
@_date: 2013-07-17 14:37:11
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] SPV bitcoind? (was: Introducing 
Would not an SPV bitcoind transfer all control on validation rules to miner?
A majority coalition of miner (pool operator) might even decide to change block reward
rules if the rest of the network only verifies POW.
Tam?s Blummer
Founder, CEO

@_date: 2013-07-31 14:31:08
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Payment Protocol: BIP 70, 71, 
Since the payment request is available from a location defined in the URI,
I think it would be appropriate to attach the PaymentACK once payment accepted by Merchant.
This would make the request and receipt available for later review.
Tam?s Blummer
Founder, CEO

@_date: 2013-06-20 09:30:29
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Missing fRelayTxes in version 
Hi Mike,
The issue with the current parser is that those fields are conditionally optional on that there will be no subsequent fields added.
If there will be further fields they will become manadory. Why not bump the version and parse the fields as mandatory from then on? This would be backward compatible and cleaner
going forward.
Tamas Blummer

@_date: 2013-06-20 10:17:04
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Missing fRelayTxes in version 
I agree that this can be deferred until there is an actual new field without any harm. But then remember to update the BIP37 too saying that it is optional only if flag added in BIPXX is not present.
Your argument is that this complexity is already there so why not preserve it. I think eliminating complexity (that has no benefit) strengthens the system.
Tam?s Blummer

@_date: 2013-06-20 10:39:10
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Missing fRelayTxes in version 
Yes it is trivial. I do not think greater complexity in the system should keep us from addressing low complexity issues.
You can't blame me or others not trying to simplify scripts, if there is such a headwind simplifying a version message.
You are right there is too much fuss about this.
Tam?s Blummer
Founder, CEO

@_date: 2013-05-27 04:57:38
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Modularizing Bitcoin 
There is a modular, modern, open source implementation of the BItcoin protocol with properties, e.g. remote wallet, you look for at bitcoingrant. It is Bits of Proof. A supported and hosted product launched at the BItcoin2013. You find the source at  and supporting documentation at Tam?s Blummer

@_date: 2013-05-28 07:16:41
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] BIP0032 
A JSON-ed version of the test vectors is here: The Bits of Proof code matching with them is at:
Tamas Blummer

@_date: 2013-11-15 06:21:26
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] moving the default display to mbtc 
Hi Jeff,
such a vote is up there since March:
Votes are in favor of it.
Advantages are obvious:
1. having satoshi as 1/100 of the main unit is familiar to people like USD and cent
2. All existing financial software can deal/store big numbers but typically only 2 decimals.
3. Split could be linked with the introduction of the ISO code in one step.
Lets get it finally done.
Tam?s Blummer
Founder, CEO

@_date: 2013-10-25 18:40:08
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Making fee estimation better 
Two thoughts:
1. Please keep it simple, miner will override it either.
2. If block construction algorithm compares alternate chains and not individual transactions,  then receiver can bump up the fee by spending the unconfirmed output again with higher fee, no need for replacement in the mempool.
Tamas Blummer

@_date: 2014-04-01 21:09:22
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Finite monetary supply for Bitcoin 
While at that let's allow coin bases to be merged from orphan blocks,
so miner are fairly rewarded even if unlucky.

@_date: 2014-04-07 19:45:30
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Why are we bleeding nodes? 
I rather prefer to start with SPV and upgrade to full node, if desired.
Tamas Blummer

@_date: 2014-04-07 20:35:40
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Why are we bleeding nodes? 
Headers first loading allows the node to run SPV from the very first minutes and it can converge to full node by time.
This is BTW how newest versions of BOP can work.
Pruning however disqualifies the node as a source for bootstrapping an other full node. BTW, did we already agree on the service bits for an archive node?
Tamas Blummer

@_date: 2014-04-07 21:00:27
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Why are we bleeding nodes? 
Once a single transaction in pruned in a block, the block is no longer eligible to be served to other nodes. Which transactions are pruned can be rather custom e.g. even depending on the wallet(s) of the node,
therefore I guess it is more handy to return some bitmap of pruned/full blocks than ranges.
Tamas Blummer

@_date: 2014-04-07 21:05:48
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Why are we bleeding nodes? 
Maybe it is not a question of the maturity of the implementation but that of the person making presumptions of it.
I consider a fully pruned blockchain being equivalent to the UTXO. Block that hold no
more unspent transaction are reduced to a header. There is however no harm if more retained.
Tamas Blummer

@_date: 2014-04-07 21:20:31
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Why are we bleeding nodes? 
Once headers are loaded first there is no reason for sequential loading. Validation has to be sequantial, but that step can be deferred until the blocks before a point are loaded and continous.
Tamas Blummer

@_date: 2014-04-07 21:36:56
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Why are we bleeding nodes? 
You have the trunk defined by the headers. Once a range from genesis to block n is fully downloaded,
you may validate upto block n. Furthermore after validation you can prune transactions spent until block n.
You would approach the highest block with validation and stop pruning say 100 blocks before it, to leave room for reorgs.
Tamas Blummer

@_date: 2014-04-07 21:50:26
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Why are we bleeding nodes? 
You have to load headers sequantially to be able to connect them and determine the longest chain.
Blocks can be loaded in random order once you have their order given by the headers.
Computing the UTXO however will force you to at least temporarily store the blocks unless you have plenty of RAM. Tamas Blummer

@_date: 2014-04-08 09:59:24
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Why are we bleeding nodes? 
Specialization of nodes is ongoing most prominent with SPV wallets and mining.
There is a need I see on my own business for software that is able to serve multiple wallets, and is multi tiered,
so the world facing P2P node can be in a DMZ. I target them with a hybrid model that is SPV plus mempool transaction validation against UTXO and use ?reference? implementations as border router.  I think that this setup will be common for enterprises and hence push for a stripped down ?reference? border router without wallet, payment protocol, GUI, RPC calls here. That border router could also serve as archive node evtl. also offering blocks at bulk e.g. through http. Enterprises that run a multi tiered environment have the bandwith to serve as archives.
Tamas Blummer

@_date: 2014-04-08 16:00:14
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] New BIP32 structure 
your suggestion has charm since ?Bitcoin seed? would even not need a global dictionary like the interpretation of the first level, since it would be self describing.
Tamas Blummer

@_date: 2014-04-09 17:37:43
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Bitcoind-in-background mode for SPV 
Such a bitcoind is what I called border router in a previous mail. Yes, SPV wallets are getting ahead of features, so people will use them also because on size just does not fit all, but all want to ensure being on the same trunk of the chain.
Therefore serious user of Bitcoin run a bitcoind as a border router and connect SPV wallets with higher functionality to that trusted node(s).
This is what I think the core should focus on: Being a lightweight superfast consensus building border router and nothing more. No wallet, no GUI, no RPC calls,
no Payment protocol and the rest.
Tamas Blummer

@_date: 2014-04-09 18:09:13
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Bitcoind-in-background mode for SPV 
I am glad that SPV wallets are discussed outside the scope of mobile devices!
Yes, SPV is a sufficient API to a trusted node to build sophisticated features not offered by the core.
SPV clients of the border router will build their own archive and indices based on their interest of the chain therefore the
border router core does not need to store (and process) anything not needed for consensus, its memory
or disk footprint would be as low as an optimal storage of UTXO.
Tam?s Blummer

@_date: 2014-04-09 18:27:13
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Bitcoind-in-background mode for SPV 
A border router that is not able to serve blocks is still protecting consensus rules, that SPVs do not.
If the network would only consist of SPV nodes only then e.g. a majority coalition of miner could increase their reward at will.
Archives need a different solution.
Tamas Blummer

@_date: 2014-04-09 19:50:03
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Bitcoind-in-background mode for 
Block header has to be available in SPV and also in an UTXO only storing core node, so why not serve it if bandwith allows.
Serving any additional information like known peer adresses or known full blocks is certainly beneficial and should be offered if at hand.
Tamas Blummer

@_date: 2014-04-10 08:04:28
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Bitcoind-in-background mode for SPV 
Hi Wladimir,
If the motivation of the SPV wallet is to radically extend functionality, as in my case, then the index is specific to the added features and the subset of the blockchain that is of interest for the wallet.
As you also point out, adding huge generic purpose indices to core would rather discourage people using full nodes due to excess requirements. I believe nothing would add more to the core?s popularity as a trusted background node to SPV than full validation at lowest possible memory, disk and CPU footprint.
Serving headers should be default but storing and serving full blocks configurable to ranges, so people can tailor to their bandwith and space available.
Tamas Blummer
Bits of Proof

@_date: 2014-04-10 09:10:36
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Bitcoind-in-background mode for SPV 
You ask why people would install this ?
I find it is odd that we who hold the key to instant machine to machine micro payments do not use it to incentivise committing resources to the network.
What about serving archive blocks to peers paying for it ?
Tamas Blummer

@_date: 2014-04-10 11:39:07
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Bitcoind-in-background mode for SPV 
I know the idea is not new. Just bringing it up to emphasize that if we don?t use it how could we expect other networks using it.
Machine to machine micro payments could become the killer application for Bitcoin.
1) There is no catch 22 as there are plenty of ways getting bitcoin without bootstrapping a full node.
2) let markets work out and not speculate what would happen.
3) Serving archive bolcks does not have to be part of core but could be a distinct service written in a language of your choice using new protocol.
As mentioned earlier I am for a stripped down core that does nothing else than consensus and stores nothing else needed for that task and offering SPV api to the wallets.
Tamas Blummer

@_date: 2014-04-10 12:44:32
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Bitcoind-in-background mode for SPV 
Thanks, Peter and you convinced me. I run away with a thought.
It?d be great to find a spot to deploy payment channels, but I agree this is not it.
Tamas Blummer

@_date: 2014-04-20 16:28:52
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] "bits": Unit of account 
People on this list are mostly engineers who have no problem dealing with magnitudes and have rather limited empathy for people who have a problem with them.
They also tend to think, that because they invented money 2.0 they would not need to care of finance?s or people?s current customs. The importance of their decisions in these questions will fade as people already use wallets other than the core.
Bring this particular discussion elsewhere, to the wallet developer. BTW the topic was discussed here several times, you have my support and Jeff Garzik?s.
Tamas Blummer

@_date: 2014-04-20 17:05:47
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] "bits": Unit of account 
Here is an earlier reference to bits:
I forgot that Alan Reiner was also supporting a unit equals to bits :
and here the earlier going back to March 2013 and a poll at that time pushing for XBT being 1 bit
Tamas Blummer

@_date: 2014-04-21 07:51:45
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] "bits": Unit of account 
I think we have two very good candidates both substantiated with arguments for their use in their context:
bit  - the word for everyday use XBT - the acronym to fit into the ISO currency set.
both meaning 100 satoshis or 1e-6 Bitcoin. I am glad that I erred, and this list finaly cares of finance customs and average Joe?s.
Tamas Blummer

@_date: 2014-04-21 08:21:17
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] "bits": Unit of account 
Here is one to please those looking for a ?fully qualified? slang word, that links with the official XBT:
xbit (spoken: ex-bit) would rationalise XBT (where X comes from supranational use) and is unique.
I personally associate from x to six also supporting the 1e-6 divisor of Bitcoin.
Regarding XBT: No matter who used it for what. The way Bloomberg will use it will define its use in finance,
and since that did not happen yet, we are not late to shape.
Tamas Blummer

@_date: 2014-04-21 11:34:42
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] "bits": Unit of account 
Thomas V: Your proposal misses the points that:
- this is about a unit with 1e-6 Bitcoins or 100 satoshis. - it is not about people who know Bitcoin and are techies, but about those who don?t and aren?t.
The reasons for such a unit are more than shifting the comma some places for convinience, but to align Bitcoin with capabilities of existing financial software and customs of finance and average people,
and ISO standard of currency abbreviations.
bit and XBT seems to check the boxes. I would love to have some feedback on xbit as per my previous mail.
Tamas Blummer

@_date: 2014-04-21 14:24:36
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] "bits": Unit of account 
xbit is close to XBT because it would be the same unit, both would mean 100 satoshi or 1e-6 Bitcoin.
xbit would be for everyday use, XBT for ISO.
I know, the XBT was used by some sites to be a synonym for BTC that is however in my opinion not yet graved in stone until it is used by e.g. Bloomberg.
Tamas Blummer

@_date: 2014-04-22 10:39:19
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Presenting a BIP for Shamir's Secret 
Extra encoding for testnet is quite useless complexity in face of many alt chains.
BIPS should be chain agnostic.
Tamas Blummer

@_date: 2014-04-22 10:43:57
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Presenting a BIP for Shamir's Secret 
It is not about taste, but the fact that BIPs are used by many chains. Alts are useful for at least for experiments, and I think that the notion of main and testnet is superseeded by a wide choice of chains.
Tamas Blummer

@_date: 2014-04-22 10:50:37
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Presenting a BIP for Shamir's Secret 
I do not suggest to encode the chain, in contrary.
I consider the encoding of main and testnet in WIF and BIP32 as legacy, that I ignore, and suggest that new BIPs should no longer carry this forward.
Tamas Blummer

@_date: 2014-04-22 17:49:10
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Presenting a BIP for Shamir's Secret 
I use several test chains while testing my software, the official test net, a standalone net in house and even chains only created on the fly for unit tests. I found no use of distinguishing serialization of keys while using any of them.
If you have some deep insights about why this is needed share it, as I am not goint to guess your valuable thoughts.
Tamas Blummer

@_date: 2014-04-22 20:29:50
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Presenting a BIP for Shamir's Secret 
Yes, it is current norm. I am questioning if we should hang on to it in BIPs.
I see testnet as a tool for a certain type of testing. Its existence is likely a consequence of Satoshi not writing unit tests and having automated integration tests, but creating a shadow chain to try things out, mostly manually.
I do not say testnet (as we know) would not be useful for certain tests. E.g. as we developed myTREZOR with slush it was useful to have a shared chain with worthless tokens and transactions we can both refer to. However for our automated tests chains-in-a-box are better as we can easily create and exactly re-create wierd situations on-the-fly.
While talking about BIP32 hierarchy use, several people argued to use a level of the hierarchy to identify the chain the key is used on. That level could identify testnet but as well an alt coin chain.
Above leads me thinking that testnet is far less important than to be addressed in every future BIP.
Tamas Blummer

@_date: 2014-04-23 07:33:32
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Presenting a BIP for Shamir's Secret 
So you agree, that SSS should not contain specific flag for testnet?
Or for that matter not even BIP32 needs them since it is not an address to send to.
Tamas Blummer

@_date: 2014-04-23 11:56:07
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] "bits": Unit of account 
The problem is ?BTC that bit tries to solve. BTC, mBTC and ?BTC are just too similiar for enyone else than engineers. The mixed use of them leads to misunderstanding. I think adoption would benefit of a single unit with easily remembered and associated name that has no smaller than 1/100 fractions called satoshis.
Tam?s Blummer
Founder, CEO

@_date: 2014-04-23 20:48:22
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] New BIP32 structure 
The most useful meta data to optimize chain scan is the key birth date, then the allowed gap size. Tamas Blummer

@_date: 2014-04-23 21:07:00
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] New BIP32 structure 
I built such a merchant system handing out BIP32 addresses. The gap size problem does not arise there since such a system has to have an extra database keeping track of requests, so there is no added cost of storing the key coordinates used by them. A scan is not needed the keys can be accessed at random order.
Tamas Blummer

@_date: 2014-04-23 21:36:39
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] New BIP32 structure 
Pieter suggested in IRC couple of months ago to append key birth to key serialization in xprv?. at unixtime format.
What about picking this idea up in BIP64? It would greatly help the importing client.
Tamas Blummer

@_date: 2014-04-23 22:01:16
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] New BIP32 structure 
This is a bit idealistic. The wallet has to know how it got the UTXO in order to be able to spend it.

@_date: 2014-04-23 22:04:35
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] New BIP32 structure 
To know the secret it needs to know which key coordinate to use that is logically the same as knowing the address it used to receive it.

@_date: 2014-04-23 22:17:12
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] New BIP32 structure 
In context of BIP32 one does not store secrets but re-create them on-the-fly if needed using key coordinates known to the UTXO.
Individual secrets per UTXO are about as irrelevant and accessible as addresses.

@_date: 2014-04-26 12:59:41
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] BIP32 "wallet structure" in use? Remove 
Yes, it is expensive but possible to discover any funds associated with a seed, provided there are set limits to:
1. gap of address use (e.g. 20)
2. depth of hierarchy (e.g. 6)
3. gap in use of parallel branches (e.g. 0) I would pick the limits in brackets above. Tamas Blummer

@_date: 2014-04-26 13:03:14
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] BIP32 "wallet structure" in use? Remove 
Actually gap in parallel branches already fails with BIP64 as it starts with m/64'/?. without having m/63'
Tamas Blummer

@_date: 2014-12-10 08:35:01
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Merged mining a side chain with proof of burn 
We spend scarce resources external to the digital realm to create Bitcoin. Real world sacrifice is needed to avoid ?nothing at stake?  and sybil attacks. With Bitcoin we now have a scarce resource within the digital realm, so it appeals my intuition to re-use it for sacrifice instead of linking again an external, real world resource. In following I outline a new mining algorithm for side chains, that burn Bitcoins to secure them.
The side chain block validity rules would require that a transaction on the Bitcoin block chain provably destroys Bitcoins with an OP_RET output, that contains the hash of the block header of the side chain. To also introduce a lottery, the burn transaction?s hash is required to satisfy some function of the block hash it was included in on the Bitcoin block chain. For example modulo m of the burn transaction hash must match modulo m of the block hash, that is not known in advance.
Those who want to mine the side chain will assemble  side chain block candidates that comply the rules of the side chain, then a Bitcoin transaction burning to the hash of the block candidate and submit it to the Bitcoin network. Should he burn transaction be included into the Bitcoin block chain and the Bitcoin block?s hash satisfy the lottery criteria, then the block candidate can be submitted to extend the side chain.
A side chain block header sequence would be accepted as side chain trunk if a sequence of Bitcoin SPV proofs for burn transactions prove, that linked blocks have the highest cumulative burn, if compared to alternative sequences. The Bitcoin miner will include burn transactions because they offer Bitcoin fees. Bitcoin miner can not selectively block side chains since the hashes associated with the burn do not disclose which side chain or other project they are for. Here you have a ?merged mining? that does not need Bitcoin miner support or even consent.
Mining difficulty of the side chain could be adjusted by stepping up the required burn and/or hardening the criteria that links a burn proof transaction with the bitcoin block hash it is included in.
The difficulty to mine with burn would be dynamic and would also imply a floating exchange rate between Bitcoin and the side coin.
Tamas Blummer
Bits of Proof

@_date: 2014-12-11 15:56:24
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Merged mining a side chain with proof of 
Isodor: Rational Miner will include burn transaction for fee, no doubt. Censoring transactions is against Bitcoin?s core values, unlikely to get wide support for any form of that.
Patrick: Mining is at cost even if following the rules. No change to that.
Tamas Blummer
Bits of Proof

@_date: 2014-12-15 11:21:01
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Merged mining a side chain with proof of 
Burn mining side chains might be one of the foundation ideas for that ecosystem, enabling permission-less merge mining for
anyone with interest in a side chain.
I am puzzled by the lack of feedback on the idea.
Tamas Blummer
Bits of Proof

@_date: 2014-12-15 14:06:32
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Merged mining a side chain with proof of 
Thanks for the research, I am glad that the idea, that proof-of-burn can ?transfer" proof-of-work was discussed earlier, as those discussions give some attack vectors that I can reevaluate in a new context, that is side chains. I think that the lottery component I suggested, makes it much more resilient to ?outspend? attack, since
the attacker not only needs to outspend but win the lottery for a reorg. This raises the cost of the attack
by magnitudes above the regular miner burn cost.
In addition, I suggest the burn transaction to include the Bitcoin block height, thereby disabling re-use of a burn,
for a later reorg.
Tamas Blummer
Bits of Proof

@_date: 2014-12-16 09:28:02
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Merged mining a side chain with proof of 
The output has to be burned  otherwise there is no cost of expressing
any number of alternate opinions the same time. Tamas Blummer
Bits of Proof

@_date: 2014-12-16 13:30:04
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Merged mining a side chain with proof of 
Let me be more concrete in implementation details: 1) burn transaction sends at least n satoshis to an OP_RETURN h, 2) h mod m matches the bitcoin block hash mod m, for the block the burn transaction was mined into.
3) The side chain block header hashes to h and also contains the bitcoin block hight.
4) a side chain block releases x new side coins
Since the burn hash does not reveal in advance which side chain it will be used for, the Bitcoin miner can not selectively block burn mining. They will include loosing bets for the Bitcoin fee. Bitcoin miner have no advantage over independent burn miner of the side chain.
Anyone who issues a burn transaction that complies the rules 1-3 has 1/m the chance to win the next block on the side chain. This implies a fair exchange rate of n*m satoshis = x side coins (at the margin).
Should two burn transactions fulfill the mod m lottery criteria, then we have a competing fork on the side chain. Just as for Bitcoin, the next block(s) will pick the winner. To contain fork rate, the parameter m would have to be adjusted dynamically, similar to Bitcoins difficulty. It needs to increase if fork rate increases and decrease if no valid block is burned with Bitcoin blocks. Unfortunately SPV can only prove the existence of a transaction, but not the non-existence of an alternative. Therefore the fork rate within a block cycle can not be evaluated with SPV proofs. Rational burn miner who frequently faces and loses head-to-head runs with a competing forks would increase his bet for the next burn cycle, as increasing the individual bet amount has the advantage that if he wins his victory is more stable. Remember the side chain trunk is selected as the one with highest cumulative burn.
Consequently cumulative burn within an adjustment period (measured in Bitcoin blocks) is expected to rise in face of high fork rate. If the sample period burn exceeds a target, then it would trigger a rise to the lottery criteria m, reducing the fork rate and vs.
Tamas Blummer
Bits of Proof

@_date: 2014-12-18 17:23:53
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Merged mining a side chain with proof of 
Moving further with the Idea:
Alternative to re-adjusting the lottery criteria, the side chain block candidate could be required to prove a work to be eligible for the burn lottery. A mix of required burn, work and luck could be tailored to achieve the desired "51% resilience? of the side chain. The side chain could use work for regular blocks and a much higher ?difficulty? parent chain burn lottery for less frequent ?checkpoints". Eg. the side chain difficulty of 1/n of Bitcoin is attainable for a small side chain miner community to advance its chain at Bitcoin?s speed. Simultaneously the block candidates
would be submitted to a Bitcoin burn lottery with 1/n odds, so the security of the side chain roughly equals that of Bitcoin at every successful burn mined checkpoint.
Tamas Blummer
Bits of Proof

@_date: 2014-02-24 19:13:29
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] On OP_RETURN in upcoming 0.9 
It costs at least 5430 satoshis to create an output at the moment. Is the same spam limit applied if the script is OP_RETURN?
If not, I would be concerned od opening a cheap spam.
Tamas Blummer

@_date: 2014-01-21 06:43:49
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] BIP0039: Final call 
The the current spec with TREZOR's wordlist is also implemented by Bits of Proof
and deployed in two projects, one being btc1k also open sourced at our github.
Tam?s Blummer

@_date: 2014-06-24 13:48:05
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Plans to separate wallet from core 
I think there are three typical uses:
1. Building consensus on the block chain. This is what the core is for.
2. Single user wallets. This is where SPV alone is good.
3. Services e.g. exchange, payment processor .... This is where core + indexing server talking SPV to core is the right choice
Tam?s Blummer
Founder, CEO

@_date: 2014-03-13 16:17:13
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] moving the default display to mbtc 
Jeff's arguments are understood and supported by those who worked in finance.
Existing financial applications have often problems dealing with more than 2 decimals.
People who work in finance are used to two decimals.
Neither systems nor people in finance have a problem with large numbers though.
For above practical reasons I am also for moving to a unit that equals 100 satoshi.
I heard the name bit for it which I like.
Tam?s Blummer
Founder, CEO
Bits of Proof

@_date: 2014-03-13 17:23:07
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] moving the default display to mbtc 
Not suprised that people dealing with real world finance problems and people who are not engineers come to the same conclusion. Welcome Alan!
Why not add 'bit' as an option or even default to Armory?
Tamas Blummer
Founder, CEO
Bits of Proof

@_date: 2014-03-13 17:30:20
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] moving the default display to mbtc 
BTW, its not like this would be the first time this was raised, instead the "ship left" while ignoring arguments.
The idea of is up there for votes since March 2013 and received the most votes. I remembered this last time on this list here:
Tamas Blummer
Founder, CEO
Bits of Proof

@_date: 2014-03-14 15:14:15
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] moving the default display to mbtc 
You give them a hard to interpret thing like mBTC and then wonder why
they rather look at local currency. Because the choices you gave them are bad.
I think Bitcoin would have a better chance to be percieved as a currency
of its own if it had prices and fractions like currencies do. 3.558 mBTC or 0.003578 BTC will never be as accepted as 3558 bits would be.
Tamas Blummer
Bits of Proof

@_date: 2014-03-14 15:57:37
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] moving the default display to mbtc 
you miss the point Andreas. It is not about the magnitude but about
the form of a price.
A number with no decimals or with two decimals is percieved as a
price in some currency. A number with more than two decimals is just not percieved as a price
but as a geeky something that you rather convert to local currency.
Tamas Blummer
Bits of Proof

@_date: 2014-03-14 16:12:45
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] moving the default display to mbtc 
I think you want to misunderstand me Andreas.
It is astonishing arrogance to define the units because we in Bitcoin are used to
some wierd notation and ignore that the vast majority of population and  financial software in existence does not have a notion of prices
with more than two decimals.
With 1 bit = 100 satoshi, we would solve this problem for good. Instead mBTC is a confusing step in-between.
Tamas Blummer

@_date: 2014-03-27 08:09:06
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] New BIP32 structure 
We had a similar meeting with Andreas Schildbach (Android Bitcoin Wallet), Jan Moller, Andreas  Petersson (Mycelium), Thomas V (Electrum), Tamas Blummer, Tamas Bartfai (Bits of Proof)
at the Inside Bitcoin Conference in Berlin.
I remember that there were different opinions on how to use a hierarchy and it did seem to me they could eventually be "standardized" for the retail customer but definitelly not for corporate use,
where hierarchy will certainly map to organisational hierarchy or cost centres.
A notable suggestion was to instead of building a directory of magic numbers (like 0 for Bitcoin, 1 for Litecoin etc) use a hash of the word "Bitcoin", "Litecoin", "Dogecoin", so collosion is unlikely and
cetral directory is not needed.
Tamas Blummer

@_date: 2014-03-27 17:07:26
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] New BIP32 structure 
I think not all alts (will) have magic numbers, at least not those defined e.g. with colored coins on top of an other chain.
Also note that the index should have MSB cleared as it would otherwise indicate private derivation. Tamas Blummer

@_date: 2014-03-28 12:30:39
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] BIP 70 refund field 
Instead of a payment request and refund, businesses would actually need a payment channel, that once established allows for multiple payments back and forth between counterparties.
One might have a number of open channels until the business relationship is assumed. The customer might decide to close the channel explicitelly once he does no longer expect a payment. Tam?s Blummer

@_date: 2014-03-28 12:45:03
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] BIP 70 refund field 
Yes, you begin to see that the payment protocol, as is has a too narrow scope of a web cart - customer, and does not even fit that.
It is not about payment requests but about business relationships. We need a protocol that deals with that concept instead of individual requests,
so we really get out of the hell of addresses. Business relationships are terminated by the parties at their own and not bey algorithms and timeouts.
Tamas Blummer

@_date: 2014-03-28 12:54:31
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] BIP 70 refund field 
It is not more effort than an auto remembered call-in phone number. You delete if you do not care. The difference however is that it would be a clean protocol for repeated payments in both directions for whatever reason, where "refund" is and "payment" are not special compared to "1st installment", "overpayed back" or "tip"  or whatever extra charge arises later.

@_date: 2014-03-28 13:55:57
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] BIP 70 refund field 
What is too abstract in a contact list ? If the payment comes with a tag like refund the UI could display as such and if it comes with e.g. VAT then that.

@_date: 2014-03-28 14:09:34
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] BIP 70 refund field 
The difference is the concept of setting up a channel that allows both parties to create valid addresses of the other by exchanging some kind of master keys. The initial handshake with the protocol would agree on tags of individual address indexes if used. The wallets would have to observe those agreed inidices and evtl. extend range. Payments could go back and forth. Either party might delete the channel information and stop observing keys as soon as he does no longer expect a payment from the other. This would be an explicit operation, like deleting a contact.
It was an example label. I would not be suprised if with widespread use of payments some government would require VAT collected separately. It is just a guess and has no weight in my prior arguments.

@_date: 2014-03-28 14:18:10
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] BIP 70 refund field 
May I ask how the current payment protocol is supposed to handle salaries? I hope you do not assume the employee creates a payment request, since he does not
even calculate the amount. There you go where a channel I described is definitelly needed.
Tamas Blummer

@_date: 2014-03-28 15:27:35
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] BIP 70 refund field 
I have nothing against incremental development. This will however not pick up until it offers some incremental benefit compared to current payment processor solutions, such as e.g.
1. Symmetrical. One can also offer a payment.
2. Aggregating and Netting. Handle multiple installments and/or net with previous cash flows.
3. More secure. One has a check not only on the payment address (which already has one with https:// in the web shop scenario it is currently able support) but not on the refund.

@_date: 2014-03-28 16:26:57
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] BIP 70 refund field 
Supporting BIP70 by BitPay or BopShop is a cake since it does no more then they did without it.
I am not in opposition but see no reason to be enthusiastic about it. I will once the spec goes
further than what was possible before.

@_date: 2014-03-28 17:45:40
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] BIP 70 refund field 
Yes that would be neat and I would not want to spoil the show. I wish the established identity could be re-used though to send and much more.

@_date: 2014-03-29 09:34:25
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Presenting a BIP for Shamir's Secret 
Great stuff Matt!
I have an implementation of Shamir's Secret Sharing here: What was missing was nice serialization. Thanks a lot for defining and starting the process.
 I will shortly adapt my code and check your test vectors.
Tamas Blummer

@_date: 2014-03-29 09:44:53
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Presenting a BIP for Shamir's Secret 
Hi Matt,
I used Shamir's Secret Sharing to decompose a seed for a BIP32 master key, that is I think more future relevant than a single key.
Therefore suggest to adapt the BIP for a length used there typically 16 or 32 bytes and have a magic code to indicate its use as key vs. seed.
Tamas Blummer

@_date: 2014-03-29 14:38:53
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Presenting a BIP for Shamir's Secret 
This is why my motivation is rather secure backup, not multisig. Instead of storing encrypted seed in one location and the passphrase for it in an other location, one can just store two shares in two places.

@_date: 2014-03-29 18:37:44
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Presenting a BIP for Shamir's Secret 
I had Matt's answer already, see below, but then I recognized that the group was not cc:-d, so I repeat:
It would help on the user interface to include into individual shares:
1. Number of shares needed
2. A few bytes fingerprint of the secret so shares that likely belong together can be identified.
I wonder how others weight security vs. usability in these questions.
Tamas Blummer
I intentionally omitted that information because it's a security risk. If an adversary gains control of one share and can see exactly how many more shares he needs, he may be able to plan a better attack. If he is clueless about how many shares he needs, then he may not be able to execute an attack at all because he may not know whether his information about what shares exist and where is complete.

@_date: 2014-03-29 19:16:28
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Presenting a BIP for Shamir's Secret 
I also think that we can add usability features if the underlying secret remains well protected.
I do not think there is any reason to assume that the knowledge of the degree of the polynomial, would aid an attacker.
Similarly a fingerprint of the secret if it is unrelated to the hash used in the polinomyal should leak no useful information,
The length of such fingerpring (say 4 bytes) and the degree (1 byte) does not seem a big overhead for me.
Remember that the biggest obstacle of Bitcoin is usability not security.
Tamas Blummer

@_date: 2014-03-29 20:49:23
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] Presenting a BIP for Shamir's Secret 
The paper does not mention anything special about the polynomial to use other than:
 "random polynomial f of degree t - 1 such that d = f(0)"
Do you have reasons to assume that there is more to this? Since this is compatible
with Matt's proposal.

@_date: 2014-05-03 06:23:24
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] moving the default display to mbtc 
Excellent move Jeff.
Best would now be to establish XBT as the ISO code for bits.
Tamas Blummer

@_date: 2014-05-03 18:10:22
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] "bits": Unit of account 
bit has a lot of meanings to geeks, so what.
bit means for average people:
- something very small, that 100 satoshi is. - part of the name Bitcoin
- easy to get conversion 1 coin = 1 million bits = 1 Bitcoin
Tamas Blummer
Founder, CEO

@_date: 2014-05-04 08:36:02
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] "bits": Unit of account 
what is missing is a decision to pull for the reference client. Or did I missed that bit?

@_date: 2014-11-06 22:58:04
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] The difficulty of writing consensus 
Thanks Peter,
Having tried to write a bug-for-bug compatible code with Satoshi, I can only second that it is rather close to impossible. The aim of BIP62 is noble, still it does not feel right for me to increase the complexity of the code with e.g. soft-fork-ready versioning.
Freezing the consensus code, studying its bugs appears more appropriate to me. What we learn could define a hard fork or a better
chain we migrate to as discussed by blockstream.
Tamas Blummer

@_date: 2014-11-07 09:07:47
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] The difficulty of writing consensus 
forking would work best with a freeze of the consensus code. Do you see any chance for that?
Tamas Blummer

@_date: 2014-10-06 05:22:51
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] The Bitcoin Freeze on Transaction Attack 
Note that the problem might arise also by a bug / accident and not as an attack.
Since value spent is not part of the signature it is easy to create an arbitrary fee by a defective wallet software.
Collecting that huge fee might provide a higher incentive to miner than the block subsidy on the trunk.
Assuming miner are fully rational, they might even form a temporary coalition to claim the fee:
The miner who mines forking block might offer part of the fee gained in a similar transaction to
other miners, so they help to extend his fork. A sufficiently high stake could trigger a long
fork ?battle? of ad-hoc coalitions.
Addressing the known bug of the signature hash, that it does not include the value spent,
would have other positive effects, e.g. for resource limited hardware wallets.
Interpretation of an OP_NOP for a value hashing signature check were suggested by Alan Reiner
discussed earlier on bitcointalk.
Tamas Blummer

@_date: 2014-10-06 06:29:15
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] The Bitcoin Freeze on Transaction Attack 
you can call this an ORBS attack or an attempt of ad-hoc coalition forming for a fork.
Preparation Step:
Include a transaction sending a sizable amount between two of your own addresses in every block.
Miner can do this at zero cost in their own blocks.
Embed into the preferred fork a transaction double spending the regular do-nothing transaction with one that offers a sufficiently high fee. This offers inceptive to rational miner to join the ad-hoc coalition for that fork.
Attempting to form an ad-hoc coalition using above steps is open to anyone, just cheaper and easier to execute for a miner. Fortunately cost for (cumulative) proof-of-work creates a lower bound to the incentive that need to be offered. So your worry
of times where block subsidy is low is unwarranted as cost of POW will be high.
I do not think ?disallowing? the implementation of rational mining is a viable option, since no one needs permission to implement whatever optimization he thinks is profitable and within the rules.
Tamas Blummer

@_date: 2015-08-14 18:37:57
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] libconsensus assertion fails if used in multiple 
We integrated libconsensus into bits of proof. It works well, in-line for all test cases with our Java engine and is about 50% faster on a single thread.
The performance advantage unfortunatelly reverses if libconsensus is executed on several threads simultaneously as we do with the Java engine, since an error:
arises under that stress.
I guess that the cause is that thread callbacks as advised for OpenSSL on  are not registered.
Registering those however would require access to OpenSSL functions, not exported from the lib.
I?d be thankful for a pointer to a workaround.
Tamas Blummer

@_date: 2015-08-16 18:07:21
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Bitcoin XT 0.11A 
Being a bitcoin software developer an entrepreneur for years I learned that success is not a direct consequence of technology and is not inevitable.
BitcoinXT manifesto ( should resonate with many fellow entrepreneurs.
I applaud Mike and Gavin for creating that choice for us.
Tamas Blummer

@_date: 2015-08-16 20:15:26
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Bitcoin XT 0.11A 
Hi Adam,
I welcomed XT for its declared focus on usability with current means.
I think there is also more room for non-consenus relevant P2P protocol flavors than a single code base can accommodate.
XT is also as Jeff just tweeted a relief valve.
It became important, that Bitcoin is able to evolve even if there are conflicting educated opinions.
If a review process serves decision making, then I?d be glad to participate.
Tamas Blummer

@_date: 2015-08-18 12:31:52
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] libconsensus assertion fails if used in multiple 
Thanks a lot Cory for following through the test case and producing a patch.
I confirm that libconsensus is now running stable within the Bits of Proof stack,
in-line with test cases we use to verify the java implementation of the script engine,
that are BTW borrowed from Bitcoin Core.
The performance of libconsensus is surprisingly close to the java one.
Validating a 2-of-2 a multi-sig  transaction runs at 1021 ops/sec with java and 1135 ops/sec
in libconsensus. This is on a 2.2GH i7 laptop (4 hyper threading cores used by 8 threads).
Another nice demonstration why one should not trade in advances
of languages for the last decades for a marginal gain of performance with C/C++,
I assume thereby that Bouncy Castle? EC lib s not superior to OpenSSL's.
I disagree that the problem was rare in the real-world, it should affect any modern
implementation that validates transactions parallel in multiple threads.
Aborting also does not make the problem less severe in my opinion.
Therefore hope the pull will be included into Core with next release.
I can?t assign a timeline to ?near future" secp256k1 integration. Can you?
Tamas Blummer

@_date: 2015-08-20 09:14:11
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Libconsensus separated repository (was Bitcoin 
separating script engine into libconsensus was very helpful, since wrapped the piece of consensus
that would least likely to be captured exactly with an implementation from scratch. Thank you for your
effort there.  Bits of Proof now uses its own or alternatively libconsensus for full validation.
I am sceptical however that a ?full? consensus lib extracted from satoshi?s code is worth trying.
Not because it was impossible, but because the result would not be higher quality, if measured on agreement
with satoshi, than other re-implementations. It would actually be lower quality because of the antique tool set.
The rules outside script engine are simpler, therefore much easier to capture exactly. They are however
scattered around in the spaghetti and are often just a single if statement, also repeated elsewhere.
You would either have to very extensively refactor the code, that unlikely goes through as a PR, or
do what me and others did. Read satoshi code and rewrite the same. You have
a slight advantage of copy-paste small fragments, but I doubt the consensus relevant advantage of that.
Tamas Blummer

@_date: 2015-08-20 10:35:13
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Libconsensus separated repository (was Bitcoin 
Every re-implementation, re-factoring even copy-paste introduces a risk of disagreement,
but also open the chance of doing the work better, in the sense of software engineering.
My goal is different. Compatibility with Bitcoin is important as I also want to deal with Bitcoins,
but it is also imperative to be able to create and serve other block chains with other rules and for those
I do not want to carry on the legacy of an antique tool set and a spaghetti style.
Bits of Proof uses scala (akka networking), java (api service), c++ (leveledb and now libconsensus)
and I am eager to integrate secp256k1 (c) as soon as part of consensus. The choices were
made because each piece appears best in what they do.
Tamas Blummer

@_date: 2015-08-20 16:25:21
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Bitcoin XT 0.11A 
POW is by design the voting mechanism for the valid chain continuation.
Many rightfully dislike that the same voting mechanism is used on the validity rules, since ideally
validators (non-mining full nodes), SPV user and even those having an investment in their cold wallet
would all have a vote.
That ideal voting mechanism is not yet in the protocol.
Before XT we used discussions and an informal consensus of those with commit access to github to evolve Bitcoin.
The decision, not the discussion, is now suggested to be replaced with POW vote with XT.
It is not hard to see problems with both approaches.
If XT comes closer to miner majority, validators will also be forced to take side, so they will be able to express
their vote. I think that most Bitcoin entrepreneurs will pick XT if Core has no comparable offer
to scale transactions per second.
XT, Not-XT and a Core with some not-BIP101 offer will potentially set the stage for the perfect hard fork storm.
I still believe, that the idea of Bitcoin is powerful enough to weather that storm.
Tamas Blummer

@_date: 2015-08-20 23:26:19
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Libconsensus separated repository (was Bitcoin 
I know what you mean as I already have such a component with pluggable block store and networking.
While you are at it you could aim for isolation of bitcoin specific decisions and algos from generic block chain code.
The magnitude of refactoring you would have to do to get there from main.cpp and the rest of the hairball
is harder than a re-write from scratch, and the result will not be impressive, just hopefully working.
I think a slim API server was a lower hanging fruit in Core?s case.
BTW, support for refactoring is an example where you see if your tool set is modern.
Tamas Blummer

@_date: 2015-08-21 08:46:26
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Libconsensus separated repository (was Bitcoin 
Thinking in Bitcoins only on the level of technology unnecessarily narrows your view.
OK, I hope to be pleasantly surprised.
Tamas Blummer

@_date: 2015-08-21 22:50:58
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] A solution to increase the incentive of running a 
I like your thinking about the implicit reward of full nodes. It was not perceived as sufficient by many, hence full node counts were falling.
This might reverse now as the implicit value of validating yourself however becomes higher in a heterogenous environment, that is if there are hard forks in the wild.
Actually pooled mining became an option through the homogenous nature of the network.
Tamas Blummer

@_date: 2015-08-22 13:04:44
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Libconsensus separated repository (was Bitcoin 
I do want something better, but not for the focus you have.
Not because what you produce was not high quality, but because quality is achieved at a very
high cost and is hard to uphold over generations of developer. You focus on a single use case
while there are many out there for distributed ledgers.
I think in an infrastructure for enterprise applications, building consensus on the ledger is a
cornerstone there, but is only a piece of the solution. I built several commercially successful
deployments where I delegated the consensus building to a border router, a Bitcoin Core,
then interfaced that trusted peer with my  implementation that accepted Core?s decisions
in an SPV manner. One might think of this setup as wasteful and unsuitable for ?small devices?
therefore an example of centralization people here try to avoid.
Enterprises have sufficient resources. Solving the business problem is valuable to them even at
magnitudes higher cost than a hobbyist would bear.
For mainstream adoption you need to get enterprises on board too, and  that is what I care of.
Enterprises want code that is not only high quality, but is easy to maintain with a development
team with high attrition. One has to take whatever help is offered for that, and one is modern
languages and runtimes.
Bits of Proof?s own implementation of the scripts was not practically relevant in my commercially
successful deployments, because of the use of a border router, but it helped development,
enabling easier debug and precise error feedback esp. end even after Core had a reject message.
I integrated libconsensus only for the hope that is significantly fastens application side tx verification,
 which it has turned out it does not, until secp265k1 is integrated.
I would likely use an other extended libconsensus too, but do not think there was a dependency on
that for enterprise development.
It would help there more to have a slim protocol server, no wallet, no rpc, no qt but a high
performance remoting API.
Storage and validation is non-trivially interconnected, but I now the separation can be done,
since I did it.
Excuse me, but function pointers is a pattern I used in the 80?s. I know that they are behind
the curtain of modern abstractions with similar use, I still prefer not to see them again.
Tamas Blummer

@_date: 2015-08-23 08:42:17
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Libconsensus separated repository (was Bitcoin 
I see the huge amount of sweat and love that went into core and it actually hurts to see that most is expended in friction and lack of a vision for the software architecture.
To be concrete, this was my plan if dealing with the Core code base:
1) I'd consider the separation of networking and storage as suggested for a future extended libconsensus low priority, as their design should be (are) dominated by the need of the consensus logic only.
2) create an API to the consensus+networking+storage service that is not at the C++ language level but some scaleable cross-platform remoting, like eg. ZeroMQ.
This API should be minimal and simple, assuming that one fully trusts the node answering it. This API would unlock user land development by distinct teams with diverse technologies.
3) move the wallet, QT and RPC and other backward compatibility stuff (if e.g. there is some mining support) in-top of the new API and into distinct source code repositories.
Tamas Blummer

@_date: 2015-12-10 13:54:30
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Segregated Witness features wish list 
Note that the unused space in coin base input script allows us to soft-fork an additional SW Merkle tree root into the design,
therefore please make sure the new SW data structure also has a new slot for future extension.
Tamas Blummer

@_date: 2015-02-01 10:33:48
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] var_int ambiguous serialization consequences 
I wonder of consequences if var_int is used in its longer than necessary forms (e.g encoding 1 as 0xfd0100 instead of 0x01)
This is already of interest if applying size limit to a block, since transaction count is var_int but is not part of the hashed header or the merkle tree.
It could also be used to create variants of the same transaction message by altered representation of txIn and txout counts, that would remain valid provided signatures validate with the shortest form, as that is created while re-serializing for signature hashing. An implementation that holds mempool by raw message hashes could be tricked to believe that a modified encoded version of the same transaction is a real double spend. One could also mine a valid block with transactions that have a different hash if regularly parsed and re-serialized. An SPV client could be confused by such a transaction as it was present in the merkle tree proof with a different hash than it gets for the tx with its own serialization or from the raw message.
Tamas Blummer
Bits of Proof

@_date: 2015-02-01 12:42:05
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] var_int ambiguous serialization 
Thanks for the clarification. Yes, I referred to CompactSize using the lingo of I am not sure if it is current concern. Apparently an exception is thrown if non-canonical CompactSize in a transaction s parsed.
Is it ensured that transactions are always parsed before computing their hash?
Tamas Blummer

@_date: 2015-02-12 08:23:29
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] replace-by-fee v0.10.0rc4 
An important use of the core is being border router to proprietary software, that is usually indexing the block chain and mempool. That software is also assuming that double spends are not relayed by the core.
To remain useful as border router, the replace-by-fee patched core should only relay double spend if it actually replaces an earlier transaction, as otherwise the replace logic that is according to your commit more than just fee comparison, would have to be replicated in the proprietary stack and mempool might get out of sync with that of the border router. Tamas Blummer
Bits of Proof

@_date: 2015-02-12 09:27:22
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] replace-by-fee v0.10.0rc4 
Since RPC interface does not scale to serve a multi user service.
In absence of better alternative, the interfaces used by a proprietary extension are usually the same as in P2P consensus.
POW is used to figure the longest chain and until now broadcasted transactions were assumed the one and only. These simple rules ensure a consensus between the proprietary stack and the border router, and that is the consensus I referred to.
You are right that the assumption about the one and only transaction have to be relaxed. Broadcasting double spend only if it is actually replacing an earlier - for whatever reason, would simplify internal consensus logic .
Tamas Blummer
Bits of Proof

@_date: 2015-02-12 10:01:48
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] replace-by-fee v0.10.0rc4 
Does it broadcast a double spend only if it IS replacing an earlier? If yes, I am fine with it.
Tamas Blummer

@_date: 2015-02-12 13:54:48
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] replace-by-fee v0.10.0rc4 
Peter?s pull request might be a foot gun, but we are here to find out. One can?t claim Bitcoin core code is there to fork and then be disappointed if some really do it.
I am not sure protecting unconfirmed transactions ranks higher than fostering innovation not to depend on the same. Tamas Blummer

@_date: 2015-02-12 15:04:35
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] replace-by-fee v0.10.0rc4 
You can not consider the outcome resulting by replace-by-fee fraudulent, as it could be the world as observed by some.
Some other?s might have seen the replaced transaction, but that only indicates for sure that the signer is fraudulent.
What should a node do that really cares of good reputation? Ignore both to be on the safe side?
Tamas Blummer

@_date: 2015-02-12 15:25:09
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] replace-by-fee v0.10.0rc4 
Assume a wallet that sends double spend of the coin spent for services with higher fees to some of its nodes simultaneously.
Merchants will catch and reject most of the attempts, but that will not stop the scheme in a setup where customer are anonymous and distant.
Miner will see a mixed picture and will struggle to act ?honestly? on a statistical measure.
Tamas Blummer

@_date: 2015-02-14 15:23:47
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] On Rewriting Bitcoin (was Re: 
You did not address me but libbitcoin. Since our story and your evaluation is probably similar, I chime in.
We have seen that the consensus critical code practically extends to Berkley DB limits or OpenSSL laxness, therefore
it is inconceivable that a consensus library is not the same as Bitcoin Core, less its P2P service rules, wallet and RPC server.
The Core code base is unfriendly to feature extensions because of its criticality, legacy design and ancient technology. It is also a commodity
that the ecosystem takes for granted and free. I honestly admire the core team that works and progresses within these limits and perception.
I am not willing to work within the core?s legacy technology limits. Does it mean I am dicking around? I think not.
It was my way to go down the rabbit hole by re-digging it and I created successful commercial products on the way.
It is entirely rational for me to focus on innovation that uses the core as a border router for this block chain. I am rather thankful for the ideas of the side chains, that enable innovation that is no longer measured on unapologetic compatibility with a given code base, but its services to end user.
Tamas Blummer
Bits of Proof

@_date: 2015-02-15 18:13:06
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] On Rewriting Bitcoin (was Re: 
I thought I was clear, that I am using Bitcoin Core as border router talking to its P2P interface.
The reimplementation of consensus code helped me to deeply understand the protocol, aids debugging
and now comes handy to create a side chain.
Acquire some before you claim its useless.
Tamas Blummer

@_date: 2015-02-19 06:22:41
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] On Rewriting Bitcoin (was Re: 
Libconsensus will create an in-process alternative to the border router setup I currently advocate in a production environment.
It is not sufficient yet, since only checking scripts, but is the move I was long waiting for. I  launched a Lighthouse project to add Java Language Binding to lib consensus. Let's turn the debate to a constructive vote.
See on Tamas Blummer

@_date: 2015-02-19 06:27:27
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] On Rewriting Bitcoin (was Re: 
I should have added the project description here, as above is only readable with lighthouse:
Java Language Binding for Core Consensus Library
Bitcoin Core 0.10.0 comes with a library for external services that validates Bitcoin transactions with the code base of the core.
The proposed language binding would unleash innovation of JVM application developer without raising concern of a network fork through incompatible alternate implementations of the protocol.
The language binding would be written with lightweight, immutable, self contained data classes that use only language standard libraries, therefore suitable for any service framework.
Tamas Blummer

@_date: 2015-02-19 15:09:06
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] On Rewriting Bitcoin (was Re: 
I meant voting by pledging on the lighthouse project, not here on the list. Sorry for not stating this explicitelly.
The language binding would be an independent and separately hosted project only using the C interface of the libconsensus library.
Tamas Blummer

@_date: 2015-02-20 17:38:09
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] bloom filtering, privacy 
Such a bloom filter was present in the Bits of Proof block store in its last public version, so the idea obvious, but not new.
It did support well scanning for BIP32 addresses as the query set extends while progressing. Tamas Blummer

@_date: 2015-01-20 18:44:31
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] The legal risks of auto-updating wallet 
Knowing the private key and owning the linked coins is not necessarily the same in front of a court.
At least in german law there is a difference between ?Eigentum' means ownership and ?Besitz? means ability to deal with it.
Being able to deal with an asset does not make you the owner.
Tamas Blummer

@_date: 2015-01-20 18:56:28
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] The legal risks of auto-updating wallet 
I am not a lawyer, just thinking loud.
I think that technology is a strong argument before court, but I suspect that it is just that, as of now.
Tamas Blummer

@_date: 2015-01-20 19:48:38
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] The legal risks of auto-updating wallet 
In contrary. Not being in the jurisdiction of the wallet provider makes it harder for the user to reclaim funds taken by the wallet provider.
The legal hurdle to force confiscation through a wallet provider might also be lower if the target user is not domestic.
Tamas Blummer

@_date: 2015-01-23 16:31:46
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] SIGHASH_WITHINPUTVALUE 
Not a fix, but would reduce the financial risk, if nodes were not relaying excessive fee transactions.
Tamas Blummer

@_date: 2015-01-23 17:08:50
@_author: Tamas Blummer 
@_subject: [Bitcoin-development] SIGHASH_WITHINPUTVALUE 
You mean an isolated signing device without memory right? An isolated node would still know the transactions substantiating its coins, why would it sign them away to fees ?
Tamas Blummer

@_date: 2015-11-17 14:10:17
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Dynamic Hierarchical Deterministic Key Trees 
Hi Eric,
Would you please enumerate, or point to, arguments that discourage the use of a key both for signing and for derivation of a deeper level of the hierarchy ?
Tamas Blummer

@_date: 2015-11-17 14:54:19
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] [patch] Switching Bitcoin Core to sqlite db 
Isolating storage from the rest of consensus code is technically desirable, but implementations using different storage will be unlikely bug-for-bug compatible,
hence able to split the network.
Such split was disastrous on the network level if partitions were of comparable magnitude - as was the case in the March 2013 fork between versions of Bitcoin Core.
This means high level implementation diversity was great, provided we would get there without blowing up the network on the way from monoculture to true decentralization of code.
Libconsensus is immensely valuable to get diversity, as it makes alternate implementations bug-for-bug compatible for a big part of the consensus code.
Tamas Blummer
