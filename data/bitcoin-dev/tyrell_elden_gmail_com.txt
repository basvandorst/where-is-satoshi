
@_date: 2012-12-23 16:38:09
@_author: Elden Tyrell 
@_subject: [Bitcoin-development] Payment Protocol Proposal: 
On 2012-12-21 17:05:21 +0000, Stephen Pair said:
Your distinction between "identity" and "trust-based identity" is one of the most important insights to emerge from this thread.  Thank you for pointing this out.

@_date: 2012-01-01 21:04:03
@_author: Elden Tyrell 
@_subject: [Bitcoin-development] does "stubbing" off Merkle trees reduce 
Satoshi's paper mentions that storage requirements for the blockchain can be reduced by deleting transactions whose outputs have been spent.
If I understand correctly, this technique can only be used for reducing *storage* requirements, not *bandwidth* needed for the initial chain download by a high-security client that doesn't trust any of its peers

@_date: 2012-01-02 14:23:16
@_author: Elden Tyrell 
@_subject: [Bitcoin-development] does "stubbing" off Merkle trees reduce 
Er, yes, this is what I meant; I guess I should have been more specific.
So, a paranoid client cannot confirm reciept of coins until it has an unstubbed copy of the entire chain.  It can do other things (like send coins) using a stubbed chain, but it needs the whole unstubbed chain in order to be sure that incoming coins haven't already been spent.
Thanks for confirming this.

@_date: 2012-01-02 17:39:09
@_author: Elden Tyrell 
@_subject: [Bitcoin-development] does "stubbing" off Merkle trees reduce 
Neat!  I had a similar idea but you've clearly beat me to [a big part of] it.
I'm not so sure about that.  If you accept X successor blocks as proof that none of the transactions in a block re-used an output, then the cost of attacking is X*50BTC since the hashpower needed for the attack could have earned that much reward.
However, an attacker could use the same faked X-block sequence to attack multiple clients by putting several double-spend transactions in the first faked block.  This would spread out the cost over more than one attack.  So simply checking that the value of the transaction is less than X*50 isn't necessarily enough, although the logistics of the attack aren't exactly easy.
There's also the question of knowing what the difficulty for those X blocks ought to be.  If the attacker controls your network connection (e.g. your ISP attacks you) you wouldn't be able to get a second opinion on how high the difficulty ought to be, and might get fooled by X very-low-difficulty blocks that were each produced with a lot less than 50BTC worth of hashpower.
  - e

@_date: 2012-01-29 12:40:23
@_author: Elden Tyrell 
@_subject: [Bitcoin-development] [PROPOSAL] Merkle tree of unspent 
On 2012-01-23 20:00:59 -0600, Alberto Torres said:
Thanks for writing this up (it's high time somebody did).  I like your acronym, but shouldn't it be "MTUO" since you spend *outputs* rather than *transactions*?  A transaction can have multiple outputs, some of which are spent and others which aren't.
I've added a link to your proposal on the  wiki page.
Just like OP_EVAL/p2sh, this creates the (small) risk of a blockchain split.
Unlike adding a new transaction type, here it's possible to eliminate this risk: give each MTUT an additional "prev" pointer (hash of some prior block) which points to the latest prior block with a correct MTUT.  This produces a "chain within the chain" of blocks that have valid MTUTs.  Hostile miners are free to add bogus-MTUT-blocks; those bogus blocks will simply never be included in the "inner chain", just like invalid blocks mined by hostile miners are never included in the blockchain.  By downloading the last day's worth of blocks (which is not much data at all), a client can see which "inner chain" the majority of the hashpower believed during the last 24 hours.  This eliminates the need for a vote in any specific block -- in effect you get a "rolling election".
This "inner chain" approach can be broadened to a K-ary tree by including K-many prior-block pointers.  With one of these in every block (and sensible choices) you wind up with O(log_K(chain_length))-operation hash-secure access to arbitrary blocks in the middle of the chain.  This is an important building block for ultra-high-security thin clients.  Even if only a 1/K of the network's hashpower starts adding these pointers the worst-case number of operations needed to reach an arbitrary block will still converge (though much more slowly) towards this ideal.
  - e
