@_author: _chjj
@_date: 2016-08-12 01:46:57
Agreed. That would be nice to see one day.
It's not necessarily _always_ required. It depends on the environment. BCoin is usable without a websocket proxy when used in a chrome app. The chrome extension API allows raw access to tcp sockets. Ideally, that's what I'd like to see with the browserified bcoin. The example posted above was just a proof of concept.
@_date: 2016-08-12 00:25:37
JJ from purse here. Just a note: this isn't meant to be used exclusively in the browser. Node.js is its target platform. I ended up browserifying it because it was almost too easy to do, and the thought of saying "just visit this webpage and you have a full node" was too cool to pass up.
The browser version is more of a proof of concept than anything. If you want to try it on node.js, install from  and try running `$ bcoin --fast`. It's _mostly_ compatible with the bitcoind json rpc api, so you can easily use `bitcoin-cli` to utilize the wallet, etc.
@_date: 2016-08-03 22:40:02
It doesn't look like the attacker's address. That 1k btc chunk was being passed around long before the attack and it was never received from any p2sh addresses. 
I posted an address. It looks like it's all in good fun to me, even if it is a troll.
@_date: 2016-08-12 01:28:44
Yeah, that's necessary because tcp sockets aren't accessible in the browser. The websocket proxy doesn't do anything except [pipe data back and forth][1] though. It doesn't do any bitcoin stuff. The browser is still seeing these sockets as peers and is still validating the blockchain.
Right now the websocket proxy is a vector for a mitm and loss of privacy. This won't be a problem once bip151 is widely supported on top of Jonas Schnelli's peer identity auth BIP.
[1]: 
@_date: 2016-08-03 17:43:36
@_date: 2016-08-12 14:41:37
Bitcore is not a full node (the full node backend it uses for the bitcore wallet service is a fork of bitcoin core). 
BCoin is also a very different project. It strives to be consensus aware at every turn. It's one of the very few bitcoin libraries that has fully validated the main, testnet3, segnet3 and segnet4 blockchains successfully. This means that not only does it conform to consensus, but it's also extremely performant (it has to be -- validating a blockchain is the toughest benchmark you could put anything through).
@_date: 2016-08-12 00:29:32
No. BCoin stores the blockchain in a different format. Part of this was for simplicity (no parsing of chain headers and chainwork recalculation on boot, no flat files for blocks, etc).
@_date: 2014-09-26 04:00:59
The real meat of the browser code lies here: 
It's tricky, KJUR+cryptojs supports [ECDSA and DSA][1] (+SHA1/256) signatures. node.js supports [DSA and RSA (+SHA1/256), but not ECDSA][2]. The only overlapping algorithms are RSA and DSA signatures.
It would be a lifesaver for bitcoin in the node.js world if node.js finally began to wrap ECDSA openssl functions, for many reasons.
It's likely the most common signature algorithm for payment protocol PaymentRequests is currently RSA+SHA1/256. BIP-70 only specifies a "pki_type" as "x509+sha1/256". There isn't much of a way to specify whether the PaymentRequest signature is RSA/DSA/ECDSA unless implementations decide to stray from the specification a little bit. We'll have to see what happens in the future. Maybe ECDSA will become the standard for PaymentRequest signatures, in which case, we could simply use KJUR within the node.js code of Bitcore to verify them.
edit: spelling
[1]: 
[2]: 
@_date: 2014-09-26 03:39:19
Hi, chjj from Bitpay here. I promise you this has never been done in the browser before. After scouring google for a quick solution, I came to the conclusion that I would have to write it myself. (I would still love to be proven wrong here: X.509 is an odd beast, and hard to work with).
Like andyd00d mentioned, Coinbase, and other platforms/wallets, most likely use the backend (or something not imprisoned by browser limitations) for that kind of thing. There's no shame in linking to openssl or gnutls. X.509+ASN.1+DER is old, confusing, and _hard_, which is why everyone tries to forget about it and use a library to meet their needs instead. I don't blame them. We just wanted to do something new and different.
The nice thing is, not only can this just be used for Bitcoin, it could be used for any application that needs to do X.509 certificate chain validation. The thing your browser does when you open any site over `https`: Bitcore can do that very same thing now.
@_date: 2014-09-26 04:07:21
Sorry about that. I tried to write it in a lay man's wording, but I guess I failed to some degree. My mind is sort of warped from studying the relevant IETF specs and BIPs for too long. I'll seek more advice about how to explain things in a simpler way and hopefully do better next time.
@_date: 2017-03-13 08:53:44
The segwit version bit is opt-in. This is the case with bitcoin core as well.
@_date: 2016-06-17 22:45:49
You're not mentioning _how_ it was fixed. The transaction was not artificially "erased". That fix involved Satoshi fixing an int64 overflow bug which he would have fixed anyway. He didn't ban an address or prevent coins from being sent to a particular address (like the fork vitalik is proposing).
@_date: 2016-06-06 05:54:43
Definitely. That might actually be ideal since the chrome api allows for raw tcp access. No need for a websocket proxy then.
@_date: 2016-06-06 11:55:01
Probably a good idea. I actually haven't tried Let's Encrypt yet. I've been meaning to. :)
@_date: 2016-06-06 11:03:42
In the browser everyone should be seeing that error, regardless of tor. Normally, bcoin running in node.js will try to find your public IP in order to advertise it to other peers. This is pointless in the browser since peers can't connect to you directly (there is no server socket to connect to). It will just give up and return that error instead. Nothing to worry about (it's more of a warning than an error).
@_date: 2016-06-06 21:38:23
My dog used to like bitcoin treats. Now he only likes ether treats. Needless to say, I abandoned him in a parking lot.
@_date: 2016-06-06 11:09:11
Pruning isn't turned on with the current page, but I may turn it on if it turns out the segnet chain is too much to handle for certain browsers. I'll maybe just include a setting for it. That way we can potentially sync the main chain in the browser.
@_date: 2016-06-06 11:48:50
The segnet chain is pretty small (just over 400mb). I will turn pruning on by default to cut that down by a lot if people have issues. Right now this is sort of a proof-of-concept just to show that it can be done. If anyone wants to use this on main, you would definitely want pruning enabled.
@_date: 2016-06-06 05:47:27
Yeah, it is for real. It's my rough proof-of-concept. I really like the idea of being able to say, "just visit this web page and you have a full node." I've been working on a bitcoin fullnode written in node.js for months (to my knowledge it's one of the very few alternative consensus-aware nodes). So, I browserified it and hacked this up over the weekend.
The only part that makes it "less" than a full node is the fact that it has to use a websocket-&gt;tcp bridge to connect to the p2p network. The proxy doesn't do anything special though. It's just a pipe: the browser is still parsing all the packets, etc.
This fullnode is what we'll be using as a wallet backend at purse.io. Though, obviously not in the browser.
@_date: 2016-06-18 00:09:24
That still wouldn't give half the benefits of segwit. Segwit doesn't only raise the blocksize. It fixes the quadratic complexity of sighashing and makes it an o(n) operation (which is very important and makes the threat of a "poisonous block/tx" less likely). It prevents mutability. It makes scripthashes sha256 instead of hash160. It adds witness programs which are easily upgradable in the future. It adds a lot of nice things that MAX_BLOCK_SIZE=2000000 would not accomplish.
@_date: 2016-06-18 00:42:08
You sort of ignored the big one. Linear complexity sighashing is _absolutely_ urgent, especially if the block size is increasing. This has been a problem for a long while. Raising the block size without optimizing sighashing is asking for trouble.
@_date: 2016-06-06 11:33:52
1. No. Bcoin stores and indexes the blockchain differently. It especially has to do this differently in the browser since the browser doesn't have direct filesystem access and also cannot handle binary keys.
2. BCoin cannot accept connections in the browser right now (there's not really a good way to do it. it's possible, but it would require a lot of ugly workarounds). When running in node.js, yes, you will have to forward the p2p port to your machine in order to accept connections if you're behind a NAT.
3. In the browser, no: it's stored in indexeddb, which will probably reside in ~/.config/chrome/Default/Indexed\ DB or something similar in chrome. The best you could do is to tell chrome you want your ~/.config/chrome directory to be placed elsewhere, or to do something hacky like `ln -s ~/chain ~/.config/chrome/Default/Indexed\ DB/name_of_bcoin_idb`. I'm not sure where firefox and everything else stores their data right now. In node.js, bcoin accepts a `location` option for the Chain object.
In other words, the browser has a lot of limitations. Some we can work around, others we unfortunately just need to deal with.
@_date: 2016-06-06 05:57:40
Just a note: it can also sync main/testnet/etc. I picked segnet4 since it's relatively fast to sync and start using. Main (67gb) also won't work in the browser without pruning due to indexeddb limits.
@_date: 2016-06-06 11:44:10
No, it's not supposed to be stuck there. Does it work without tor? If it does, I would guess it's some issue with websockets over tor. But you should still be getting more logs after that anyway.
What browser are you using? Could you check the console and see if there are any uncaught errors?
@_date: 2016-06-06 12:09:49
Haha, well it might take a little while longer since it still needs to do a bunch of writes as well as some basic verification (merkle root/duplicate txids, target, deployments, etc). 
IndexedDB in chrome is surprisingly slow compared to leveldb (which is strange because chrome's IDB is implemented on top of leveldb). And while no sighashing would be necessary, hashing for txids still would be. All the hashing is done with [javascript functions]( in the browser. It's well implemented and fast for javascript, but it will never be nearly as fast as a native sha256 implementation.
Basically, the browser sucks when it comes to perf. I've tried to optimize bcoin as best I can. It's nice and fast in node.js, but probably at least 3-4x slower in the browser.
@_date: 2017-01-13 20:59:49
@_date: 2017-01-13 20:30:50
Unfortunately [BIP142][1] was put on hold. But that didn't stop me from [implementing it][2]. s segwit branch of btcd (used for [lnd][3]) also supports segwit addresses. I'm not sure which other wallets have support/planned-support for them right now. It's fairly trivial to support them for sending (requires no other segwit changes to any code).
I honestly think wallet devs should just begin implementing them. If the specification changes in the future, both the new and old could be supported for sending. It's a simple non-consensus change. I don't see an issue with implementing them now, because I agree with you: nested p2sh is a pain.
[1]: 
[2]: 
[3]: 
@_date: 2016-06-06 08:15:42
In chrome, it should be ~430mb for segnet, give or take.
Firefox may have issues with this. Firefox is supposed to have no size limits (users decide the limit), but by certain accounts firefox will choke after 300mb regardless.
Chrome has a dynamic limit based on the size of your disk, so it _should_ be okay in most cases I think.
IE has a 50mb limit or something ridiculously small, but who cares about IE?
If people report indexeddb issues, I may turn pruning on by default.
@_date: 2017-01-13 20:06:40
The first tx you listed is using nested p2sh+p2wpkh. That's a backward compatibility feature until wallets are upgraded to support segwit addrs. The first transaction's base size will still be smaller, although the real size is larger.
Actual segwit transactions that redeem directly from witness outputs will be almost exactly the same in real size as traditional bitcoin transactions. Maybe a byte or two smaller. And the old network will see them as being much smaller still.
If you don't like nested p2sh, you should encourage wallet developers to start implementing segwit addrs.
edit: s/p2wsh/p2wpkh/
@_date: 2016-11-01 00:40:59
After segwit is activated, any account created on purse will use p2sh witness programs as addresses. Ideally, I would want to use naked segwit addresses if we can get them implemented in all popular wallets in a reasonable amount of time.
Note that witness program, even behind a scripthash, still make the blocks appear smaller on the old network (a witness program redeem script is 22 bytes (+1 for the redeem script pushdata in the input script -- a regular scriptsig for p2pkh would have been ~106 bytes).
@_date: 2016-06-06 12:16:38
Awesome. I'm ashamed to say I haven't tested my own node on my pi yet. Good to know it works.
I say go for it if you want to test main. I have a feeling it may eventually OOM on a raspberry pi though. LevelDB uses a lot of memory once a significant amount of keys are in the db. Something I'm working on improving (bcoin creates too many keys for coins right now -- the same flawed way bitcoinj stores them).
@_date: 2016-11-09 19:28:14
A VPN solves a completely different problem. Even if you're on a VPN, the peer you're talking to might not be. The communication on their end could still be in plaintext for anyone listening on the wire.
With bip151 and bip150 together, you can connect to a peer with an associated identity key (no MITM'ing) and encrypt the connection. You will have a list of known_peers and authorized_peers, similar to SSH.
The protocol isn't there to find you a peer you can trust -- it assumes you're connecting to a peer you know about. The purpose is to make sure your communication stays secret (bip151) and to make it impossible for anyone to eavesdrop on you and your friend (bip150). 
Without bip150, you can still encrypt all communication, but you're subject to a MITM -- this is true. At the end of the day, I would rather get spied on while being encrypted than get spied on while unencrypted.
SSH-level security for bitcoin is pretty cool if you ask me.
@_date: 2016-11-25 02:54:32
Let Bob decide: 
@_date: 2016-11-27 09:47:03
This will confuse a lot of wallets, depending on how they index, recognize, and store addresses. It's likely funds sent this way will never be seen as received by the target wallet.
You're creating a new hash here. The wallet you're sending to probably didn't index the scripthash as one of its addresses. It won't even recognize the output you created.
@_date: 2016-11-09 19:29:55
This could be part of it. Unfortunately the handshake for bip151 is very obviously a bitcoin crypto handshake to anyone watching (the `encinit` msg is sent in plaintext with a standard bitcoin packet header). Ideally it should be nearly indistinguishable from random bytes, but we need it to be a standard bitcoin message for backward compatibility.
Note that the lightning network will have a much better crypto handshake (it has the benefit of being built from the ground up).
@_date: 2016-11-27 10:07:09
It still may not recognize it even if that was the case. Using the same key for p2pkh and wp2pkh addrs adds a lot of internal complexities into wallet implementation. My own wallet originally used the same key for p2pkh and wp2pkh, but it was scrapped for a new design: segwit addrs get their own hd derivation branch. I imagine this will be a common model eventually since it's really the only sane way to do things. (It's been discussed on bitcoin-dev a few times, but a BIP hasn't materialized yet).
This means that the segwit addr that the wallet supports may not use the same keys as the ones they use for standard p2pkh, resulting in no shared hashes between p2pkh and wp2pkh.
There's no "unless" here. Don't do this. You'll lose money, or cause someone a huge headache by forcing them to hack some weird addresses into their wallet and rescan.
@_date: 2016-11-09 20:13:02
SSH is a key example here. We have bip151 for the same reason we have encryption over SSH. Would you rather SSH into a server, or _telnet_ into it over a VPN? Your decision.
@_date: 2017-04-07 04:04:28
I am the only co-author of the spec that works at purse. Fedor spoke with Greg and this was Greg's suggestion.
I personally would have added this much sooner if it was ever mentioned to me. I asked for suggestions regarding the merkle commitment construction on the bitcoin-dev ML and none were given. Instead of being mentioned in peer review, the asicboost findings were announced separately later.
@_date: 2017-04-04 02:52:29


I'm not happy about it either. I don't think Wang Chun would have done that if it wasn't April Fools day. I think he's just having fun.
@_date: 2017-04-04 07:10:18
I made it a point to mention this in the specification:


Segwit as included in the extension blocks spec is not compatible with BIP141. It's not meant to activate in the main chain block, only the extension block. In the regular block, witness programs are still just pushdatas which are immediately redeemed by the resolution transaction.
Since both ext. blocks and BIP141 require 95% activation, it's unlikely the miners would activate both. Furthermore, it's impossible that they could enforce both. It's even more unlikely they will activate segwit on its own, which is part of the reason this specification exists: get segwit, get bigger blocks in a safe way, and end this scaling debate.
@_date: 2017-04-07 04:18:07


He clearly did read our proposal. I'm guessing he even read my ML email if he was able to conclude ext. blocks were vulnerable to this. He even specifically mentions the ext. block commitment magic number in his announcement: 






His proposal actually blocks extension blocks with that one line. He could have reached out and suggested a better merkle construction instead.
@_date: 2017-04-07 04:12:08
Not sure what you're getting at here, but unless Greg was the only person aware of this beforehand, I feel it could have been mentioned by others during the review process.
@_date: 2017-04-06 21:31:56
I wanted to reinforce the point that segwit is probably not going to be activated on its own (which is why we made this in the first place), but after looking again at jl's proposed way of doing ext. blocks and hearing both luke-jr and johnson suggest it, I was on board to support segwit in the mainchain.
I mentioned it twice in both of these posts (both of which were posted before gmax's big reveal):
From 




















From 
















My next idea was to simply _bundle_ mainchain segwit as part of ext. blocks.
@_date: 2017-04-04 09:00:30


No. Nested P2SH exists as `P2SH(witness-program)`. There's a chance somebody in the historical blockchain sent their funds to a script that is identical to a witness program, wrapped within a scripthash. Once segwit activates, they will not be able to redeem their money, unless their random pushdata happens to be a hash of their key/script (unlikely).
Technically, this was a potential issue when p2sh was getting activated as well. The difference is, with p2sh, you could actually parse the blockchain and see if any of these p2sh-like outputs existed beforehand. With segwit's nested p2sh, you can't do this, since the script sits behind a hash. It may have never been revealed.
@_date: 2017-04-04 08:06:17
It's possible, but it would require some changes.
One way would be changes to the pushdata format. Instead of witness programs, maybe we would be using some other kind of pushdata for the extension block. That would in turn result in a new address type. So now we would have 3 address formats: traditional, segwit, and extension block.
One of Johnson's clever ideas was to make the higher witness version numbers be extension-block-only. That would be one way to do it and avoid having 3 address types.
In the end, having all witness programs be the entrance signal to the extension block was just a bit cleaner for implementations sake. The 1mb chain is left untouched, and all new behavior exists only inside the ext. block.
@_date: 2016-02-27 23:04:18


Yeah, Fedor is a brilliant guy. He's the reason I got into bitcoin development (bcoin was the first bitcoin library I could read and actually understand). He comes up with a lot of cool stuff. Just last night he messaged me with a way to [create valid ecdsa signatures of different hashes from existing signatures][1]. He wasn't sure whether it had been discovered before. Neither was I. I generated a bunch of signatures and hashes that verify against satoshis public key for fun:
- 
- 
This technically makes finding sighash collisions a bit easier, but still very hard. Luckily for bitcoin, this isn't a malleability issue since you need to create a new hash for the signature.
[1]: 
@_date: 2017-04-04 03:47:45
Production bcoin nodes do not implement the extension blocks specification. The code currently resides on a development branch. The proposal still needs more feedback, testing, and review. It is not production ready and doesn't claim to be.
@_date: 2017-04-04 08:19:35


Yes. Non-upgraded wallets will see an output on the resolution transaction (it will look like the resolution transaction sent money to them). This works because all "traditional" outputs (exiting outputs) inside the extension block get duplicated onto the resolution transaction in the regular block.


A non-upgraded wallet will require an upgrade for *at least* address types. The good news is is that these are not hard to hack in with a few minimal lines of code. The developer of the wallet may not have time to implement all of ext-blocks/segwit, but they may have time to quickly add a new address type for sending.
Segwit currently has a backward compatibility rule for this by nesting witness programs inside p2sh. The problem with this is that it would be hard to make compatible with extension blocks, and on top of that, segwit's nested p2sh may inadvertently burn existing coins once activated. For these reasons, the nested p2sh backward compatibility feature is not included in extension blocks.
@_date: 2016-02-27 23:03:05
Maintainer of bcoin here. Glad to see people are interested in bcoin. Just a warning that the master branch is unstable and not ready for production yet (the docs also need to be updated). We're planning on using bcoin for our new wallet/contract server at purse.io, so it will ultimately be battle tested at some point.
@_date: 2017-04-06 22:01:40
Also, I mentioned plans to make ext. blocks compatible with mainchain segwit twice:
- 
- 
Both of these were posted before Greg's announcement.
I was open to suggestions for how to create the commitment, since I don't fancy myself a merkle expert. If Core Devs were aware of this, why didn't they mention it in the review of ext. blocks? e.g.
"Hey, by the way, you should build the merkle commitment this way. It prevents against patented miner optimizations."
I would have glady added that if it was pointed out to me in review. Instead, it was used as a political tool to smear anything that wasn't segwit.
@_date: 2017-04-06 21:41:13


Well, apparently any scaling proposal that is not segwit is tailored to this. It's pretty easy to accidentally come up with something that is "custom tailored" to do this.
Greg was criticizing us for not being aware of privileged knowledge only he had access to.
@_date: 2017-04-04 08:22:48
Yes. This is true, but this is also the case for any softfork in relation to non-upgraded nodes, which is why bip9 softforks require 95% activation. Even with a 51% activation threshold, they would eventually get reorg'd out of their mistakenly invalid chain.
@_date: 2017-04-05 11:23:19


I contributed to it, but segwit is not going to be activated. That should be clear to anyone paying attention for the past year. Once you accept that reality, this specification may seem more appealing to you. We designed this specification so it would have the easiest upgrade path possible from segwit to extension blocks.


Nodes intentionally avoiding validation due to bandwidth/cpu concerns can be just as much of an issue with segwit assuming the max extension block size is initially 1-3mb.
On a similar side of the coin, non-upgraded nodes not enforcing the new soft-forked rules is a risk inherent to _all_ soft-forks that we as a community have learned to live with.


What you're saying is you want this proposal to be __both__ segwit in the main chain and extension blocks? That would lead to even greater bandwidth concerns: &lt;=4mb blocks in the main chain + a 1-2mb extension block.
@_date: 2017-04-05 09:57:35
Adam, I am one of those developers who put work into segwit. Bcoin was the second or third implementation of segregated witness available. I very thoroughly tested segwit in the early days. I've synced the segnet3, segnet4, and testnet chain more times than I can count. I spent nights lost in thought trying to find unnoticed edge cases in segwit.
Maybe others feel differently, but I wouldn't find this idea annoying if it were proposed by someone else.
Joseph and I had an idea, and we worked on it with help. Once we had some working code and felt it was mature enough to publish it as a draft, we posted it. As far as success goes, it may not include segwit as it exists, but it would be nice to see bitcoin move forward in some way. This is just a proposal right now. We'll see what happens. I see no reason to be annoyed by it.
@_date: 2017-04-07 04:39:37
We can, I've mentioned it on the mailing list. I originally wanted to be able to rip out the segwit code for the mainchain and only keep segwit in the ext. block. It seems cleaner code-wise and just conceptually. It was also a sneaky way of trying to unite people somewhat, i.e. if you want segwit you have to use bigger blocks, if you want bigger blocks, you have to use segwit.
I will open an issue for it. It's a simple revision to the spec, just a lot of rewriting of the code.
@_date: 2017-04-06 22:23:53
Ext. blocks also include a commitment in the coinbase. I asked for help on how to construct the merkle commitment during initial review of ext. blocks. I was open to suggestions, since I'm not a merkle expert. No one replied with suggestions on that. Instead, they kept the asicboost findings under wraps in order to use it as a political smear tool later.
I also mentioned _twice_ that I would rewrite the code to be compatible with mainchain segwit, both times were before Greg announced his asicboost findings:
- 
- 
@_date: 2017-04-04 08:29:04
Fair enough. I should have wrote "left untouched as much as possible."
@_date: 2017-04-04 07:47:54
Voluntary. There's always a risk a non-upgraded miner could mine an invalid block if they aren't aware of the new resolution transaction rules with regards to witness programs, but should be very unlikely as long as they have the default standardness rules in their mempool.
That being said, since extension blocks has such a high activation threshold, there wouldn't be many non-upgraded miners left if this were to activate.
I'd like to add that this is also the case with segwit and most every softfork. A non-upgraded miner _could_ in theory mine an invalid block if they're not aware of the new rules, but it's very unlikely if they have standardness turned on in their mempool.
An "upgraded" miner who simply doesn't wish to mine extension blocks is more than welcome to though.
@_date: 2016-09-27 21:09:25
BCoin is not limited by a single thread in this case. Transaction verification is parallelized via worker processes (try the `--use-workers` arg). If you have 4 cores, you can verify 4 transactions concurrently without blocking the main thread.
In the browser, bcoin will use web workers.
@_date: 2017-04-04 08:25:33
No. The spec states that miners who have entering outputs in their block without an extension block must have a commitment of all zeroes.
Non-upgraded miners using proper mempool standardness would not include witness program outputs, and thus not have to include a commitment.
@_date: 2016-09-27 21:22:40
Thank you for politely phrasing this question (seriously, I'm too used to dismissive comments like the other one in this thread).
bcoin was not started by me. It was created in 2014 by Fedor Indutny, a lead node.js dev. It was originally a small spv wallet in the browser. I got involved in the development right away. Last year I started rewriting it as a full node since it was already there. 
Javascript may not have been a conscious decision in the design of bcoin, but the killer feature of JS is that it's ubiqituous. Javascript may be the most omnipresent language in the world. It will run on the server, the browser, your laptop, you phone, etc. Everyone is familiar with it.
On top of that, JS is faster than you may think. It can't beat golang for example (it can come close in some select benchmarks), but it will beat the hell out of python or ruby. The v8 JIT might be one of the most clever JITs ever created.
I have to admit though, even I was originally afraid that a javascript full node wouldn't be able to keep up, given the amount of processing a full node needs to do, but it does. v8 is a tough little bastard.
@_date: 2016-09-27 21:04:31
Libconsensus encompasses only a small percentage of what bitcoin consensus is. The only thing I can think of that's using it is bitcoin-ruby. 
It's a step in the right direction, but in practice it's not very useful right now... at least not until all of bitcoin core's consensus critical functions can be linked to and used as a library (not likely).
@_date: 2016-09-27 21:06:27
Bitcore is not a full node. Bits of Proof is not a full node to my knowledge. BitcoinJ is unusable due to extremely naive management of the utxo set.
In my eyes, the only full nodes besides bcoin are: bitcoin core, btcd, and NBitcoin.
@_date: 2016-09-27 23:59:28


bcoin has validated the main, testnet3, segnet3, and segnet4 blockchains successfully. It also passes all bitcoind script &amp; tx unit tests: 
It strives to be consensus conforming. Unfortunately there's no way to tell for certain that an alternative implementation is byte-for-byte accurate, but as far as I can tell, it's there.
@_date: 2016-09-28 02:18:09
I'm aware of that. Which is why I said there's no way to tell for certain that an alternative implementation is consensus conforming, but we can take these pieces of evidence to suggest it's at least conforming to a high degree.
@_date: 2016-09-14 11:00:09
Well, it's an exact reimplementation of the p2p protocol, so, yes, it has the same upload requirements, but I just wanted to say, as someone who has been implementing this stuff for a year, I really see that as secondary to the amount of CPU large blocks would require.
Also, things like compact blocks will reduce the amount of bandwidth required for block relay, since most full nodes have at least 75% of the transactions in their mempool already. It's sort of a solved problem now.
@_date: 2016-09-27 22:03:42
Yeah, this is one of the major pains with JS right now. There is no 64 bit number type, however, JS does have helper functions for overflowing 32 bit mulitiplication for example (`Math.imul()`). 
I have to implement some trickery to treat doubles as if they were ints. The [siphash][siphash], [murmur3][murmur3], and [rolling bloom filter][bloom] implementations are probably good examples of this.
It's a pain, but it's possible if you know how doubles work and know how ints are supposed to work. For speed, bcoin will actually call out to C++ for murmur and siphash if the binding is available. If not, it will use the pure JS implementation.
The other problem is potential precision loss. Double floats lose precision at 53 bits. Luckily, bitcoin MAX_MONEY is only 51 bits, so we can check for overflows the same way bitcoin core does: check that two output values are less than MAX_MONEY. Add them together, check that the result is less than MAX_MONEY. This works because the highest number you can get as the result of a 51 bit addition is a 52 bit number -- maybe too close for comfort, but it works.
If an output value is higher than 53 bits, bcoin will simply fail parsing and reject the tx, which is okay since there's no way that transaction could be valid in the first place.
[siphash]: 
[murmur3]: 
[bloom]: 
@_date: 2016-09-14 03:48:10
The real bottleneck for bigger blocks is CPU, not bandwidth.
This is considered more of an issue for the network and protocol as a whole. It's an attack vector for DOSing the network if an evil miner were to mine several "worst case" blocks.
Sighashing is an O(n^2) operation. A transaction has to be reserialized and hashed for every input it contains. On top of that, for every input there is 1 to 15 potential EC point operations. So, say you have a 32mb transaction with many thousands of inputs. The verifier has to hash ~20mb of data many thousands of times and do many thousands of EC operations. It's not the "size" that matters so much as the amount of processing it does. Increasing the size means more hashing, more EC verification.
The O(n^2) sighashing will be fixed with segwit, which is why it's safe to have increased block size with segwit. Unfortunately, the EC operations are still a bottleneck, but in the future this can be fixed with things like batched verifications.
@_date: 2016-09-14 10:50:07
Yes. It's been running in production for several weeks now relaying transactions with a fully validating mempool and blockchain: 
One of the few alternative bitcoin full node implementations. You should check it out if you're interested.
@_date: 2016-09-28 16:16:35
In node.js, bcoin will call out to libsecp256k1 for ecdsa. In the browser it will use `elliptic` - the fastest javascript ecdsa module. 
The utxo set and blockchain are stored in leveldb in node.js, and in IndexedDB in the browser. IndexedDB has different limits depending on the browser, but you can sync the main chain if it's pruned. The chaindb, coins serialization, and coin viewpoints are here if you're interested in the lowlevel details: 
SHA256 is openssl (which node.js already links to and compiles with asm support), and hash.js in the browser. However, I've wanted to write a webgl shader in the browser for sha256 (that way we get GPU acceleration -- the hashing may be faster in the browser than it is on the server).
Signing and verification itself will run on worker processes in node.js, and web worker threads in the browser.
@_date: 2016-09-14 10:44:35
I disagree, but it depends on the point of view. As an implementer of a full node, I will always see the CPU usage as the main bottleneck. It's what I've been trying to optimize for a year. Bandwidth is still important but secondary.
@_date: 2016-09-27 21:10:21
Heard that one before. Try again.
@_date: 2017-04-04 09:03:45
You must wait 1 block, since you don't yet know what the txid of the resolution transaction is when it enters the mempool. You have to wait to see the output on the blockchain. It's a drawback for sure, but if you picture a future where most people are using the extension block in their everyday transactions, funds may not be exiting all that frequently.
@_date: 2016-05-02 10:50:18
Perhaps Gavin was duped? I'm not sure. We still haven't seen any cryptographic proof that Wright is Satoshi. It's extremely peculiar he didn't post the message he signed. All he had to do was post: "I, Craig Wright, am satoshi. Use the key in block 9 to verify this message. [signature here]"
Instead we got a wall of text containing a phony signature, explaining how to verify a message that he didn't even post.
@_date: 2017-05-19 11:56:43


I figure you're referring to the extension blocks spec, since I've publicly supported segwit for over a year and still do (just not via UASF). Segwit compatibility for the extension blocks spec and code have been here for over a week now: 
I opened it up for discussion on the repo and the dev mailing list. Not many people gave their thoughts on it. More feedback is appreciated.


I think it turned out to be a pretty good way to warn people about the UASF.
Anyway, code which auto-redeems pushdatas in the mempool isn't really a new thing (this happens already, try it if you don't believe me). Auto-malleation of high S-value signatures is also already present on some nodes watching the mempool (anyone who has implemented a wallet can tell you this). Personally, I see things like this as a public service to warn people about security issues. 
The UASF introduces the worst replay attack in cryptocurrency history. It shouldn't be ignored. The threat should be made visible. This code makes it clear that the adversary is out there, and that sending money to an unenforced soft-fork pushdata isn't safe.
@_date: 2016-05-16 01:36:01
Calm down.
@_date: 2016-07-24 22:25:49
Any _consensus-level_ bug can potentially ruin bitcoin. Not a bug in a script in a single transaction. Ethereum forked to fix a bug which was in a contract, and not inherent to the currency itself.
Sure, I'm picking and choosing. I'm choosing to fix the bitcoin bugs, not the non-bitcoin bugs, which seems like it should be a given.
@_date: 2017-05-19 12:32:14


Pointing out major security holes in a deployment causes me to lose credibility?
@_date: 2016-05-02 09:18:35
This has already been debunked on the bitcointalk forums: 
The signature Wright posted is a signature from a transaction on the blockchain (and therefore cannot be a signature of a Nobel prize refusal speech or whatever other message he claims): 
The above tx's scriptSig: 3045022100c12a7d54972f26d14cb311339b5122f8c187417dde1e8efb6841f55c34220ae0022066632c5cd4161efa3a2837764eee9eb84975dd54c2de2865e9752585c53e7cce01
The signature Wright posted:
    $ echo 'MEUCIQDBKn1Uly8m0UyzETObUSL4wYdBfd4ejvtoQfVcNCIK4AIgZmMsXNQWHvo6KDd2Tu6euEl13VTC3ihl6XUlhcU+fM4=' | base64 -d | xxd -p
    3045022100c12a7d54972f26d14cb311339b5122f8c187417dde1e8efb68
    41f55c34220ae0022066632c5cd4161efa3a2837764eee9eb84975dd54c2
    de2865e9752585c53e7cce
No wonder he didn't actually post the file he signed.
@_date: 2016-07-09 15:13:35
The algorithm is: `base-reward &gt;&gt; (height / halving-interval)`
- base-reward = 50 btc (in satoshis)
- halving-interval = 210000
If height is 420000, halvings are 2, so it becomes `50 btc &gt;&gt; 2`.
Note that the right shift is the same as `base-reward / 2^(height / halving-interval)`.
@_date: 2016-07-24 21:32:55
Something is either a consensus-level bug or it's not. That's just a fact.
Also, motives behind hard forks matter. If bitcoin hard forked tomorrow because of a consensus-level bug that could potentially ruin the currency, I would understand the need to do that. If bitcoin hard forked because somebody accidentally sent coins to an unspendable output, I would oppose it (hopefully everyone would).
@_date: 2016-07-24 20:05:35


People really need to stop comparing the DAO attack to this incident.
Satoshi didn't go in and implement a check to artificially prevent the attacker from spending those funds. He fixed a bug in the protocol itself (which he would have fixed anyway).
There was no bug in ethereum itself, just the DAO, but they hardforked anyway. It was all done for the sake of self-interest. If the DAO incident was caused by consensus-level bug, I'm sure everyone here could forgive a hard fork, but that was _not_ the case.
They're not the same thing. Stop repeating this misconception.
@_date: 2016-07-08 02:08:56
To get even more technical, you also have to subtract the genesis block coinbase since its output is not added to the database as a spendable coin, making a grand total of `20999949.97690000`.
@_date: 2017-07-03 02:10:41
The difference is, my attack disclosure pertained to bip148, and it actually worked. Peter Rizun is talking nonsense and is essentially arguing against softforks in general. Mike Hearn had these same arguments posted all over his blog. I think everyone grasps the arguments against softforks, but they're not applicable to the reality of the situation.
For the record, segwit outputs are perfectly secure because they're protected by hashpower (that is, unless you do something stupid like bip148).
@_date: 2016-07-25 00:05:23
Author of bcoin here. Full nodes process a lot of data. Just posting to say that this only works in javascript because google hired some of the best compiler engineers in the world and went to insane lengths to [optimize][1] the v8 javascript engine (this in turn sparked a performance arms race among other javascript engine implementors).
Unfortunately I suspect a lot, if not most platforms will have trouble performing when validating a modern 1mb block. Not to mention every TX that hits the mempool. Javascript just barely pulls it off. It took a lot of work and tricky optimizations to get bcoin on par with the performance of bitcoin core. A full bitcoin node is really the most intensive benchmark you could put any language through.
All that being said, a PHP full node could definitely be done, but I wouldn't expect it to be fast unless it calls out for things like parsing/serialization, script execution, etc. I would love to be proven wrong though.
[1]: 