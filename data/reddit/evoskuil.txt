@_author: evoskuil
@_date: 2016-03-01 02:46:34
jtimon and others did some good work in isolating script validation rules from the Satoshi client. But for the sake of clarity, libbitcoin (and other libraries) have had full native consensus implementations for years. I wouldn't call it help in development, it is more accurately help in removing barriers to adoption. For this we are appreciative.
Libbitcoin packages up these sources files into an independent library as a matter of convenience for developers, since the Core consensus library is not fully isolated. Our libbitcoin-consensus library can optionally be linked to libbitcoin libraries, substituting for our native implementation.
@_date: 2016-03-01 02:56:34


Actually this is one of the aspects of the debate that is not in dispute. Larger blocks increase the advantage of greater hash power over lesser hash power.


This is possible, yet it misses the point. The question is not whether there may be existing centralizing aspects of the consensus rules, but under what conditions are consensus rules subject to change.
@_date: 2016-03-02 02:47:37


I thought your problem with LN was that it was not yet deployed.


Absolutely true and I agree.
@_date: 2016-03-01 19:20:53
It's too bad that you didn't have a good experience with ZeroMQ. I consider it the [gold standard]( in unbrokered messaging abstractions.


When it comes to performance it is [truly exceptional]( even described as [staggering](
Libbitcoin has incorporated it for implementation of the blockchain query interface since inception. We set up automated CI builds for all of our repositories about 1.5 years ago. Our installer and Travis-CI builds operate directly against ZeroMQ master, so not only do we end up testing against each version, but nearly every change as it happens. We do this specifically so that we will be able to detect any possible interface drift well before it could ship in a ZeroMQ release package. We have never encountered an interface break and in fact the number of interim breaks resulting from this approach can be counted on one hand.
I've found ZeroMQ to have a robust maintainer and user community. The few trivial problems that we've encountered (in master) have been resolved almost immediately, never more than 24 hours.
CurveZMQ is based on Daniel Bernstein's CurveCP and NaCl. On the other hand the poor security, sluggish performance and high complexity of TLS/SSL are legendary.
@_date: 2016-03-01 06:02:18
The most obvious difference is that the Satoshi client, in its various forks, is not a development library - it's an application.
Regarding consensus rules, there are no differences. The [libbitcoin]( libraries provide a native implementation and [libbitcoin-consensus]( packages the Core script validation rule sources as an optional independent library.
Libbitcoin consists of nine independent libraries, one experimental and one build system.
* libbitcoin
* libbitcoin-blockchain
* libbitcoin-build
* libbitcoin-client
* libbitcoin-consensus
* libbitcoin-database
* libbitcoin-explorer
* libbitcoin-network
* libbitcoin-node
* libbitcoin-protocol
* libbitcoin-server
The blockchain database uses a hash table design over file-mapped memory and offers tremendous query performance. The P2P networking, blockchain and server interfaces are asynchronous and multithreaded, based on the proactor pattern. The client-server protocol is built on the highly-scalable, performant, lightweight, and securable **ZeroMQ**. There is a comprehensive type library, set of hashing primitives and cryptographic wrappers for **libsecp256k1** (for Bitcoin) and **libsodium** (for CurveZMQ).
The libraries include automated builds for multiple configurations, including statically-linked single file, command-line-based, portable binaries for Linux, OSX and Windows. This includes server (bs), full node (bn) and explorer (bx) for mainnet and testnet. In other words deployment consists of placing one file on a machine. Server is a layer over the full node, adding the ZeroMQ query API, which includes stealth payment indexing and prefix-based retrieval.
The explorer command line tool can query server, build and post a tx to server, any node or a set of nodes discovered on the p2p network. It provides nearly 100 fully documented commands for working with all aspects of Bitcoin, hashes, ec math, stealth, keys, etc. Wallet commands support altcoins, for example:
The library makes extensive use of C++11 advances and supports clang, gcc and msvc compilers. The build system generates all of the build artifacts for all of the libraries, including single file comprehensive build scripts and automated continuous integration builds and test/coverage runs. Dependencies are minimal, consisting of (at most) those libraries mentioned above and **boost**.
I hope this helps. The [Bitcoin Wiki]( has a good deal more information, all of which should be current.
@_date: 2016-03-01 20:33:03
If you accept the centralizing effect of increasing block latency then this reasoning is a false dichotomy. We cannot ensure that people who require censorship-resistant payment can get it if we destroy censorship resistance. Essentially price becomes infinite for everyone (although lesser substitutes remain available, as before Bitcoin).
Censorship-resistant transactions are not, and cannot be, free. People must perform work to maintain decentralization, and this work must be compensated or it will not happen. This makes decentralization property, and that property must be sold at a price determined by those who own the property. This ensures that such transactions will always be available, the question is only at what cost (i.e. delay and fee level).
Those who "genuinely need" censorship resistance is a subjective matter. But I don't think that you could reasonably suggest, for example, that someone attempting to evade the currency controls of an oppressive regime is getting priced out of an occasional Bitcoin transfer any time soon. The demands for increasing block size and thereby centralization are not coming from these oppressed peoples, they are coming from banks and miners.
@_date: 2016-03-01 06:38:08
It is possible to build either a centralized or decentralized system on a decentralized system. It is not possible to build a decentralized system on a centralized system. To assume that any system built on a decentralized system must be centralized seems an obvious error.
@_date: 2016-07-20 09:03:24
Hash reversal in textual presentation is an idiosyncrasy of the original client and pervades the entire ecosystem. Libbitcoin provides decode_hash/encode_hash as a convenience. 
@_date: 2016-07-20 08:28:29
This isn't actually an issue of endianness. Due to an idiosyncrasy in the original client bitcoin hashes are conventionally represented in reverse when encoded as hexadecimal text. The above code decodes a hash (decode_hash) and then re-encodes it as binary (encode_hex). The inverse operations are: encode_hash/decode_hash and encode_hex/decode_hex (or encode_base16/decode_base16).
@_date: 2016-07-20 08:30:59
Regarding your question  the libbitcoin github issues, Freenode IRC and mailing list are the best places to get questions answered. More info here: 