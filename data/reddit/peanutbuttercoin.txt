@_author: peanutbuttercoin
@_date: 2015-12-07 06:58:31
Yeah, I think that's well known.
If anyone knows where the idea originated, I would appreciate them appropriately accrediting it to that individual. This is for sure the first implementation I know of.
Edit: gmaxwell ascribes it to Russel O'Connor.
@_date: 2015-12-06 20:07:16
It's not pedantic if I'm using the terminology incorrectly. Thank you for politely correcting me.
@_date: 2015-12-05 01:10:46
You'd be able to move Bitcoins into the Ethereum sidechain as a token. You'd use contracthashtool to send the Bitcoin to the federated peg multisig, then the federation would make the Bitcoins appear on the other side as tokens spawning from a contract sent to some Ethereum public key you owned. You then use the 'Bitcoins' for whatever you want, but the transactions involving them are powered by Ether (you still need to pay fees). You could have the user send some small extra BTC to the federation so they could give you some Ethereum to move the BTC around with on the other side, or send it to an address that already has a little Ether.
When you want to cash out the BTC, send it to the federation contract, then the federation owners make it appear again on the Bitcoin blockchain, paying out to you.
There'd be some serious lol if Bitcoin's first fully functional mainnet sidechain was Ethereum.
@_date: 2015-12-04 21:34:48
I'd like to see it work, but even historically mining a few hundred USD extra in NMC per block isn't enough of an incentive for a mining operation to run an extra daemon to do the merged mining. I'm going to guess that Rootstock isn't going to be the only merged mining chain in this space in the future, and that it'll end up being competitive.
And, worse, it increases mining centralization by forcing those who mine on the network to use more computational power and bandwidth.
@_date: 2015-12-07 04:25:18
This is a false dichotomy. The lead XT developer is a [core developer]( the second largest committer on Bitcoin. Boolberry (a CryptoNote coin) already had segregated witness [a year before the Elements sidechain was released]( the Elements sidechain just added a commitment to the signature data in the merkle tree.
@_date: 2015-12-04 21:15:20
Uh, where in the white paper exactly? It looks like they're using the same idea of DMMS as in Blockstream's sidechain paper, whose security is incidentally shown to be broken in Appendix A of the very same paper.
See: Page 14/24 of the RS paper. It looks like they are planning to at least start it as a Federated Peg.
@_date: 2015-12-07 04:28:04
Oh; well, I'm referring to Gavin, since he committed to XT too.
@_date: 2015-12-08 16:27:38
Yes, that's correct. They're propagated outside the block.
@_date: 2015-12-04 21:19:09
Merge mined chain incentivization is probably broken, as it is with NameCoin, etc. I wrote about it here:
It looks like they're just doing Federated Peg initially anyway, so maybe doesn't even matter and they'll just sign the blocks (despite all the discussion of crazy mining algorithms in the paper).
@_date: 2015-12-08 16:46:15
It has nothing to do with data capacity of the network, unfortunately. It just allows you to stick the bits needed to validate transactions off the block, which need to be transmitted with the block.
@_date: 2015-12-07 16:44:50
I wrote an "ELI14" or so here:
The only other thing added was fraud proofs, as far as I can tell.
@_date: 2015-12-04 22:37:39
I doubt it'll really effect Ethereum. Vitalik will probably step up within the next week and create a federated peg that transfers Bitcoins into the Ethereum blockchain, which isn't terribly difficult because the EVM scripting is extensive. And then Ethereum will be a Bitcoin sidechain, and I'm not sure what the point of this will be exactly.
@_date: 2015-12-07 20:57:37
Blank out the usernames too and I'll be really impressed.
@_date: 2015-12-04 21:29:22
Whoops, it's in appendix B, sorry.
Because of variance in the amount of work done on a block. A weaker attacker has a high probability of eventual success due to the random chance of finding a very high PoW block.
From the paper:


worth of work with probability roughly 10%, a much higher number [than 10^-196 expected with the Bitcoin blockchain].


@_date: 2015-12-06 20:06:07


gmaxwell just mentioned that he still yearns for a blocksize _reduction_, so I'm not sure what the overall consensus will end up being. Maybe "double it now and deal with it later at some point in the future when we feel like we have a good solution".


@_date: 2015-12-07 03:26:30
If you send a transaction with an invalid witness, the script VM will fail and that transaction will never make it into the mempool on a node enforcing the new policy, let alone a block. It does require the network to softfork, though.
You could mine a block like this with legacy the legacy code and put this transaction into it, but it wouldn't send the extra block signature data or include the hash in the coinbase sigScript, so it would never be valid.
@_date: 2015-12-07 02:31:59
I explained it in a bit more depth here.
You get a size increase because you no longer store the signatures in the block, you just have all your signatures empty and reference an output like [hash] OP_TRUE, where [hash] is the script hash to execute. Then you can sign for the transaction with an empty script sig. Data for the signature is held outside of the block, and is referenced by a hash in the block (probably in the sigScript of the coinbase transaction). Because the signature data isn't part of the real block, you can make the block+extra sig data be more than 1 MB.
@_date: 2015-12-04 21:46:00
Mm... yes, but you're also already competing with the original implementation of their scripting language, which is expressive enough that they can already do a Bitcoin sidechain on top of itself without modification, and which is already secured by its own token.
@_date: 2016-01-08 21:45:17
No, it's software engineering based on ignorance. Banks and anyone else using cryptography today only have to make sure their data can't be cracked in the very short term future because sessions eventually expire and passwords can later be changed. Bitcoin is a permanent, public ledger, and solutions for it need to be engineered from the perspective.
Just how long into the future will an algorithm or cryptographic primitive need to be secure such that it's considered secure enough from a software engineering perspective? 20 years? 30 years? At what point do you decide long enough of a time has passed with privacy that your past financial decisions should be able to be visible to the entire world to judge? If you run for president in 30 years, are you going to regret buying that heroin on the darknet that the whole world knows about? Your weird, politically incorrect fetish porn?
@_date: 2016-01-23 22:58:09
This is misleading. It's only true in the instance that you do not reuse addresses. If the scanning key found in the address ever becomes public knowledge, all the amounts negotiated with that ECDH key are revealed by uncovering the corresponding scalar. 
The difficulty of just straight factoring to find a number that makes sense starting from coinbases (which are known) in the current floating point encoding scheme should only be a system of 2^32 equations, \sum a_i = a for the masks and then for each bit in the range proof you have two possibilities for the mask. This is absolutely easy for a fast QC to bruteforce I think.
@_date: 2016-01-08 23:43:21
It's moving a lot faster than you think.
@_date: 2016-01-08 20:36:52
It's a bad idea to try to do this with EC cryptography. We'll be making a permanent ledger of transactions that is one day able to be totally unmasked post-quantum computing. It's going to lead to a lot of people being stupidly reckless with cryptocurrencies and then self-incriminating when the data is revealed.
There is no good quantum scheme to do group signatures for CryptoNote-style ring signatures or CT range proofs. They all involve massive key and signature sizes, and are slow to validate. If you're going to bother fixing fungibility, fix it correctly. Bitcoin is a ledger that leaves permanent public records of every transaction, which is much different from other systems of communication on the internet.
@_date: 2016-01-08 22:10:07
At [things that are not theoretical](
@_date: 2016-01-08 21:00:36
The length of numbers able to be factored by QC has been increasing exponentially over the past few years. You really want to be to one with everything out in the open on a public ledger in 5-10 years time when they can factor 256-bit length numbers in a nanosecond?
The banks will have moved to PQC methods by then, but the Bitcoin user will be screwed because their communication was all public and stored forever.
@_date: 2016-01-23 22:58:26
See above, I responded to adam3us
@_date: 2016-01-08 23:32:55
We could always do that. It could have been done before with a soft fork via replacing an OP_NOP with a new type of CHECKSIG or by a hardfork.
@_date: 2016-01-08 20:42:45
Great. And then when the range proofs are decrypted with QC, it'll be painfully obvious where coins are going because the input amounts will match up with output amounts.
@_date: 2015-08-17 20:02:23
When it happens to an alt coin it's called premining or mining with an unfair advantage. When benevolent anime character and divine ruler of blockchain fairness Satoshi does it, it's Bitcoin manifest destiny and egalitarianism.
@_date: 2015-08-17 18:31:32
There was a bug or possibly intentional coding that caused the genesis transaction to not be inserted into the database of transactions. From bitcoind, genesis transaction a99c7c572f07503bb52506cc6bcc18a0653d78c9c34fd7b576fe093723554bac is totally inaccessible with getrawtransaction. The coinbase is impossible to spend for the reason that it simply doesn't exist from the standpoint of the software. the data for the transaction still exists in the raw block of the genesis block, and there is a 50 BTC output there to public key 
presumably owned by Satoshi, since he made the genesis block.
@_date: 2015-08-11 14:41:27
I meant PR to Bitcoin master to test Schnorr, confidential tx, etc on testnet3. You could easily do this with new OP codes under OP_NOP3 to OP_NOP10, just like OP_CHECKLOCKTIMEVERIFY uses an unused NOP to softfork.
Segregated witness could even have been a new transaction wire version and block version, also rolled out on testnet3
@_date: 2015-08-17 18:43:24
I'm not sure that's true. It looks clear from the early blocks nonce data and the initial difficulty that Satoshi was operating a small server cluster using a modified miner to mine a large number of blocks for himself, at the expense of any other miners who were using his stock source code to mine. That doesn't seem egalitarian.
@_date: 2015-08-15 19:32:57
He almost certainly still has the genesis block key, as it's non-spendable and he has at least some pride in his work.
@_date: 2015-08-15 23:08:05
@_date: 2015-08-11 14:47:37
I don't understand? OP_CLTV was rolled out on testnet3 along with P2SH and every other feature in the history of Bitcoin's existing.
The eventual plan is to softfork Bitcoin itself with a new OP code to check the DMMSs that allow transfer of Bitcoin back and forth between sidechains, which seems to be the only actual contribution to Bitcoin
@_date: 2015-08-11 15:40:15
It seems like not a lot of development effort has actually gone to that. That's a simple PR on master for rollout of OP_DMMSVERIFY on testnet3, then enabling of the OP code on mainnet
@_date: 2015-08-17 21:44:12
ty based devs
@_date: 2015-08-11 16:20:57
More centralization, more censorship.
@_date: 2015-08-15 19:22:49
This is a joke... Bitcore has forever had the functionality to sign a message from an address.
The public key paid to from the Genesis block is this:
If Satoshi wants to reach out, I'm sure he'll use this public key, or his PGP key 5EC948A1.
@_date: 2016-02-04 04:39:32
Ah, yes, brilliant, let's use a **permanent public ledger** to break State and Federal law! Could there possibly be a better solution?
@_date: 2016-02-06 22:05:37
It won't be best chain, but it will still be a valid chain that old peers can sync to.
@_date: 2016-02-05 22:14:23
Block time: 
The proof of work isn't too hard. Just add a 32-byte nonce to the coinbase signature script and then H(Header with merkle root pointing to tree with zeroed coinbase scriptSig 32-byte nonce and zeroed header nonce || 32-byte nonce). Once you find a nonce, embed it in the signature script and use a USB ASIC to find a difficulty 1 block. This is perfectly acceptable to the network if the difficulty falls low enough. You'd have to add a real network difficulty into the scriptSig too. The peers download the block and verify that the embedded proof of work is correct by H(zeroed nonce header || nonce from scriptSig).
Of course, it's every bit as big of an engineering trainwreck as a segregated witness soft fork. If the segregated witness soft fork gets into master, I will dump the rest of my coins.
@_date: 2016-02-04 04:32:24
No, it didn't. That segwit method is hardfork and about 10 lines of code. And as far as I can tell, Elements has only been used with TestNet coins.
Bitcoin could do the safe, tiny hardfork, but instead BlockStream is opting to support the buggy legacy wire encoding and signature hashing methods. It sure is great to support a legacy O(N^2) hashing algorithm for SIGHASH_ALL that we can use to screw up the network at any time! Better not remove that!
@_date: 2015-09-20 06:16:17
He did sign one of the output PKHs recently
Off my lawn :) 17/6/2015
@_date: 2015-09-28 03:06:14
"Secure Sampling of Public Parameters for Succinct Zero Knowledge Proofs" by Eli Ben-Sasson.
@_date: 2015-09-26 03:59:47
Yes, the Pedersen commitment and niZKP via Ring signatures should confirm that the transaction spends exactly as many coins as were included as inputs. I'm implying that potentially a bug that in verification could be discovered that somehow allowed an invalid niZKP proof of no overspending to be accepted. TinyRam's SNARK was secure until Microsoft broke it, Zooko found bugs in libsnark, etc. It's a newly introduced scheme and it seems like a nicely well thought out idea with much simpler assumption than for many of these SNARK suites, but there's a reason BlockStream is using it on a sidechain rather than immediately integrating it into Bitcoin main.
@_date: 2015-09-26 03:13:50
Only certain portions are uncontroversial... CT I would estimate requires a hardfork because the outputs of a transaction must sum to be the same as the sum of the outputs. Stealth/ECDH still has no consensus on implementation or specification. Banks themselves have little incentive to add more privacy to the system, because they wish to abide by Federal regulations as much as possible. CT requires 2.5 KB per output, CoinJoin requires participants to communicate with one another and in the simplest case produces outputs which are readily detectable as joins. Coinbase could simply ban any user whose funds go downstream to a CoinJoin or anyone who receives coins from a CoinJoin. Stealth has its own large set of issues depending on how you implement it.
Merge avoidance is the easiest to integrate, and so far wallets haven't even been able to implement that. Maybe the exception is Core, with CoinControl, but no one uses Bitcoin-QT anymore.
@_date: 2015-09-08 06:15:59
If you really have that, then yes, you can reinitialize the PRNG with that value and regenerate the private key (use setSeed).
All the private key d is is 32 bytes pulled from the PRNG mod the order (n) of the curve (0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141).
You can also coredump the memory of the browser and try scanning 32 bytes at a time and taking Q = dG where d is considered the scalar (the 32 bytes) and G is the secp256k1 generator. Then Q is the pubkey, hash160 of the serialization gives you the address. PM me if you're shit out of options and I can write the software myself.
You can coredump with gcore, which you'd need to compile:
As the other user said too, try dumping the strings first and seeing if it's there.
@_date: 2015-09-21 05:52:20
ArtForz was great, I miss his posts. The rumour is that he is actually Solar Designer, but no one knows to this day. One thing for sure is that he's frighteningly intelligent.
@_date: 2015-09-26 05:51:46
The post appears to have been shadowbanned if you can still see it, because I can not. I'm guessing it was because you accused me of trolling. To be fair, my first couple of posts were, but it was only because of all the ridiculousness going on with Bitcoin-XT at the time.
I just get frustrated when people act like Bitcore core/Blockstream are the only serious people involved in cryptocurrencies... The Green/Ben-Sasson lab has been really incredible in its work and I wish Bitcoin would make a greater effort to figure out a way to support alternative blockchains with admittedly superior ability in some areas, rather than the economically fascist policy of "one-world-one-cryptocurrency". We're all here to compete and improve our products, and it must be the case that some other chain can provide a service to a subset of clients that Bitcoin can not. Sidechains are a sort of admission to this fact, but I'm not sure they're the most ideal or viable one. What's healthy for the ecosystem is healthy for every given blockchain, Bitcoin or not.
I'm eternally skeptic and I never forsaw Bitcoin breaking $100, so I'm open to surprises.
@_date: 2015-09-26 04:14:37
Yes, conceptually it's certainly more readable and comprehensible as compared to something like the original papers on SNARKs. Waxwing has a really good writeup about it on his github.
@_date: 2015-09-26 03:40:30
So Eragmus commented and then deleted these words, but I'll still address the points anyway since I already went to the effect to type them out.


Okay, so maybe you make a softfork where you allow zero amount inputs and zero amount outputs and then encode the value for the Pedersen commitment into the end of the transaction script... This is rather kludgy and you're probably better of just hardforking. We're hardforking soon anyway. Still have the 2.5 KB-per-out extra cost to worry about.


Reusable payment codes is another hack that requires on-chain interaction to establish payment addresses, so in the interest of saving space and enhancing scalability I don't think it'll be popular. It also adds more traceability than necessary, as you now have extra data related to your payment in the blockchain.




Most actual payments in Bitcoins merge a large number of inputs and pay to one output (plus change), aside from things like gambling websites and exchanges. Thus it's often easy to see when an individual is sending funds. There was a whole giant paper about this recent whose title I can not recall. CoinJoins have a large number of both inputs and outputs, and the outputs often sum to some of the input values. That is, if the input values aren't directly used, e.g. three people swapping 1 BTC each. When merge avoidance is added this still won't be less of an issue, because actual payments will be separated into smaller transactions, like ones only spending single inputs.
CoinJoin isn't a magic bullet and it has its shortcomings too.


Yes, BreadWallet is working on it. But it was recognized as a problem in 2009 and it still hasn't been properly addressed by any wallets to this day.
@_date: 2015-09-26 00:41:32
Privacy isn't going to be fixed in Bitcoin in the near future. We're still waiting on the conference in Hong Kong just so we can fix scaling. What's going to happen is lots of outrage about this happening, again, for the nth time, and then everyone becoming amnesic as another topic comes up. It's been the case for the past five years. Meanwhile, other blockchains are already have dealt with these issues. ZeroCash is now aiming for a release in less than a year.
@_date: 2015-09-13 03:21:11
First point is [actually from ByteCoin in 2011]( the user who also [first proposed secp256k1 ECDH to make stealth transactions]( [first described selfish mining]( and [first noted many of the common arguments regarding Bitcoin adaptive block sizing]( He should maybe get the attribution here.
The thing to keep in mind with these types of transaction is that outputs they contain can never be spent for COINBASEMATURITY (100) many blocks. They are essentially the same as coinbases in that if the blockchain is rolled back and then played forward because of a reorganization, the coins could be lost to the recipient forever because the new chain is too long to include them. Normally Bitcoin transactions never expire, so transactions without the lock could always be put in the blockchain later. This is not the case with something like a transaction that expires by a certain block height.
It appears as if Satoshi considered it but then seemingly made the erroneous assumption that it was impossible to safely incorporate into the blockchain because they could be lost in reorganizations. The same is certainly true for coinbase outputs, which is why we may not spend them for 100 blocks.
@_date: 2015-09-28 03:09:00
The compact scheme is broken. Andrew Poelstra said that it fails to prevent knowledge leakage, which is the entire point of CT.
@_date: 2015-09-26 03:07:10
1) Yes, there was recently a paper about trustless distributed zkSNARK setup requiring only one honest participant to function securely. "Secure Sampling of Public Parameters for Succinct Zero Knowledge Proofs" by Eli Ben-Sasson.
2) No, but that's inherent to any niZKP system. With confidential transactions, it's also impossible to tell if bug that allows Pederson commitment overflow has occurred and coins are generated out of nowhere.
3) In ZeroCash you can prepare and present a proof showing your intended destination and the amount of funds you received and sent, so yes, it is auditable.
ZeroCash has a rather large development team as of Q1 of this year, but they're being very hush-hush about it.
@_date: 2015-09-05 14:15:19
You're outlining the great tragedy of Blockstream: that Austin Hill could buy and sequester all the best Bitcoin devs for $21 million United States dollars.
The price for the ownership of a multibillion dollar financial system has been proved less than the average CEO severance package.
@_date: 2015-11-15 14:50:21
I wish it was. Let's say you do a 4 output CoinJoin. The four outputs are still visible and tracked after the fact, it's just not clear who owns them. And if the other three people spend them in obvious or visible ways, then the last user is unmasked. If you have a system where most payment channels are diverted through known, trusted, regulated entities because it's not only possible to do so but incredibly easy, and the battle is lost before it's even fought. The regulators can even just ban all outputs downstream of a CoinJoin.
CoinParty is a major improvement, but it was invented outside of the core team and so isn't much discussed. Even with such an addition to the protocol, if the primary use case of Bitcoins is transferring fiat money outside the control of the fiat systems and eventually channeling it back into fiat, you need to pass through a bank at some point. The banks can just collude and decide to ban all unknown outputs.
@_date: 2015-11-29 20:34:07
^ This.
Don't use variable-time algorithms if you are in an environment that demands constant-time algorithms.
@_date: 2015-11-02 20:17:23
It's one of the better things you can do. The community has become more toxic than it likes to admit after the 2013 boom. Everyone is welcome to their opinions, but there's been a marked rise in outright derision instead of constructive criticism. It used to be that questions were asked and people responded by explaining their position, not attacking another person and attempting to prove how smart they are to the world.
@_date: 2015-11-15 17:27:30


It could end up being simply "some output in the blockchain whose origin is unknown". The 'Blockchain Alliance' could keep a consistent database of all their customers' and affiliates' addresses and ban incoming Bitcoin deposits that are of unknown origin. This has already been happening with Coinbase and Circle.
@_date: 2015-11-15 17:33:55
That's my thought too -- Bitcoin is great as a distributed timestamping system backed by non-anonymous tokens, which is where the real value of Bitcoin lies. It provides a fast, low-cost, distributed international settlement system that is highly transparent. You'd have to be outright insane to use the Bitcoin blockchain for any large amount of criminal activity, because the tokens are so readily traceable.
I have way more Bitcoin than alt coins, and if the real value lies in Bitcoin being a tool of the classical banking system I'm more than okay with that.
@_date: 2015-11-20 16:32:22
^^^ xygo
Yeah, if you're new to coding in Bitcoin it's important to keep in mind that output scripts, despite being called scriptPk, don't have to have anything to do with public keys, and input scripts, scriptSig, don't have to have anything to do with signatures. The former is just a required condition, and the latter is just a statement satisfying the condition.
@_date: 2015-11-15 17:47:15


This is the default in CryptoNote coins, e.g. Monero... But it has its own series of trafe-offs, like permanently unpruneable transaction outputs. Forking to these types of solutions runs the risk of breaking years of software dedicated to the current functionality of Bitcoin (and expensively upgrading it), so moving to such a solution seems like it would be difficult.
@_date: 2015-11-15 20:03:37
Although the word itself isn't used.
edit: Looks like this post has been shadowbanned too... stay classy Bitcoin 
2nd edit: Thank you for unbanning the post.
@_date: 2015-11-24 20:34:27
Okay, but: you're doing an apples-to-oranges comparison of a protocol based around subjectivity versus cryptographic proof, which are two different things.
@_date: 2015-11-16 00:07:59
No, I have opinions and I don't have to resort to ad hominems to express them. If you would like to explain how incorrect I am conceptually, you are welcome to do so. I like being wrong; it means I've learnt something.
@_date: 2015-11-02 16:14:55
gmaxwell ejected his own ass from reddit.
Since joining Blockstream he's really been wrapped in his own ego. Which is a shame. Meeting him pre-2014 he seemed like a pretty easy going guy. Money changes people.
@_date: 2015-11-19 21:08:22
The implementation of it on a new blockchain like Elements is easy, but as a soft fork it's more complicated because now you have a legacy txid and a witness-free txid, and blocks must commit to the legacy txids still. A downside if you use the legacy hash in the merkle tree is that you don't get the pruning of signatures, but I think otherwise this is a hard fork. All the current Bitcoin software is tooled to the legacy txids, and you don't want everyone to have to overhaul their databases and systems to deal with the new form of txid... but maybe they'll have to in the long run.
Outpoints then also need to switch from referencing one type of txid to referencing the new type.
It looks like sipa tries to work around the merkle tree commitment issue somehow, although the code isn't commented and I'm not sure exactly what it does:
I don't know if a hard fork is that much better, because it'll be messy either way.
@_date: 2015-11-18 22:35:20
I actually agree with Luke Jr on this one. I don't think the authors of the BIP should use the blockchain to store data, as everything required to do ECDH can be done off chain. See: CryptoNote and their whitepaper, section 4.3. This is already implemented for Monero and other CN currencies.
@_date: 2015-11-24 19:56:34


Blockstream uses SPV and then demonstrates a history of actual work on top of the transaction's inclusion in the blockchain. This might be difficult to forge if the hash rate of the chain is large enough.


Okay. What's the penalty to just ignoring everything on the sidechain and voting yes to every single transaction spending Bitcoins on the mainchain that comes in from the sidechain? Why would they at all care if they get the fees either way?
@_date: 2015-11-25 00:53:53
I'm glad we agree. :)
@_date: 2015-10-09 05:17:23
I like you.
Contrast this to the opinion of Blockstream:


@_date: 2015-11-15 19:41:10


I think this is different to the way I've seen the term used elsewhere. The occasional argument from the core devs against a hardfork of any kind is because the system must remain "antifragile". The muscle here grows and adapts to the stressor. In effect, changing its size and shape to adapt to environmental exposure so that in the future it may better endure the environment. Bitcoin too must adapt itself to new stressors, or risk going the way of the dinosaurs. 


That's my issue with it. I never really see it being discussed openly. I feel like there has been an attempt to publicly understate the security challenges posed to making sidechains effectively work. As proposed, I don't think they work. That doesn't mean in the future they can not.
@_date: 2015-11-24 20:07:09


The Blockstream method relies on providing a proof that demonstrates the work of the entire history of the blockchain by using a skiplist. It sounds like you're just using the mainchain to vote consecutively in a chain of blocks, which has a smaller security margin. It also relies on the miners being incentivized to care about how they're voting, whereas the Blockstream method is based purely in non-subjective cryptography.
That's not to say the Blockstream method is the correct solution either (see above), but at least it doesn't involve subjectivity.
@_date: 2015-11-24 19:35:30
The sidechain --&gt; mainchain system sounds like "proof of whatever a bunch of consecutive miners say", which isn't terribly compelling. It seems to assume that the miners are compelled at all to care about what's going on in the sidechains, which is unlikely, and then vote in a sane manner about releasing coins relating to the mainchain. If I was a Bitcoin miner I'd just ignore everything about the sidechain, vote yes to every Bitcoin releasing transaction with fees, and take the fees. The Blockstream sidechain method is entirely cryptographic and so requires no Bitcoin miner to care about what's happening on a sidechain, but broken in a general sense due to variance. See the appendix of the Blockstream paper.
@_date: 2015-11-19 20:01:21
How? Schnorr still uses a 'random' nonce when calculating a signature. You can use a deterministic nonce generated by RFC 6979, however there's nothing stopping you from signing from any value of k in the signature:
r = k G
s = k - x H(m || R)
where k is the secret nonce.
As far as I know, there are no cryptographic proposals to fix this flavor of malleability. This is why segregated witness is the correct solution, because it skips hashing the signatures in the txid entirely.
Edit: I realized there may be some ambiguity, if you're saying that segregated witness corrects nonce-based malleability, this is indeed correct.
@_date: 2015-11-24 20:25:37


Okay, now you're making the assumption that Blockstream was readily trying to avoid because it's proven to be economically incorrect (re: NameCoin and other merge mined currencies). Even when NMC price was high it proved basically impossible to get &gt;51% to mine it, and to this day it remains insecure and containing only 35% of the Bitcoin hash rate despite its blocks having non-negligible subsidy. In fact, the Bitcoin network can't even stop people mining on mainnet with 2-3 empty blocks per day because they can't be arsed to run an actual Bitcoin node. And you're making the very, very dangerous assumption that people are going to add loads of merge-mined chains with their own computation and bandwidth requirements, dramatically increasing the complexity and maintenance of mining operations for what are likely to be, at least initially, extremely small fees?


This is not true. It doesn't seem like the Bitcoin miners are penalized at all for the way in which they vote. In the case of Blockstream's method, the transactions fail to validate. Here, the miners could see the outputs, collectively choose to spend them all to themselves, and walk off with everyone's money if I'm reading this right. There is no penalty in doing so aside from destroying all the sidechains, and you're making the subjective assumption that they won't want to do this.
@_date: 2015-11-16 20:03:52
This. I make a lot of controversial posts on here criticizing core, but libsecp256k1 looks very safe from the testing done and the 32x8/64x4 scalar implementations are blazingly fast. Everything in the codebase relating to secp256k1 ECDSA is very well done. Much of the codebase is from Wuille and he is a very capable (and friendly) software engineer.
@_date: 2015-11-15 20:12:56
"A system designed "to more adequately handle hard forks" is a system designed "to more adequately change the fundamental rules of bitcoin in arbitrary ways." With an adversarial mindset, that's not a desirable end-state."
The argument is that Bitcoin must not adapt through a hard fork, because adaptation means that an adversary could change Bitcoin in some way to make it advantageous to its own interests.
My argument is that failing to adapt may also make Bitcoin advantageous to an adversary's interests.
@_date: 2015-11-15 19:29:43
Our opinions diverge here. I believe that sidechains may end up being the destabilizing factor that causes the failure of Bitcoin. Antifragile is another way of stating "my system is non-changing". In the case of any biological or constitutional system, this means that the system is deceased.
@_date: 2015-11-19 00:57:01
If you like that platform, there is a Bitmessage implementation in Golang by Monetas that is easily built for iOS or Android.
Somewhat ironically, justusranvier also provided a BIP for the creation of Bitmessage addresses from BIP32 wallets.
@_date: 2015-11-07 01:30:17
Why? I voted once and only once. Apparently that's all that was needed.
@_date: 2015-11-16 20:08:31
I don't think the OpenSSL codebase is that bad, at least, in terms of the handling of the more primitive data structures and cryptography for secp256k1. The bug Wuille caught was an extremely rare edge case. Their encoding stuff has generally been the bigger headache, e.g. the recent forking consensus bug described here.
@_date: 2015-11-15 19:25:08


Unless I'm mistaken, unlocking requires either a coordinated, centralized party to do the unlock, federated peg, or DMMS. DMMS assumes the security of proof-of-work for the sidechain and gives a proof of inclusion on the sidechain that is included on the main blockchain to unlock the coins there. Neither of which is equivalent to the security of the Bitcoin blockchain.


This is your opinion. If a non-core team had introduced this proposal, it would be considered an alt coin. Even Bitcoin XT is considered an alt coin according to many core supporters.


Perhaps you don't understand. You need a large hash rate to secure a side chain that doesn't used centralized multiparty trust (federated peg). If you use the Bitcoin eventual securization mechanism, fees, and the sidechain has more transactions with fees than the main chain, the sidechain will have more miners and will end up becoming the new main chain. Merged mining is possible, but requires the miners to agree to verify the consensus rules of the side chain network -- and potentially introduce further insecurity in doing so, not to mention increased bandwidth usage.


I think sidechains are a dangerous idea that threatens the security of Bitcoin users, with a large number of core proponents pumping it as a safe alternative without divulging the potential side effects.
This is my opinion.
@_date: 2015-10-09 14:54:20
You need &gt;=33% of the mixing peers to be honest in their scheme during the transaction phase.


If you have &gt;66% of the mixing peers drop off the network at this time, your money gets stuck in oblivion in the escrow address.
edit: Corrected. It should be noted that most of the other steps require at least 66% honest mixing node participants.
@_date: 2015-11-15 14:14:11
This, unfortunately. You can fire up BitIodine or other Bitcoin tracking engines now and readily associate old Bitcoin addresses to the original Silk Road. This is by design. Bitcoin is a public bearer shares clearing system with no end user identity protection, something that would never have been created by the legacy banking system because of privacy concerns. Bitcoin is antiprivacy and the community struggles to deal with this. The only way to fix this is to port in features from alt coins (Elements, Monero, ZeroCash) but this looks more and more unlikely every day. Pegging to an alternative 1:1 non-Bitcoin token (side chains) is riddled with other unsolved security issues like how to prevent removing hash rate from mainnet and how to deal with variance in skip lists describing total work. The outlook on Bitcoin is not a broken dream, just a dream that most of the original users never subscribed to. This dream involves banks, regulators, and preventable fungibility.
@_date: 2015-11-20 01:40:47
If you remove them, you get an added benefit that when downloading the blockchain or verifying a transaction's inclusion into the blockchain with a proof, you need to download less data. So long as you trust the data up to some checkpoint in the chain, or the work done on the chain, you don't need to download those signature scripts and you trust simply that the hash of the signature script data points to valid signature data. In the classic Bitcoin case, in order to validate the hash of a transaction found in the merkle tree, you need to have the serialized data containing everything.
This is all daemon level, the implementation specifics as of yet I'm not too clear on. This is my current understanding: It apparently allows both classical malleable transactions and a new transaction type that is not malleable. For a transaction to have the signature scripts totally separate, it'd have to reference only inputs that all have a script hash suffixed by OP_TRUE (meaning anyone can spend it to old clients... the top stack item is true so any signature script is valid). Then signature scripts for this transaction are separately included not in the serialized block.
They only need to be provided separately at the block (daemon) level. You can introduce a new transaction type that includes both the transaction and signature scripts serialized into one buffer, then whoever is mining using an upgraded node can split them up. Or, you could choose a serialization type that submits them separately, it doesn't really matter, the transaction data itself is concrete and immutable whereas the signature data isn't, but the signature data has to validate the given transaction as before.
@_date: 2015-11-15 17:12:02
CoinParty is superior to CoinJoin with CoinShuffle. The problem with banks banning unknown Bitcoin outputs remains, despite it. The only thing that can solve this is mandatory protocol wide privacy.
@_date: 2015-11-19 19:50:42
Segregated witness is the correct way to deal with malleability.
@_date: 2015-10-09 06:26:51
The input transactions just need one output going to Ti with the required amounts, so you could have a single output of a transaction with many outputs going to Ti. e.g. you could send 2.0 coins to Alice, 3.0 coins to Bob, and 1.0 coins to a mix.
It could probably be done as one big transaction where the input peers all put their inputs into a transaction with a single large, collective output to T. They'd then round robin sign the inputs. There's a size advantage at the cost of privacy. T would then be spent as one input in a new transaction, with many outputs to the input peers. Of course, then you can readily identify these transactions on the blockchain: you'll have a transaction with n inputs to Ti, then a second transaction with n outputs from T. These might be considered more suspicious than a transaction with one input and one output, which will become very common once merge avoidance is implemented in wallets.
@_date: 2015-11-15 18:44:15
A Bitcoin, by definition, is an output on the Bitcoin blockchain secured by the hashing power of the Bitcoin blockchain. A sidechain is the transference of Bitcoins to another blockchain with a different protocol and different security assumptions -- an "alt coin". That is to say, a Bitcoin output on the Bitcoin main blockchain is not the same as a pegged Bitcoin token on a sidechain: the result is a 1:1 pegged non-Bitcoin token somewhere else. The redemption of the Bitcoins on the main blockchain from the sidechain uses security that is non-equivalent to the main chain itself.
You either solve issues with the Bitcoin main blockchain itself or you may as well use any other currently available alt coin that has the features you require. There is no inbetween. There are so many reasons sidechains are a bad idea, yet these are glossed over by their purveyors. They include:
(1) Inability to securely deal with variance of work in Bitcoin blocks, which is described for DMMS in the sidechains paper.
(2) Security requires either merged mining or removing hashing power from the main blockchain and importing it to the sidechain. The former case means that miners are now responsible for keeping track of yet more data and blockchain rules, which is a difficult call when the miners themselves would rather just expand the block size. The latter case means that if a sidechain becomes more popular than the main blockchain, the main blockchain would collapse and the sidechain would effectively take over the main chain, completely destroying Bitcoin. Both solutions are terrible.
(3) Many different security assumptions from new, hand-rolled cryptography in the sidechain.
@_date: 2015-10-09 14:51:59
I think you might be misinterpreting my comment. I meant that there's no reason a denominated output to a mix can't be found in a transaction with other mixing unrelated outputs. This is to break the pattern of (inputs) --&gt; (1x mix output, 1x change output).
@_date: 2015-11-20 00:32:55
Sure. This is more like ELI14, but anyway.
Bitcoin transactions consist normally of inputs and outputs. Inputs reference an index in an old transaction (an 'outpoint' pointing to another transaction's output given as [txid, index]) and have a signature script signing for that output. Outputs have a value (number of coins) and another script (often called scriptPk or 'script pubkey') that is a condition for them to be used as an input later in another transaction.
Signature scripts are inherent malleability vectors when an ECDSA signature is used as the condition for spending the referenced scriptPk, because they use a value k (nonce) which is allowed to be set to anything. So, you can make two totally different signatures that are both valid. In Bitcoin, the whole transaction is hashed, and so you get two totally different 'txids', or hashes of the serialized transaction. So, you can have multiple transactions with identical input references and outputs, but different signature scripts. In this example, because the two valid signature scripts are different, the transaction, despite using the same referenced inputs and having identical outputs, has two different versions with two different transaction ids. This is bad if you're a merchant looking for a payment with a specific transaction ID, because with multiple transaction IDs referring to the same basic transaction, you might miss receiving funds if it's not the ID you're looking for. This can also screw up chains of transactions that are reliant on a previous transaction's id: when you reference the 'outpoint' above, you reference the actual txid, which we now know is malleable.
All 'segregated witness' is is removing the signature scripts from the transaction and providing them separately, and calculating the txid based on the transaction _without_ the signature scripts. So now when you reference a txid, there's only one valid possibility for what it might be because the malleability source (signature scripts) is removed. In the case of the soft fork, it looks like the block commits somewhere to the signature data, with probably a hash of it stored somewhere, and then broadcasts the signature script data separately in a separate message from the block message. New clients get the block message and the signature script message, verify the signature scripts, and then insert the block. Old clients get the block message and still verify it as being valid even without the signature scripts, because in the soft fork case the way it's done makes it look like the outputs are spendable by anyone to the older clients, and so even with empty signature scripts they are validated.
@_date: 2015-10-04 22:41:38
It'd be a potentially messy hardfork. Every transaction after the block of the hard fork would now have its transaction hash calculated differently, yet they'd have to reference transaction hashes that are calculated differently.
There's this urge to fix as many things as possible with a single hardfork, but the truth is that designing specifications and implementations to address myriad different issues will cause such a time delay that the blockchain will probably suffer before the original issue, block size limitations, is corrected. A better solution is a system which is designed to more adequately handle hard forks in the future. The current design of Bitcoin may not be amenable to such a democratic future in new feature subsets.
@_date: 2015-10-04 21:09:35
This threat sounds exaggerated. For example, it's easy if you're a service provider to make your own auxiliary database that has transactions hashed without sigscripts, and then the service only needs to look for this hash in a block/mempool instead of the one with the script sigs (that's actually referenced in the block).
Transaction malleability has rarely ever actually caused issues with Bitcoin services, it was just blamed for MtGox's troubles way back when and that seems to have stuck with it.
You could hardfork to the CryptoNote/Elements solution (hashing signature scripts separately), but if you code your service backend correctly you should never have an issue in the first place. The only thing enabled by this change is more rigorous smart contracts.
@_date: 2015-11-20 00:06:32
Oh hey, you're back.
The way sipa is doing things in the soft fork makes perfect sense after reading the SE post below. It's not really all that complicated, it's just not the apparent solution if you're used to what Elements did. As evidenced from your mailing list post, this was not immediately apparent to you as well.
I don't think anyone was punishing or victimizing anyone. Everyone just wanted to make sense of what was being discussed. There's nothing conceptually difficult, and if in understanding how someone else has solved a problem we do some problem solving ourselves, I think we've actually learned more that if we'd simply had it spewed out at us.
It's important to sometimes make mistakes, to discuss concerns, and to come to a conclusion about things independent of the information that is available, and without criticism for our curiosity. This is how we grow as humans.
@_date: 2015-11-22 05:48:57
Well, it is a currency whose valuation is based almost entirely around public speculation.
@_date: 2015-10-12 20:47:43
Have you seen the way gmaxwell responds to people he doesn't like on IRC? A phrase like "extremely poor technical judgement" is gentle by comparison.
@_date: 2015-10-09 15:17:39
3 people are apparently Satoshi.
@_date: 2015-10-15 14:42:16
It's also nice to post criticism somewhere where a pro-Blockstream PR dude and his army of upvote bots won't immediately scramble and deride your opinion.
@_date: 2015-10-09 06:38:09
A T for each.
So, from the reading of the paper I'm guessing that by specifying Qi/Ti they do mean that for each input peer, a unique public key Qi/address Ti can be made.
I edited the wording a bit for my post to make this clearer.
@_date: 2015-10-09 15:30:46
Thanks, rereading it now... it's confusing because Table 1 clearly reports 2/3 security, but in the group signature case it looks like there may be relaxed tolerances as compared to the other steps before it. The other steps all seem to have 2/3 security. I guess if you make it to the transaction phase, you may need only 1/3 of mixing nodes honest and present, but before this 2/3 are required honest.
@_date: 2015-10-09 15:41:15
I know, I'm kidding. For example, I was around in 2010.
@_date: 2015-10-09 06:04:08
I'll take a stab. As far as I can tell, it's pretty simple. To start, it is the case that the public key of any Bitcoin private key is generated by multiplying by the generator, and thus directly corresponds to the private key. The public key is then hashed to give the Bitcoin address.
There are two parties, one who does the mixing (mixing peers) and one who sends their funds to be mixed (input peers).
Using a distributed, dealerless secret sharing scheme using polynomials (think Shamir's Secret Sharing), every person doing mixing (mixing peer) generates a fragment of a private key. The private fragment is then used to generate a public fragment, which is distributed to every single other person mixing. With each mixing person having all the public fragments, they can reassemble the public key and hash it to get the escrow addresses Ti for each input peer. 
These addresses Ti are sent to people who want their coins mixed (input peers) and the input peers verify themselves that they indeed were all given the same address, as there is a unique Ti for every input peer and each mixing peer should know it. These persons send their coins in identical denominations to address Ti in separate transactions. The input peers also send an encrypted form of their receiving addresses to the people doing the mixing, who then decrypt and shuffle them using a decentralized, secure method. It is ensured that while that while the mixing peers possess each address, they do know which address belongs to which input peer.
Finally, the mixing peers collaborate to produce a number of transactions equal to the number of input peers spending one input from the initial escrow phase to one decoded output address given by an input peer. Each of these transactions, with an input from address Ti, is signed by a distributed method (sometimes called a 'threshold signature') and then broadcast to the network, giving each input peer an amount equal to their original inputs but with an unknown origin.
In effect, for n input peers you get n transactions to various Ti and then n transactions from Ti to an input peer's address, for a total of 2n transactions on the network.
@_date: 2015-11-16 00:25:21
From you:




Derision of core team supporters against persons who do not support them, and the disparagement of legitimate criticism regarding their constructs.


This is an attack on my motives.


This is all of the things you just defined.
@_date: 2015-10-18 15:52:08
Shill Hard 2: The Shardening
Monetas has been working hard to make such a system deployable by voting pools for the last two years, but has all but entirely been ignored by the greater Bitcoin community.
Liquid also substitutes what had "formerly" been performed by centralized, well-engineered clearing systems for _decades_ with a totally insane data structure for the application, a blockchain. My guess is that Liquid will crash and burn within a year or two due to having no useful application and no interesting properties beyond systems that are already well in place. In the meantime, we'll never stop hearing about it thanks in no small part to the [amount of Goebbelsian marketing upvote/downvote bots]( 
@_date: 2015-11-07 00:24:25
@_date: 2015-11-19 00:51:09
I don't see most of the listed disadvantages as disadvantages, so I have no guilt where honesty is concerned.


It's only vaguely more difficult, and your implementation already requires intensive modification to a wallet to recognize your new transaction types.


Publish R in the transaction in an OP_RETURN if you're really paranoid, so that by scanning the blockchain the user can always redeem their transactions. This is certainly less intensive than your scheme, and can be optional for the end user.


If you use a proper asynchronous communications protocol, this should not be an issue. It's much more likely that pretty much any secondary network you access will be more private than the Bitcoin blockchain, which permanently stores data in _public_. The information you transmit to the recipient is already encrypted, so there's no worry about someone in the middle decoding it, and most other communications methods involve non-permanence of their content.
You also have to transmit your notification transaction to a Bitcoin daemon somewhere, so I fail to see the advantage of sending to this P2P network as opposed to a protocol deliberately designed for the secure transmission of data to some recipient (which a blockchain is _not_ intended for).
@_date: 2015-11-16 00:11:08
Well, that I agree with. I more take offense to phrases like "never roll your own crypto" from people who roll all their own crypto, or the assertion that only a single group of developers is capable of deciding what is best for Bitcoin in the future. In terms of hard and soft forks. I don't know how many PRs you've submitted to the Bitcoin repo on github, but over time I've gotten the feeling that it's not so inclusive as it's made out to be.
@_date: 2015-11-19 00:34:59
Instead of communicating your outputs on-chain, communicate them off-chain. For example, the data containing the transaction hash that they can redeem, R = rG, and any extra data they wish to communicate can be sent to the recipient by using the method described in ANSI X9.63, section 5.8.1 (Elliptic Curve Encryption Scheme).
You could use any number of protocols as a communications medium, e.g. e-mail or Adam Langley's Pond over Tor if you'd like more privacy.
In this way you will produce Bitcoin outputs that are indistinguishable from others on the blockchain and that use up no additional space, as opposed to your protocol. This is also much less analysis friendly than your protocol. The end user does not need to scan for these outputs, they receive them directly from the sender off-chain.
@_date: 2015-10-18 15:46:02
How does this incentivize full nodes? All it seems to incentivize is having a node online that does a single function unrelated to network security, which is to sign for random subsidy funds. It seems half baked at best.