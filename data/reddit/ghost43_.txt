@_author: ghost43_
@_date: 2018-01-08 03:55:25
You need to create a new seed, and choose segwit there. Seed words are versioned so that it is easy to maintain long-term compatibility.
@_date: 2018-01-07 04:31:15
The private keys never leave the Trezor.
@_date: 2018-01-08 03:35:59
Unfortunately that's not the case.
With 2.6-3.0.3, any random website's javascript can gain access to RPC.
But the same is true for 3.0.4, you just have to trick the browser to think it's a "simple request". (0)
The quick fix deployed in 3.0.4 was to depend on the browser to enforce the CORS policy (disable CORS), but turns out CORS is not enforced if the browser deems the request to be a "simple request" (those do not trigger a "CORS preflight"). (1)
So the fix deployed in 3.0.5 is to not rely on the browser but instead
- implement password authentication for RPC, and set a strong random password by default
- disable most RPC functionality if the GUI is running
(0): 
(1): 
@_date: 2018-01-08 03:25:48
Actually this vulnerability does not really affect Tails.
To exploit it from a browser, you need javascript. The NoScript extension blocks javascript. The Tor browser has NoScript by default. The default browser in Tails is the Tor browser.
@_date: 2019-07-10 12:43:59
Price on 2013-11-21 was around 1000 USD.
42 months later, price on 2017-05-21 was around 2300 USD.
2.3x return. If that makes you "rich as fuck" then you were already rich to begin with.
@_date: 2019-07-07 22:00:57
 [
@_date: 2019-07-19 03:03:10
Did he mean Gavin?
@_date: 2018-01-07 04:34:27
You should still update Electrum, e.g. websites exploiting the issue can read your xpub (so can see all your addresses and balance, but not spend).
@_date: 2019-07-25 12:48:00
It's more complicated than that. You can construct all kinds of scripts that use private keys. There is no clear number like the "4" you mentioned.
Even if you are listing "common" script templates, there is also P2PK which was notably used for the first few years of coinbases.
@_date: 2019-07-05 06:27:13




Yes, you are missing that whoever closes cannot use CPFP because of the CSV delay.


If you are the initiator, you are supposed to renegotiate onchain fees when you think they substantially changed. If you are the other guy, you are supposed to close the channel when you consider the onchain fees in the latest commitment transaction are starting to become dangerously low compared to market conditions.
@_date: 2019-07-17 01:47:11
Bitcoin is horribly inefficient not because it is distributed, but because it is distributed AND every node is independently running the same calculations. Every node is doing redundant work.
Distributed systems where the work is sanely assigned among N workers can be much more efficient than central systems; assuming you could not simply scale a single system to N times the processing power (e.g. see clock speeds of processors).
@_date: 2019-07-17 17:10:01
And still no support of bech32 withdrawals?
@_date: 2019-07-31 01:50:45
Funny remark at 3:11:53 : 
They too know you cannot stop Bitcoin.
@_date: 2019-07-01 12:33:07
No, naively it is not possible.
1. You are creating new onchain transaction outputs, and lightning channels have a single funding transaction output they are based on. The outputs you are creating as you have indicated are small (presumably pool payouts), so they are not large enough to be used as funding outputs.
2. Coinbase outputs are unspendable for 100 blocks, so you will need to wait that out.
So it seems to me that whatever you do, you will need to make an onchain transaction spending the coinbase outputs, which will cost onchain fees, which is what you were trying to avoid in the first place.
However, what would be possible in pooled mining, is that the pool could become a temporary custodial of funds (which I believe is often already the case) and the pool itself could offer to pay the payouts via lightning.
@_date: 2017-12-15 06:02:09


Are you saying that they support sending to bech32 native segwit addresses? Can someone confirm this please?
@_date: 2018-05-09 13:33:08
It has been published now. See [
@_date: 2018-05-28 08:39:10
Since the introduction of segwit, fee per byte is ambiguous. You should not make bets until clarifying what you mean by it. Blockchain info is actually calculating NOT what people usually mean by it. What Bitcoin Core cares about when relaying transactions, evicting from mempool, and building blocks, is fee per VIRTUAL byte.
fee per weight is a quarter of fee per virtual byte \(as 1 virtual byte is 4 weight units\)
so looking at that txn, it is just above 1 sat/vbyte
@_date: 2019-03-16 00:32:14
You can use the 3.2.4 version.
To update to 3.3, see [
@_date: 2019-03-26 04:12:35
Given m, n, and the n public keys, you can construct the redeemScript, and from that you can construct the address; hence, yes, you can tell.
@_date: 2019-03-21 14:30:35
Can this finally send to bech32? Or is that too much to ask?
I know this has nothing to do with hardware, I am just disappointed that no ATM seems to be able to.
@_date: 2019-03-23 05:03:19
The research only considers trades on exchanges. They are measuring it as a commodity. They don't have (or did not include) data regarding how bitcoin is being used.
@_date: 2019-11-01 21:19:38
Paying the invoice likely failed because when OP made this video testnet was kind of broken.
Mining difficulty was amazingly low (difficulty reset to 1) and blocks were coming in every second.
Just look at the video at 03:48: [
Watch the network orb in the bottom right. You can see there is a blockchain fork; that only lasts around 1 second.
Now, look at the failures OP got for his payment attempt at 04:33: [
9 out of 10 are EXPIRY\_TOO\_SOON. Which means the CLTV block heights that are encoded in the onion payload of the payment attempt are too close to the present.
The CLTVs are too close because while the payment (onion) is sent around between the hops on the network; the network latencies are long enough for several blocks to get mined.
The conclusion is that testnet is completely unreliable for testing lightning.
@_date: 2019-11-30 01:37:03
This might work with a password you came up with, as those contain much less entropy and they are usually somewhat personalised. However, you're not going to remember 128 bits of entropy you have only seen once many months ago.
@_date: 2019-03-13 13:51:47
One thing that almost always works when encountering network issues with Electrum, is to simply set it to use a Tor proxy. Just go to the network settings &gt; Proxy tab and check "Use Tor proxy at port ..."
@_date: 2019-03-25 13:17:01
BOLT 1.0 has been tagged.
@_date: 2019-03-12 19:26:35




Do you mean the fixed salt? Why don't you use per-user or per-contact salts?
@_date: 2019-11-12 14:07:52
@_date: 2019-03-19 00:42:14


This is because you are using an older version. You need to update. Your original issue should also go away then.
@_date: 2019-03-12 13:30:19


Oh wow, that's amazing. So, let's do math then.
So they use 512 iterations of HMAC-SHA256 with a fixed salt.
A GTX 1080 can do about 3 billion iterations of SHA256 per second. ([
Let's say there exist 10\*\*10 phone numbers total.
For a single iteration of HMAC-SHA256, you need \~2 iterations of SHA256.
That gives: (2\*512\*10\*\*10) / (3\*10\*\*9) = 3413.3 seconds &lt; 1 hour to calculate the hash for every possible phone number, and to be able to invert any hash \~instantly after that.
Thanks for open-sourcing the code!
EDIT: I see after my post, you have taken down the repository from GitHub...
@_date: 2019-03-13 03:36:38
From your link:


Without third party applications, what Trusty can be used for is what is directly implemented out of the box.
Currently, the KeyMaster API in Trusty does not support ECDSA on the secp256k1 curve, and it does not support BIP32 either. Both of these would be needed for HD wallets. Without those, what exactly do you want? :/
You simply cannot have "hardware wallet"-like guarantees with an Android phone today (not that I think you can in an iPhone); not anywhere close.
For example, what Breadwallet does, upon which all their "hardware backed" key storage claims are based, is store an AES symmetric encryption key in there (the hardware keystore, using the KeyMaster API). This key is then used to encrypt/decrypt the seed words (through the secure API), whenever they are needed. The ciphertext and the IV are stored in SharedPreferences (application-private standard filesystem file, secured only with file permissions -- this is what most Android wallets use). Whenever the app needs to sign a transaction, or derive a key for an address, it calls into the KeyMaster API, decrypt the seed words, put the seed words in userspace memory, derive the child keys (BIP32) outside the secure environment, do the ECDSA signing outside the secure environment. What is being signed (the transaction; well sighash) is also constructed and shown to the user using the device display (outside the secure environment).
How does the KeyMaster API in the secure environment decide whether you can use an AES key it has, you might ask. Well, it knows which application created a key, and checks the asking process against that. That can be spoofed via a root exploit, or by any process running as root. What about the SharedPreferences that are application private that store the ciphertext, how can that be defeated? Well you just need to be root to change the filesystem permissions. So what do you need to defeat all protections? You need to be root! What do you need to defeat protections of other Android wallets that do not use the KeyMaster API? Same thing: root.
Why was the KeyMaster API even created then?! Well, it has different goals in mind. Its main objective is to prevent at all costs the extraction of the secret stored inside. The documentation even says so explicitly, that against a privileged (root) process, the guarantee it provides is keeping the secret safe: the attacker in that case can \_use\_ the key (e.g. to decrypt or sign something) but not extract the key itself. Note that in Breadwallet's case, the key is an AES key that in itself is not even that interesting, what an attacker would want is using the key to decrypt the seed words, which he can do.
I am not saying Breadwallet is doing anything wrong, nor that they could be doing it any better really; I've mainly singled them out because they have the loudest claims of doing it securely. In reality, it simply cannot be done securely on current smartphones. And Samsung could have changed this if they implemented ECDSA on secp256k1, and BIP32 in the secure environment.
But even that would not be as secure as a dedicated hardware wallet, for many reasons, the most obvious being that it would not have a dedicated trusted screen where you can check outputs.
@_date: 2019-11-21 00:53:35
Indeed. And it can be sent back via any number of side-channels. For example, a private key can be leaked via a signature, leaking info through the choice of nonce.
Imagine you are a hardware wallet supply chain attacker; or in this case the evil manufacturer itself.
The RFC6979 deterministic nonce generation algorithm takes a `signing_privkey` and a `msg_hash`, and gives you back a nonce `k`. The attacker could store their `attacker_pubkey` on the device somewhere and then modify the nonce generation such that instead of the `signing_privkey` it takes `sha256(ECDH(signing_privkey, attacker_pubkey))`.
Then the attacker watches the blockchain and tests all sigs whether they have been generated like that. They can compute the same nonce `k` as `sha256(ECDH(signing_privkey, attacker_pubkey)) == sha256(ECDH(signing_pubkey, attacker_privkey))`. Now that the attacker can reconstruct the nonce, they can solve the ECDSA equation for the private key. Hence the evil device can successfully exfiltrate the private key as part of signatures it creates (and in such a way that only the attacker can reconstruct them!).
Even if you are not using RBF, the attacker can now collaborate with a miner to double-spend your coins before the original tx confirms, and your money is gone.
@_date: 2019-11-25 16:18:19


No we could not. At most, witness data could have been made free, but the non-witness part of the transactions in a block even then must have remained under 1 MB.


Making witness data cheaper, now, would be a hard fork. The segwit "trick" to increase the block size was a one-off. You could make witness data more expensive: that would be a soft, and that would reduce the max block "size".
@_date: 2019-11-19 17:02:43
Trezor T has a touchscreen and lets you choose whether to enter the passphrase on the device or on the host machine.
@_date: 2019-03-16 06:14:11


One onchain UTXO (funding outpoint) can only "onboard" one person. That is, if you want the graph to be connected.
If a channel onboarded two people, that means neither of them had any channels before, which also means they are isolated from the rest of the network. They need another channel. At which point they opened two channels to onboard two people.
A connected graph of N nodes needs to have at least N-1 edges.
@_date: 2019-11-21 00:56:47


This is a really hard problem; easier said than done. See my other comment for an example attack.
@_date: 2019-03-14 04:13:09
but but... they "also have a feature where you can pick your strategy and it will play automatically for you"
surely, that is great... for someone :)
@_date: 2019-11-12 15:34:44
Tap the name of the wallet at the top; and then select "Show seed" at the bottom.
@_date: 2019-11-21 14:11:35


The Bitcoin Core wallet can spend segwit and non-segwit UTXOs in the same tx; so can Electrum with imported keys; and also I believe at least mycelium and coinomi too.
@_date: 2019-11-24 20:33:00
A miner can mine a block with a conflicting transaction.
@_date: 2019-11-21 01:04:51
You cannot be sure which one is change unless there is address reuse. You are just making educated guesses at best.
@_date: 2018-10-11 11:01:56
Right click &gt; Remove.
@_date: 2019-11-03 23:30:32


Typically they are 12 words. All modern Electrum seeds are 12 words.
Older versions used to generate 13 word seeds; and originally "2fa" seeds were 24 words.
@_date: 2019-03-06 02:20:26


You probably mean BIP37. SPV is about maintaining a chain of blockchain headers and verifying merkle branches against the merkle roots in the headers to determine transaction inclusion in a block.
I would guess Neutrino is or will be using SPV too. It's orthogonal to BIP37/BIP157.
Electrum is using SPV, but not BIP37, for example.
SPV is described in the Satoshi paper, BIP37 came around 2012.
@_date: 2018-10-19 11:30:27
Electrum two-factor wallets work exactly like that. They are 2 of 3 multisig, where the user has 2 keys, and the third key is controlled by a company ("TrustedCoin"). The seed words generated at wallet creation backup both user keys. The seed is only shown once, the user writes it down, and then it is not stored electronically (it is even preferred to generate it offline in the first place). The wallet file will store user_key_1 only. TrustedCoin has key_3, and the user is given a QR code during wallet creation, that is used to initialise (e.g.) Google Authenticator. Typically when user wants to send, they will enter the wallet password to unlock user_key_1 and sign with that, and then the user is prompted for a one-time-password from Google Authenticator, which is sent to TrustedCoin along with the partial transaction, who sends back the fully signed transaction. Funds are not locked however, as even if TrustedCoin disappeared completely, the user can restore both key_1 and key_2 from their seed words backup, and spend their coins.
@_date: 2019-03-25 04:30:56


Except your premise is that the fake ID is good enough for the exchange in the first place, which means it's already valuable.
Just as an example: someone can use your leaked "fake ID" to register on another exchange, sell some stolen bitcoins, and then the trace leads back to you.
@_date: 2019-11-26 23:42:52
see 
@_date: 2019-11-13 22:47:08
It only creates a single address? Way to encourage address-reuse.
@_date: 2019-11-13 02:28:07
Tap "default\_wallet"
@_date: 2019-11-22 23:32:42


Please explain how this could work. How do I "check" the nonce?
The naive way I can see right now, would require `signing_privkey` (I would reproduce the nonce independently, using RFC6979, and then compare) but that is only available on the device.
@_date: 2019-11-21 02:14:39
Yes I am familiar with the common heuristics.
In the case of [29a3efd3]( what makes them/you think the 500k btc output is the "value being transferred" and the 50k output is change? There are 11 inputs all with 50k btc value (and the fee is zero). It makes no sense. None of the typical change heuristics apply.
@_date: 2019-11-30 04:00:12


That is exactly what you should do. On a typical machine you can sync in less than a day. This way, you would be able to get the data you currently think you need, and if you later realise some other data is also needed, you will already have that available too. Also, you will be able to get fresh data whenever required.
`bitcoin-cli getrawmempool`
@_date: 2018-10-27 01:46:07
They still can be in the middle of payments. Just run high liquidity low fee low cltv-delta LN forwarding nodes.
@_date: 2019-11-19 00:23:26
Yes, of course it is possible. You can run your own Electrum server at home or wherever, and then run Electrum on Android, and point the client on your phone to your server.
@_date: 2018-10-17 00:16:55
Full segwit support and being able to send to bech32 are two very different things. The latter you can implement in a spare afternoon. Anyone who cannot send to bech32 at this point is just pure lazy; there is no other excuse.
@_date: 2019-03-01 12:27:28
You would rather have more shitcoins installed at once than a secure bitcoin wallet? OK.
@_date: 2018-06-11 07:36:04
What is "cryptocurrency mining equipment" though? Any ASIC for any POW used by any crypocurrency? FPGAs? GPUs? CPUs? Pen and paper?
@_date: 2019-08-06 03:24:35
In the Qt console, try `make_seed(264, None, True)`
@_date: 2019-08-09 14:20:40
The Bitcoin CEO, who else? :)
@_date: 2018-06-16 12:31:40
You look up the funding transaction outputs for the channels on the blockchain, so that you know their capacity (but not balance), which narrows it down. Then, you select a route and try it. If it fails, an onion error will propagate back to you, which will contain broad info regarding why it failed, including which edge/node was faulty. Then, you try again, but this time you route around the faulty node/edge.
@_date: 2019-10-24 13:26:28
Pubkey-hashing doesn't really protect against quantum computing. Especially with fee-markets and "small blocks". While the transaction is unconfirmed, it is vulnerable, as at that point the pubkey is already visible but it hasn't been mined yet. With a mature fee-market, such a situation (tx being unconfirmed) can easily persist for several hours, maybe days. Sure, one could argue that "slow" quantum computers would emerge first which would need e.g. months to crack ECDLP; maybe.
Further, a significant fraction of the Bitcoin supply (maybe a third?) is locked in UTXOs that have their pubkeys known. This is mostly because early coinbases used P2PK (no hashing), and because of address-reuse. If one third of all existing bitcoins was suddenly "stolen", including "Satoshi's" coins being moved, the market would really "crash". It would be mass hysteria.
If you look at the witness version 1 proposal, the current idea is to just [put pubkeys in the outputs directly]( and don't bother with hashing.
@_date: 2019-10-24 11:56:09
That is an absolute limit, so it is quite possible to hit with a large tx during congestion. For a 100 KB tx, it translates to 100 sat/byte. Some people hit it in late 2017.
@_date: 2019-10-03 22:46:57
That website is controlled by some long time community members. They are e.g. not core developers. There is also [bitcoincore.org]( which is controlled by some core developers.
@_date: 2019-08-05 14:08:12
There is no point in having a 24 word seed, but if you really want to, you can create one using the command line.
electrum make_seed --nbits 264 --segwit
@_date: 2018-06-11 07:21:52
Look into "2FA" wallets by Electrum. It's 2\-of\-3 multisig, with the user having 2 keys, and a company called TrustedCoin having the third. The first user key is stored in the wallet, the second is a cold key for backups that should never touch an online machine. To sign normally, you sign with the first key, and then the app prompts you for a one\-time password (google authenticator), which if correct, TrustedCoin will sign the tx too.
If you want to, you can of course store the second key in a bank vault, in which case, it is fairly similar to what you described.
@_date: 2018-06-30 22:42:02
What is complicated about putting two pieces of plastic on top of each other?
@_date: 2019-10-03 22:59:09
If you just want to connect through a tor proxy; run Tor browser in the background, and then in the Network settings, go the Proxy tab, and enable "Use Tor proxy at port ..."
@_date: 2019-10-04 20:12:40
How did you manage to do it? Using what software? Or did you write custom code?
IIRC it's a standardness rule that segwit can only use compressed pubkeys; not enforced by consensus (yet...). This means that a miner can include such a transaction in a block. You can try to contact a mining pool and ask them to include your tx.
@_date: 2019-10-04 23:47:02


Which wallet application is that?
@_date: 2019-10-03 12:43:51


someone drank the koolaid. good luck hosting your website; and half those other things. and no electricity? joking, right?
@_date: 2019-10-09 22:31:04
[@_date: 2019-10-28 00:12:48
Looking at the graph, he probably means pay to "bare" multisig (OP\_CHECKMULTISIG directly in scriptPubKey). Armory used to do this for example, or custom scripts using Bitcoin Core.
@_date: 2019-10-17 12:12:18


* Non-Custodial Wallet
* Supports all ERC-20 Tokens
* Supports up to 5000 TPS
* All main cryptocurrencies: BTC, LTC, ETH, Zen and more
\^ I see. So it's not open source. Then Non-custodial is automatically invalidated. The rest of your features only tell us it is not a serious project.
@_date: 2019-10-14 13:42:11
In what way does it not work? It should.
@_date: 2018-06-30 21:05:24
From a user perspective,  libsecp256k1 is much faster than python-ecdsa (what was used before, and is still used in case libsecp256k1 is not available). For example, signing a transaction with 100 inputs with python-ecdsa takes about a minute; while with libsecp256k1, it is below a second. This was mostly a preparatory change for lightning, as the lightning protocol involves lots of elliptic curve operations (e.g. signing) that need to be fast.
@_date: 2019-10-11 23:45:20


If you consider taproot a gigantic leap in privacy, maybe. It's a small step in that direction at least.
Best case scenario is someone figures out something in the next 2 years, there is no way a "gigantic leap" would get soft forked in that fast.
@_date: 2019-02-20 13:14:00
From [ : 


So, checksums are useless against a website takeover/hijack/MITM.
@_date: 2019-08-09 14:21:34
Make sure you get clearance for mentioning the "Internet" as well!
@_date: 2019-06-18 23:24:33
Please [enable debug logging]( and see if there is anything useful there.
Also, does it offer to send a crash report? If so, please send it.
@_date: 2019-06-19 01:25:06
That's an old answer.  [
@_date: 2019-06-06 13:08:04


He is saying that the price will become zero as a consequence of governments shutting down (all) exchanges. We have long known that centralised exchanges are a weak point. Luckily, better and better decentralised solutions are emerging. For now, consider using bisq to buy/sell.
@_date: 2019-06-19 23:51:49
IIRC that was (is?) version 2.6.4 which is ancient at this point. I don't think it was ever updated.
@_date: 2019-06-18 23:24:04
Please [enable debug logging]( and see if there is anything useful there.
Also, does it offer to send a crash report? If so, please send it.
@_date: 2019-10-04 11:30:37


Well, actually the [Windows binaries]( and the [Linux Appimage]( are built reproducibly. This is mentioned on both the git repo (see my previous links) and the website ([see the top of the page on electrum.org](
The [MacOS binary]( and the [Android APK]( are not deterministic. We tried to make these builds reproducible too but failed so far. Arguably the Android APK is both much harder (due to complex toolchain) and less important (as most users install through Google Play anyway) but at least the Mac binary would be really nice to be made deterministic. Help/contributions towards this (either) would be most welcome!
@_date: 2019-02-22 04:05:12
depends on what you want to query by, and how fast.
bitcoind + txindex + electrumx is around 300 GB, which is enough for a bare-bones block explorer.
bitcoind + electrs (modified for esplora) needs around 1 TB (somewhat less, after sync has finished AFAIU), which is what [blockstream.info]( uses.
@_date: 2019-10-05 00:00:40
And what did you have to do to create a segwit address with an uncompressed public key? Was there a GUI option for that?
@_date: 2019-06-10 23:21:22
Like you yourself said, you can use Electrum to sweep your Casascius mini private key. Make sure to use the latest Electrum version, and to get it from the official website.
@_date: 2019-06-17 12:32:51


@_date: 2019-06-11 12:50:20
Could you check if the Nano X works with Electrum 3.3.6?
Please report back, and if it doesn't then I'll look into it.
@_date: 2019-02-17 20:23:36


Yes, well, I am not sure about this. I think we will just make libsecp256k1 a required dependency (atm it is only optional), and just use that. Then there would be no need for a python Schnorr implementation; at least for Electrum.
@_date: 2019-06-30 20:48:12


Does Eclair really have watchtower support? Source?
@_date: 2019-02-17 20:20:48
the timestamp is unsigned 32 bit, not signed, so it's \~2106
@_date: 2019-06-24 14:10:09
IIRC Reddit has since changed how it counts "online users".
@_date: 2019-12-18 14:50:56


Yes, if you read your own link, it would confirm what I said.


@_date: 2019-12-18 13:28:54
Even with the timestamp, the 4 byte nonce is not enough these days. The scriptSig of the input of the coinbase tx is used as extra nonce.
@_date: 2019-02-10 20:31:36
Yes, false positive. See [discussion and response here]( on Electrum GitHub.
@_date: 2019-12-19 23:44:49


And hard copies can get water damaged, burnt or lost.
@_date: 2019-04-19 15:02:08
From  IRC logs:
    [2019-02-17 04:42:58 +0100] *	bitcoin-git (~bitcoin-g has joined
    [2019-02-17 04:42:58 +0100] &lt;bitcoin-git&gt;	[bitcoin] gmaxwell opened pull request  Update assumevalid, minimumchainwork, and getchaintxstats to height 563378 (master...201902-assumevalid) 
    [2019-02-17 04:43:01 +0100] *	bitcoin-git (~bitcoin-g has left
    [2019-02-17 04:43:03 +0100] &lt;gmaxwell&gt;	sipa: as requested,  you might want to 0.18 tag.
    [2019-02-17 04:45:31 +0100] &lt;echeveria&gt;	gmaxwell: isn't the block hash usually set back a bit from the tip?
    [2019-02-17 04:45:45 +0100] &lt;echeveria&gt;	the one in the pull request is approximately now. 
    [2019-02-17 04:48:59 +0100] &lt;fanquake&gt;	by the time that PR gets merged, and then 0.18.0 released, it should be back from the tip. testnet is usually set back a larger amount.
    [2019-02-17 04:49:57 +0100] &lt;echeveria&gt;	right, sure
    [2019-02-17 05:03:11 +0100] &lt;gmaxwell&gt;	echeveria: it will be by the time it gets merged.
    [2019-02-17 05:04:04 +0100] &lt;gmaxwell&gt;	IIRC the first time I did it I set it further back, but then noticed how long it took to get merged, since then I've set it right at the tip after first looking to see if I could find a competing block
@_date: 2018-11-03 01:23:16


Whitespaces before/after the seed don't matter.
@_date: 2019-04-30 13:03:34
People are going to be disappointed big time when they realise how far Schnorr cross-input signature aggregation is. It certainly won't be in the first version of Schnorr (which probably comes in witness version 1).
@_date: 2019-01-26 19:31:46


How do they know how much bitcoin is stored in wallets? Do the wallets phone home? Is there really ~2 million bitcoins stored in breadwallet?
@_date: 2018-11-15 01:21:44
Fewer than 42.
@_date: 2018-03-05 16:12:31


Good thing you can do that too :)
@_date: 2019-01-28 09:13:30


Unlikely. Look at the picture. He's scanning a QR code from a piece of paper. It could be LN but it is probably not.
@_date: 2019-01-24 02:12:26
Why not? The difficulty retarget is based on that timestamp. I don't see a way around a hard fork.
@_date: 2018-02-24 00:38:55


What do you mean by this? Not using bip39/44? This has been discussed countless times ([for example]( they are simply bad design. Also, Electrum came BEFORE bip39! Do you expect the devs to time travel? :)


That's the thing, there will never be consensus. See bip39. Oh wait, there is consensus:


Is that consensus enough?
@_date: 2019-01-27 13:56:56
He's worried about two things:
\- the bank opens the box by itself and steals the coins
\- the bank destroys the box contents
Banks open/destroy safety deposit boxes without the owner's consent [sometimes]( it certainly would not be unprecedented.
@_date: 2018-11-15 00:53:50


Not really.
Napkin math says an output is 40 vbytes, and a block can fit 1_000_000 vbytes. That means 42 outputs per second, and this is ignoring inputs and other overhead.
@_date: 2019-01-27 14:30:56
That's a change that mimics the wallet behaviour in Bitcoin Core. See rationale there.
@_date: 2018-11-11 23:03:20
but the inverse of 2% is 5000%..
@_date: 2019-09-24 20:10:04


Well even in that case, as the pcp depends on the ctn, so Alice would have to bruteforce the ctn (commitment number). She cannot read it out from the sequence number + locktime as for that she would need both her and Bob's payment_basepoint.


Well, yes, in theory maybe. In practice this assumes that (1) ACINQ keeps state for closed channels at least for months, and (2) they would actually help OP manually (which is not really practical, maybe if the channel had a really large capacity).
@_date: 2019-09-24 19:24:40
Alice and Bob have a channel. Alice's commitment transactions all use Alice's per_commitment_points, Bob's ctxs all use Bob's pcps. The remotekey as you correctly said is derived from the remote basepoint. 
pubkey = basepoint + SHA256(per_commitment_point || basepoint) * G
Bob broadcasts his latest ctx hence unilaterally closing. The to_remote output in the ctx pays to a p2wpkh script where the pubkey is derived from Alice's payment_basepoint and Bob's current (ctn-dependent) per_commitment_point.
How do you propose that Alice should figure out what Bob's latest per_commitment_point is?
EDIT: this is the very reason option_static_remotekey is being proposed.
@_date: 2019-09-15 23:57:19
Note that there is an error on the last line. the witness program for a p2wpkh script consists of a 0x00 byte, then a 0x14 byte, and then the 20 byte pubkeyhash. The 0x14 byte signals the length of the data push (that the following item is 20 bytes). This item and the item two lines above (where the 0x14 byte does appear) are logically the same; they are the same witness program.
@_date: 2018-07-04 22:52:51
Note that there is an Android app for Electrum.
@_date: 2019-09-22 03:29:17
That only works up to a certain point. There aren't that many reputable banks.
@_date: 2018-07-01 16:51:46
Change the fee estimation method to "ETA" or "mempool".
@_date: 2018-07-07 14:50:33




Not necessarily. You could imagine an exchange batch-opening 50 channels in a single transaction for 50 users.
@_date: 2018-07-31 12:11:56
Last time I checked, it was not compatible with the BOLTs though.
@_date: 2018-07-01 01:46:19
With the revealer, having access to one half does not give you any information. It is a one time pad.
@_date: 2019-09-24 11:58:41


No. You are assuming option\_static\_remotekey, an experimental, not yet merged feature in the spec. Or you are just misunderstanding the spec.
@_date: 2019-09-24 19:35:34
Maybe you should have read the key derivation section in the relevant BOLT before starting this discussion.
It explains the original motivation.
With option\_static\_remotekey, what you said will be possible.
@_date: 2018-07-01 01:47:56
Indeed. Electrum has many options. E.g. you can connect to your own full node from even the Android app, and the sync is fast.
@_date: 2018-07-07 22:03:58


No. The exchange can splice-out from its existing channels to open all the 50 new ones.
Who said the exchange would be a custodian of your lightning funds?
This whole topic is about futuristic problems and futuristic solutions. There could be a protocol that allows your LN node talk to an exchange and another LN node at the same time, and the exchange would fund your channel, but all the LN keys would be only known to you; e.g. the multisig key that unlocks the funding txout would not be known to the exchange.
@_date: 2019-09-15 23:50:47
Note: this is specifically BIP39 + BIP32 + BIP44/49/84
@_date: 2018-07-30 07:22:44
If enough nodes and miners are enforcing a certain rule, you can rely on that rule. That's why it's ok that some nodes might not be enforcing segwit: it's ok because most of them are. This is how soft forks work, and why BIP9 (and BIP8) exists.
That said, if you are serious and need to validate high value transactions, you run a recent version of Bitcoin Core.
@_date: 2018-07-01 16:51:18
It's a joke :P
@_date: 2019-09-17 17:49:16
You can recover the public key from the ecdsa signature. That is how this has always worked.
@_date: 2018-07-29 15:21:32
You need to verify channel announcements to mitigate a potential DOS attack anyway. You verify it by checking if the funding outpoint exists (and potentially that it is still unspent). While doing this, you can just read out the capacity from the transaction.
@_date: 2019-09-17 15:56:40
Re the Electrum part, it's [detailed in the FAQ](
@_date: 2019-09-21 12:53:29
No, it's not that simple. To reclaim the to\_remote output of "their" commitment transaction, you would need their last commitment point; seed words are NOT enough. This is why option\_dataloss\_protect was introduced, and this is why option\_static\_remotekey is being introduced too, soon. If the remote node already force-closed the channel, and if they also deleted their past state regarding the already closed channel, the coins are most likely lost.
@_date: 2018-04-06 07:45:17
Having the UTXO set is enough, but newly started nodes could no longer derive it trustlessly by themselves. Who would you trust to give your newly started full node the UTXO set? Don't trust, verify.
@_date: 2019-05-29 13:24:56


@_date: 2019-05-09 01:20:33
Well, except not, [as was shown with Segwit2x.](










@_date: 2018-12-28 21:55:18
Try with a different server.
Otherwise, it seems the transaction you are trying to broadcast is creating dust outputs. These are tiny amounts (usually below 546 satoshi) and are disallowed on the Bitcoin p2p policy layer. Not much to do with Electrum.
EDIT: A common scenario for this is when casual users mix up units/denominations. e.g. application is set to mBTC and you type in BTC amount (and then actual amount in tx output becomes too small).
@_date: 2019-05-27 00:03:19
Why will it get better with Taproot?
It's a PITA to do the interactive multi-round signing of MuSig; at least manually. I expect most people who store their own personal coins in a multisig will not do it; they will keep using OP\_CHECKMULTISIG (or the Taproot equivalent, OP\_CHECKSIGADD). Perhaps if a streamlined automated coordinator of the interactive signing gets implemented, then... Otherwise only Lightning and similar automated protocols will use MuSig.
@_date: 2019-05-03 12:46:00




This has been available with Electrum since beginning of 2015.
@_date: 2018-12-18 22:35:12


The devil is in the details. The address space of phone numbers is extremely small in cryptographic terms. What are you doing to make creating rainbow tables difficult as those would make your hashing meaningless? This is why you should open source the code.
@_date: 2019-05-24 02:12:50


You can also use passphrases with electrum seeds.
@_date: 2019-05-29 00:48:54
Maybe they use the application-specific private storage that is invisible to users? Would make sense.
 [
@_date: 2019-05-07 00:34:55
Why are you so sure? Are you willing to bet?
@_date: 2019-05-10 03:03:51


Except this post was made on 2017-05-09, when the price was around 1750 USD.
It was never again that cheap after that date.
@_date: 2018-12-27 13:50:29
The error message is trying to trick users to install malware. If you always verify GPG signatures, you will not install that random binary as it is not signed by the usual people.
@_date: 2018-12-28 21:57:54
No. Please don't spread incorrect information. The issue is detailed at 
If you happened to connect to malicious servers, when broadcasting a transaction, you were shown a "phishing" message basically. That does not compromise you in any way. If you follow the link in the message, just like anywhere on the internet, you can compromise yourself however.
@_date: 2018-12-28 21:58:55


No such thing as "Electrum is down". Nothing depends on anything central. Nothing. There is no central server whatsoever. The servers are run by volunteers; anyone can run one, including you.
@_date: 2019-05-19 03:38:26


It's not free though.
@_date: 2018-12-02 03:21:10




BIP70 provides authentication. If you save the invoice (which e.g. Electrum does), you will have proof that the SSL certificate have in fact signed requesting a payment to that particular address, and along with the blockchain you will be able to claim to have paid that invoice. This protects the user from the merchant/service provider tricking them. That part is certainly not security theater. Unfortunately, SSL certificates seem to be the most practical thing we have to link keys to real identities for now. In some jurisdictions, this link is actually enforceable.
@_date: 2018-12-27 13:53:25
Yes. The error message is trying to get you run something that is not Electrum but looks like it. If you do use the real Electrum, your coins are not at risk. If you get the error, just ignore it, and connect to a different server. Here's a list of probably ok servers: 
@_date: 2019-05-17 13:44:16




Don't. Do more research. A lot more. You don't have a good enough understanding to implement a wallet.
@_date: 2018-12-28 00:07:49
Decentralisation. If only the devs ran servers, there could be downtimes. Also, servers learn your addresses and can link them together and to your IP. If only the devs ran servers, regulators could force AML/KYC shit on them.
It's a network of federated servers where anyone can run servers. If the protocol was designed such that servers could not do anything harmful, then this architecture would be great. Clearly this particular part of the protocol needs to be improved.
@_date: 2018-12-28 21:55:55
Please elaborate. I am using it without issues right now.
@_date: 2019-05-21 03:12:28
I am looking at the first diagram, and see the words "2FA"; but however I look at it, his phone number was a \*single\* factor that was enough to take over the email account?
@_date: 2019-05-19 23:49:45


jeez,  I wonder what wallet existed in 2009
@_date: 2019-05-26 15:19:23
There are actually at least 4 things to know when restoring from a BIP39 seed:
- the BIP39 mnemonic itself
- passphrase / seed extension (if you have used one)
- derivation path
- script type (legacy/segwit/... or even some custom complex script)
If you use an Electrum seed OTOH, the derivation path and the script type are properties of the seed itself that follow from the embedded version number, so you only need
- the electrum seed
- passphrase / seed extension (if you have used one)