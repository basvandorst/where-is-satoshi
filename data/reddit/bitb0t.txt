@_author: bitb0t
@_date: 2014-02-14 07:06:04
Thanks for the link, that was an interesting read. I don't think it directly solves my problem though, because I want the only interaction to generate the wallet to be through the app (I'm ok with verification happening outside the app). If I were going through the trouble to generate the bip38 intermediate value, I might as well just generate the whole wallet.
Maybe I could use it in a slightly different way though:
* The user enters a passphrase (I'm ignoring the whole lot / series issue for now) for the bip38 protocol into the app
* The app internally generates a wallet following the steps of the bip38 protocol, except that the app is both the "owner" and the "printer". The app now knows the private key as well as the passphrase (it has everything)
* The app outputs the confirmation code and public key
* The user (optionally) takes these two things and enters them along with his passphrase into a trusted (offline) computer which can verify that the public key actually came from the passphrase
This would prove that the app actually generated a real wallet based on the passphrase, and if the passphrase is unique, it would guarantee that only the app and (maybe) the trusted offline computer know the private key. This of course assumes that the app hasn't transmitted the private key, but that seems easier to monitor for.
@_date: 2014-02-14 07:22:20
I must have misunderstood the bip38 scheme then. My understanding was that the "owner" (the guy who generates the passphrase) can verify that the "printer" (the guy who creates the encrypted private key and public key) used his passphrase with the [confirmation code](
This would mean that the app couldn't use a pre-generated key, because it wouldn't verify with my passphrase (that the app-maker couldn't have known when they published the app) when I checked the confirmation on my other computer. Am I missing something?
@_date: 2014-02-14 06:11:55
Immediately after posting this I got the following idea, let me know if you think this works:
* The app has a unique id unique to that installation (e.g. a vendor-id for iOS, or a random UUID generated by the app the first time it runs)
* I type a passphrase into the app. The app then uses its unique id and my passphrase to generate a seed for a private key
* The app shows me the unique id it used
* I could then use the passphrase, unique id, and published algorithm, and go to my own (offline) computer and re-generate the wallet, and verify that the wallet addresses match
This sort of defeats the entire purpose of the app though, because if I were going to generate a wallet on my own machine, I could just use that. This also has the advantage / disadvantage that if the phone is lost or destroyed, I could re-create the private key (assuming I wrote down the unique id from the app), and recover my coins
@_date: 2014-02-14 07:27:24


Sure, but assuming I choose a secure password, this seems infeasible.
As for the network issue, it might be true that the average user wouldn't know how to block internet access, but it would be really obvious to anyone snooping traffic that the app is sending up data. More specifically, the app could be designed in a way that all data it sends is according to a published API. Then you could monitor traffic and verify that the app isn't sending up anything outside the published API.
My goal here is that the average user can use the app, and experts can do a decent job verifying that the app isn't doing anything bad. I'm claiming that verifying network traffic is a lot easier than reverse engineering the whole app to try to see how the keys are generated.
Either way, I came up with an idea I think might be better in response to 's post