@_author: hakase_shinonome
@_date: 2018-01-22 06:20:46
[You should link to the source...](
@_date: 2018-01-22 06:55:47
Though in an Objectivist society, you'd have to put a quarter in a machine every time you thought about Objectivism. :P
@_date: 2017-12-26 00:05:50
* Deep learning isn't powerful enough for that. It's more like advanced pattern recognition, sometimes approaching a level of "intelligence" reminiscent of animal instinct. It can't make real plans. When deep learning AIs do things like playing chess, they are making moves which *feel good* to them based on their past experiences, not actually thinking ahead. Also, machine learning was far less developed in 2008.
* Bitcoin's hashrate cannot be used for computation.
* Bitcoin 0.1 was written in good, modern (as of 2008) C++, which is inherently free of the more typical security flaws. There *were* several deeper security flaws in the first versions, though, including a flaw which allowed stealing anyone's BTC.
@_date: 2017-12-25 23:41:45
A fork after Segwit activation with Segwit removed from the code would leave all Segwit outputs unprotected and spendable by anyone. I don't know why anyone would use such a fork, though.
@_date: 2017-02-15 05:55:57


It does, though quantum attacks aren't yet a real threat.
@_date: 2017-02-23 07:05:53
It's an extensible protocol first defined in BIP 21, which also defines some basic parameters. Additional parameters are defined by other BIPs such as BIP 72 (Bitcoin Payment Protocol). Wallets can choose to implement or not implement whichever parameters they want; unless a parameter starts with "req-", it's allowed to be ignored.
@_date: 2017-02-19 08:01:28
SegWit is not an off-chain system, so there is no settlement. Every SegWit transaction appears in a Bitcoin block, even from the perspective of old nodes which don't support SegWit. SegWit increases the max block size by essentially replacing a big chunk of data in SegWit transactions with a pointer to the same data elsewhere. For SegWit nodes, blocks simply become bigger and are rearranged. For old nodes, everyone else starts sending weird small transactions, creating space for other transactions.
@_date: 2017-02-19 08:14:07
Yes, SegWit is a max block size increase, with all associated costs and benefits.
@_date: 2019-03-07 00:46:25
Both your lightning wallet and theirs should know the full witness script. It's timelocked with CSV. To actually *spend* the output will also require private data from your lightning wallet.
@_date: 2017-03-04 23:49:30


Wrong. UASF does not attempt to count nodes. Reread the proposal.
@_date: 2017-03-31 07:34:43
Interesting. Is there theory behind this? For example, was this generated by treating the standard SVG as a series of steps?
@_date: 2017-03-04 23:51:24
CLTV and CSV are already live.
@_date: 2019-03-06 05:38:37


That's BIP 68. Transaction locktimes aren't limited in that way. Your transaction was unlocked in 1987.
The last 3 bytes of each of the locktime and the sequence number encode the [lightning obscured commitment number]( This is purely for finding transactions easier, and has no effect on transaction validity.
When the UTXO will be spendable depends on the output's witness script, but that's not visible to us while it's unspent.
@_date: 2017-01-20 05:26:41
[November 15, 2017](
@_date: 2017-01-23 06:39:38
AFAIK there's no standard server software for it. You just have to implement it yourself according to the specification I linked. It's not all that complex.
@_date: 2017-08-30 10:06:42
The first output is a BitStamp deposit, so I would guess that this person imported his old private keys into a multisig wallet before sending 1000 BTC to BitStamp, and the 2000 BTC output is multisig change.
@_date: 2017-01-23 05:28:52
You can't. For that, use the [payment protocol]( The client will then also directly send your server the transaction, so you'll know for sure when the transaction is sent.
Do **not** put a time limit on transactions *confirming*. Bitcoin block generation is random, and it is not all that unlikely that *no* transactions get confirmed for more than an hour. If you require transactions to confirm quickly, then you should reject and refund transactions with a fee below a required level that you state in advance to senders, or add additional fee with CPFP.
@_date: 2016-12-15 06:28:44
The section you linked to is about scalar-scalar multiplication, ie. multiplying two normal numbers together. Finding a public key is done by multiplying a generator *point* G by a scalar private key k.
How a point-by-scalar multiplication is done is non-obvious; you don't, for example, just multiply the x and y coordinates of the point by the scalar. G\*k is defined to be equal to G + G + ... + G, with k total points added together. The operation of adding two points together is also non-obvious, and is done by drawing a straight line between the two points, finding where on the curve this line intersects other than these two points (there's always exactly one on elliptic curves except for at a finite number of special points), and then the final result of the addition is this point reflected across the curve's axis of symmetry. When adding two identical points together, you can't draw a line between the two points, so you take the tangent line of the curve at that point instead.
There are nice, fairly efficient algorithms for the above higher-level definitions, which you can find later on in the page you linked.
@_date: 2016-12-15 06:39:08


You're thinking of *p*. secp256k1's generator is a random number.
@_date: 2017-04-24 01:45:25
The overt version can also be blocked via softfork. Greg Maxwell [said](




@_date: 2017-04-24 01:52:13




Both could be blocked in a single softfork. See Greg's post for his reasoning behind only blocking the covert form.
@_date: 2017-04-15 03:46:11
Agreed, it looks like Teredo tunneling. But does that mean that Windows 10 relays IPv6 traffic via Microsoft's Teredo relays by default? That would be a big privacy issue.
@_date: 2018-11-29 03:59:19
Breaking any of today's crypto is a problem in NP, so if you can transform any NP problem to a P problem, then secure crypto may be fundamentally impossible, though there would be some small hope in things like quantum cryptography. However, a proof of P=NP might not come with an algorithm for actually *transforming* NP problems to P problems, even if you know for sure that it's possible. Furthermore, P is probably *not* actually equal to NP.
People commonly misunderstand the relationship between quantum computers and P/NP. Quantum computers can efficiently solve problems in the complexity class BQP. BQP contains P and intersects with at least part of NP, but otherwise its relationship to NP and P are unknown. It is possible that BQP=P, in which case quantum computers are actually useless. It is also possible that BQP=NP, in which case quantum computers could kill all crypto, though there is no actual evidence of this. All that is currently known is that quantum computers would kill all currently-used public-key-crypto, but not other crypto. We already have replacements ready for everything that quantum computers are known to break.
@_date: 2018-11-29 04:27:31
If P=NP, then quantum cryptography would only be secure if BQP≠NP≠QMA. If P=NP and BQP=QMA, then you'd have to find the difficulty asymmetry necessary for crypto somewhere else, but I don't know of any plausible options. There might not be any.
Quantum computers may always be very big and expensive, since they require temperatures near absolute zero. Usage by end-users of quantum cryptographic algorithms is unlikely. It's also not necessary to use a quantum computer to protect against quantum attacks; there's quantum-safe crypto on classical computers.
@_date: 2017-10-22 23:34:07
That's a good illustration of just how large the Bitcoin keyspace is. If there was one 3x3m square per P2PKH address, then you'd need 10 million billion billion billion Earths to fit them all. It'd require 11 words with what3words' 40k-word dictionary.