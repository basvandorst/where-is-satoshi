@_author: dryja
@_date: 2016-08-15 15:41:39
Thanks Rusty! I should say that this work is still preliminary and there's lots of good ideas from yourself, roasbeef, and Joseph on how to set this up.
The goal I think would be for all the outsourced channel data to be freely transferable to any number of observers, without the knowledge of the channel participant.
So if you send the pre-signed data to observer A, she might share it with observers B and C.  You don't even know how many nodes are watching your back, and you don't care because the data doesn't identify you or what you're doing with your bitcoin in the channel.
I think this is a good model because all it takes is one nice person to thwart an attack.  So any good Samaritans who want to run a full node and have terabytes of storage, you can set up to observe *every* channel and protect everyone using LN from fraud. In practice that wouldn't actually work because the channel is so anonymous that you can't tell if it even exists, so people would spam you billions of made-up channels states. (Oh well) Still, increasing the number of observers increases safety, making fraud very unlikely. (Making it very unlikely any of the data will ever be actually used!)
That said, there are still ways information can leak out.  Timing, observing network traffic, things like that which are hard problems in many anonymous systems.  But it should certainly be private enough that you can ask your friends to monitor your channels without them learning how much money you have, or where your money is coming from / going.
And if you don't want to trust / reveal anything to anyone, run your own full node and don't turn it off.  Which you're doing anyway, right? :)
@_date: 2016-08-16 17:53:24
Transaction fees are denominated in satoshis, not USD; if you opened a channel with 1 BTC and the value of 1 BTC rose in USD terms, the fee may also rise in USD terms but not in BTC terms.
Looking only at USD, here's what it would take for $1K/close tx fees:
A close tx is around 300 bytes, so approximately $3/byte for block inclusion.  With segwit, there's around 2M bytes / block, so each block has total transaction fees of about $6M, which is before any coinbase subsidy.
144 blocks/day is $864M / day in fees, or about $315 billion per year in transaction fees.
This is higher than total annual revenue for all credit card companies (which also extend credit!) and all other payment processing industries.  So in this scenario either 1000 USD isn't worth that much and the fees are reasonable in BTC terms (or in 2016 USD terms), or Bitcoin has taken over the world and become the de-facto single global currency.
Seems quite unlikely, but if this happens I don't think people on r/bitcoin will complain.
Scale it down to $100 per close tx and the conclusions don't change too much; fee revenue in the tens of billions of USD per year, which is on the order of a major credit card company.
On a technical level, fees in USD are likely to be much more volatile than fees in BTC.  The USD/BTC price goes all over the place for whatever reasons, which changes the USD fee price even if the BTC price is static.  But changing the fee in BTC terms is the only thing that matters for LN channels.  The only thing that can increase fees in BTC terms is an increased demand for BTC velocity.... except it's not even that.  Fees are per byte, not per BTC sent, so there's lots of room to consolidate payments and move more BTC in fewer bytes.
Right now I'd say fees are mostly being paid by people who don't care, and would rather spend a couple extra dollars than re-write or update their code.  If you look at blocks, there's still a lot of junk, like uncompressed pubkeys, chained txouts being spent dozens of times in the same block, and so on.  This is rational though: if I'm spending an extra $1 a day in fees, I'm not going to bother re-programming software to cut that down to $0.10/day, because it's going to be hours of effort to program, at a value of hundreds of dollars.  If fees go higher though, people will remove those inefficiencies.
My guess is that we'll see channels where the fee to open is well under 1/1000th of the channel value.  Could the USD denominated fee to close go up 100X from that?  Sure, I've seen BTC/USD go up 100X.  Channel might cost $10 to close, which would be forgotten by the user whose channel is worth 100X more in USD terms.  Could BTC denominated fees increase 100X during the time the channel is open, without any change in BTC/USD?  I can't think of any realistic way that would happen.
Fees don't usually go up much in BTC terms and probably won't.  Similar to how if you have some bitcoins now, you'll always be able to spend them -- If you have a channel open today, you'll be able to close it tomorrow.
@_date: 2016-08-17 01:41:42
Sure, 20GB blocks would result in tx fees that everyone can afford.  But then nobody could afford to verify the integrity of the system.  So basically the same as dollars... low fees, totally opaque.  So why not just use dollars then?
I've never quite understood why people seem so against a theoretical scenario where bitcoin sortof "takes over the world" but only wealthy people directly interact with bitcoin.  (The "good delivery bar" scenario.)  If that happens, all the hodlers here end up in that group who still get to use bitcoin, and can buy a bunch of yachts and stuff as well.
I agree that it's somewhat disappointing if it "just" replaces SDRs / good delivery bars, which is why I'm working on LN.  I certainly wouldn't complain if that happened though.  
"Ugh, bitcoin sucks.  I can buy a house with half a coin, sure, and I have bought several, but what about all the people in Indonesia who can't afford tx fees??  Useless!"
Maybe people who want 20GB blocks are super altruistic, and unconcerned with personal gains..?
@_date: 2016-04-19 04:15:49
I don't think you can ever actually get to 4MB.  These blocks (I made them) are all 3768776 bytes.  "Strippedsize" (what non-segwit aware nodes will see) is 73167 bytes.  So you can get close to 4MB but can't actually get there.
These blocks are actually very quick to validate though, as they don't have any signatures in them!
Maybe I can do some pathological multisig or something later to see how that fares.
@_date: 2016-04-24 21:08:25
The HTLCs "happen" in that they are signed, sent over the network,  verified, saved to disks and so on.  But they very rarely will end up broadcast to the network, or in a block.
The most likely cause of broadcasting channel states containing HTLCs is that nodes losing connectivity / disappearing.
@_date: 2016-04-19 06:43:39
These transactions are just to test mining and propagation.  They're full of transactions that will never be used on mainnet.  There's no public keys or signatures.  The script is 6d6d6d6d6d6d6d6d51, which is 8 OP_2DROPs and then OP_1.  
So you can put 16 data pushes and the stack will evaluate to true.  I put 16x256 bytes, getting about 4KB per transaction.
There are some previous blocks with with lots of 1-in 1-out P2WPKH transactions, and you end up with around 1.7MB.  There are also some giant transactions which push block size up to near 2MB.  Those would be non-standard and not relayed on mainnet; I was testing the new signature hashing which scales much better.  (a 12K txin transaction would probably take minutes to verify without segwit)
My take from playing around with segnet a bit is that if most people use segwit it'll probably be something like 1.7MB blocks in practice.  If people use more multisig P2WSH it might get closer to 2MB.
From a technical viewpoint, the size increase part is not an interesting / important aspect of the segwit changes.  For what I'm working on, I mainly care about txids not changing, which seems to work!
Also Schnorr sigs later on would be very cool.  LN channel outpoints would look the same as single key P2WPKH.  Multisig at zero size increase.  And spending dozens of outpoints, from different users, all with one sig.  And implied pubkeys.  Neat stuff.
@_date: 2016-08-17 05:57:45


You guys?  I wasn't aware I was on a team.
But yeah, being able to run bitcoin and not trust others is pretty much the whole point.  If that precludes some use cases, or a portion of humanity from using it, oh well.  Maybe there are ways to extend bitcoin use cases without changing it; that's what I've been working on.  Not sure about the other guys.


Who's we?  A different team than the you guys?
I don't get the connection between the rich and hipsters.  If bitcoin is for the rich, that means people with bitcoin are rich, right.  And people who don't have it aren't.  That doesn't make it a plaything though, quite the opposite.
It doesn't seem like bitcoin is going to flatten the pareto curve of wealth distribution on this planet.  Bitcoin wasn't designed as an altruistic system.  
If you can convince the rich, who hold bitcoin, that switching from bitcoin to 20Gigcoin will make them richer, they might do it.  If the incentives don't line up though, they won't jump ship.  And the rich generally get to call the shots -- one of the perks of being rich.
I'm not making value judgments here, about "good" or "bad", and I'm not rich myself.  But this is how things work.  LN allows more people to use bitcoin.  That's why I'm working on it.  So am I in the altruistic "we" or the obstinate "you guys"?
@_date: 2016-04-14 10:51:48
This is not an issue with LN.  The customer has mathematical proof of payment, signed by the merchant.  The merchant may then deliver damaged goods, refuse to deliver goods, throw tomatoes at the customer or whatever.  The same can be done with any payment system.
LN is just about moving coins around, it does not include a marketplace with ratings, which is a separate system.
Yes, LN assumes the hash functions work properly, and breaks if the hash functions break.  It also breaks if ECDSA breaks, P=NP, etc.
@_date: 2016-04-24 21:05:02
You can broadcast old, invalid channel states, but it's a bad idea.  When your counterparty sees that state, they use the revocation preimage that you gave them when you revoked your claim on that state, and take all the money.
So the risk of broadcasting an old state is that with very high probability (0.999...) you lose all your money.
But when you don't *have* any money in the channel, there's no risk, and even if it's a longshot, you might get a bit more by being a jerk and broadcasting a state you revoked your claim on.
@_date: 2016-04-14 09:27:32
First, in the current implementation we're working on, channels don't expire.  They can stay open indefinitely.
The main way to "fix" this though is actually social, not technical.  Dave releasing R means Dave got paid.  Maybe he didn't, and released R before he got the money.  But that's not Alice's problem.  If Alice knows R, that means Dave owes Alice the product.  Those are the rules.
Proper software will only release R when payment has been received.  If you wrote a version which releases R before that, you're basically giving money to Carol.
It's equivalent on-chain to Dave posting an address, receiving funds, then before the tx is confirmed broadcasting the private key in an OP_RETURN, and then claiming to Alice he never got paid.  No, he did, he just discarded the payment afterwards.  Alice can show the txid proving she paid Dave.  In fact LN is a little better in that the sender has a signed message from the receiver concerning the payment.
TLDR: Knowledge of R = proof of payment. 
@_date: 2016-04-06 01:22:34
When outsourcing the enforcement of channel state, the 3rd party that you outsource to doesn't gain the ability to close the channel.  
A rogue enforcer could still be dangerous though -- if you rely on them exclusively (without checking using hardware and software you control) and they conspire with your channel counter-party, then a previous, invalid state could be successfully broadcast.
(PS thanks for the great LN explanations!)
@_date: 2016-04-15 17:41:11
LN channels can be created with compatible altcoins.  The current software we're writing uses OP_CSV and segregated witness, which are probably not in many other coins yet, but might get ported over.  (I'm not familiar with the altcoin scene; do BIPs from Bitcoin usually get ported over quickly?)
One node can have channels open in multiple coins, and route payments between coins, potentially without sending and receiving parties being aware of this.  For example, Alice wants to pay Dave 1 BTC.  The payment ends up being:
    Alice -&gt; Bob: 1 bitcoin
    Bob -&gt; Carol: 5,000 namecoins
    Carol -&gt; Dave: 1 bitcoin
This is possible because Bob and Carol have both set exchange rates they're willing to exchange between coins at in their software.
@_date: 2016-04-19 16:54:23
All the above statements are incorrect and / or incoherent.
* LN transactions do not need large signatures.  Here's one:  2-of-2 multisig, 302 bytes.
* Everyone has access to develop bitcoin code.  It's open source.  I'm not aware of any of the people building LN software pushing code to bitcoind, but roasbeef and I have pushed code to btcd that's segwit related.
* LN developers don't pay any tx fees, LN users would.
* Many / most developers do not think that a decrease in transaction costs is important.  That's why they're unconvinced about the urgent need to raise the block size.
@_date: 2016-04-25 03:29:48
Yes, having 99.99% of the funds in the channel is also not a great situation; if the other party thinks they can succeed with a probability of 0.001 and the gain is sufficient, they might try to attack.  There's also another, more practical reason to try to keep channels well-balanced: if all the funds are on one side, the channel can only route payments in one direction.
Someone needs to be vigilant while the channel is open.  If you're going away for a week and won't be using bitcoin, you can close your channel and open it back up when you get back.  If you don't want to watch the blockchain yourself, you can create and sign the auto-confiscate transaction and send it to another user or friend who can monitor the blockchain and broadcast it for you.  You can trust others to do it for you, or run a node and do it yourself.  Or even better, do both!  
That way if the attacker tries to segment your node off the network so you don't see the transaction, or DDoS you so your internet is down, your friends node still sees it and sweeps the funds for you.
@_date: 2016-04-19 06:52:07
Right, but the way it's calculated is with "vsize", and due to the fact that there will always be *some* non-witness data in a block, you can't quite get to 4M.
Can coinbase txs only have one txin?  I think so.  And txin[0] must have only 1 item on the witness stack.  So the coinbase tx can't have much witness data; you'd have to put it in a transaction.
So right there you've got a 100-ish byte coinbase tx, most of which is non-witness.  That plus another transaction with ~20 bytes overhead means you could maybe get to 3999000 bytes or so.
It's kind of academic, sortof like how you never actually get to 21M bitcoins :)
@_date: 2017-12-13 13:04:01
2MB blocks are quite possible today on the Bitcoin network.  A 1.6MB block was mined recently. (Block height 493182)
@_date: 2017-12-28 23:42:55
Off topic for this subreddit, but I've looked at iota quite a bit, and it scales much worse than bitcoin does.  You still need to store a UTXO set and download every transaction, but in iota the transactions and signatures are huge!  
They're not using bytes, so that's an efficiency loss right there for any software or hardware using binary.  Which is all existing software and hardware in the world.  And other worlds, as space probes also use binary.
Also they're using hash based signatures, which are huge (couple KB) and reveal your private key if you sign more than once with the same key.  Which is something the wallet software is happy to do.
It really seems like the whole iota thing is a troll currency where they intentionally see how ridiculously bad they can make it before people wise up to the joke.  I mean... "infinitely scalable"?  Are you in on the joke as well?
@_date: 2017-12-13 13:00:07
Nitpick on 5:
Transactions all confirm immediately; the script itself uses OP_CHECKSEQUENCEVERIFY so that you can't spend the closing transactions output for a number of blocks.  Similar idea but does not in fact use the locktime field in the transaction.
@_date: 2017-12-13 12:55:35
Possible nit-pick but it's not that the closing transaction is valid after some time -- in fact it is valid immediately.  What takes some time is that if you unilaterally close with that transaction, your side of the funds is locked for some period of time, to give your counterparty a chance to call foul on your close transaction.
(Maybe you closed with an old state where you had more money than you currently do.  Of course you wouldn't do that, but just in case...)
@_date: 2017-12-11 21:47:17
Why would the sat/B fee rate decrease with higher USD prices?  If anything I would expect it to increase, as higher USD prices imply wider usage and more demand for transaction space.
(P.S. If you want to free up some space, maybe ask Gemini to stop using uncompressed pubkeys... that's just weird :) )
@_date: 2017-12-19 01:31:20
The problem is actually quite a bit easier in that there can never be more channels than there are UTXOs, so the total space needed to store the entire graph is a constant factor times the size of the utxo set.  In practice the extra data is about the same size as storing utxos, maybe a little more.
So if you have 2X the space to run a (pruned) full node, you have enough space to store the full LN graph.
@_date: 2017-12-24 16:01:59
[lit]( works without any full node at all.
(It will not connect to a pruned full node, however, as pruned nodes can't serve old blocks)
@_date: 2017-12-24 16:07:22
Yes, there are several reasons why you want the payments to be much smaller than the capacity of the channel.  
I think updating the heap won't be too bad, as the graph only changes once every 10 minutes or so, when transactions are confirmed. 
When you open a channel and want to tell everyone about it, in that case yes you need to broadcast it.  When you close a channel, you don't have to do anything, because everyone on the bitcoin network can see that the channel has closed (that txout has been spent).
It's hard to say what range of payment sizes LN will be most useful for, but certainly not for the largest payments.  A recent talk at scaling bitcoin had modelling of the network, which had the interesting property that most *transactions* happened on LN, while most of the *value* sent was with normal bitcoin transactions.  This seems like a pretty good guess as to how it will play out.
@_date: 2017-12-24 15:58:38
My lightning software, [lit]( doesn't depend on having your own full node -- it automatically connects to full nodes on the network.
There is also preliminary support for "powless" SPV, which does limited SPV header verification.  Help on all this is of course welcome! (Though I may not work on it much during the end-of-year holidays)
@_date: 2017-12-13 12:57:37
I don't like the term "IOU" for LN because there's is no "owing"; no party has any obligations or debt, and either party can disappear at any time.  The bitcoin received in LN channels isn't owed to you; you can spend it unilaterally, you just have to go through an extra transaction that you otherwise would with a standard p2pkh utxo.
@_date: 2017-12-13 13:06:24
If the only channel the parties have is with each other, then it's illiquid in the context of the broader network, but much more liquid between each other, as they can send to each other rapidly with no fees and no confirmation times.  So that's a trade-off.
With a well-connected network, the funds in the channel may be more easily and cheaply moved than funds in a p2pkh utxo.
@_date: 2017-12-22 01:56:42
You can run Dijikstra's on the unwieghted graph with time O(E + VlogV).  If a payment is not significantly smaller than the channel capacity, you can first remove that channel from the graph before pathfinding.  With that it'll scale decently well to the size of the full utxo set, which is currently around 61M.
@_date: 2017-12-13 14:27:52
Sure; also in most cases, there's only 1 "closing transaction".  The OP_CSV output which you can only spend after a delay doesn't *need* to be spent immediately once the time has past.  So in the LN wallet I'm working on, those utxos aren't swept or anything, they're just stored in the wallet and can be used along with all other utxos to make transactions.
@_date: 2017-12-28 02:00:44
Also, this metric is "number of transactions", which is probably not the best indicator.  Size-weighted would be a much better metric to look at.
This is similar to [Johoe's mempool chart site]( (which is great!) in that at the top it has # of transactions, which is pretty easy to game, either intentionally or unintentionally: make lots of tiny transactions to show up, or make a few big ones to go under the radar.
\# of transactions is OK for a first approximation, but in cases like this a spike may be due to a completely different explanation: utxo consolidation.  If wallets, like an exchange used a lower fee period to make large, non-segwit transactions with many inputs and few outputs, that would cause the number of non-segwit transactions to be fewer, and the proportion of segwit transactions would go higher.  So this bump may have nothing to do with segwit adoption at all.
(note that I haven't gone through the transaction data to see if this is the case; it's just a guess.  But this is possible when you measure by number of txs!)
@_date: 2015-12-07 03:26:22
Hi, presenter / OP here.
I actually screwed up the numbers for the middle Llvl 2 column; they are actually much closer to Llvl 1 column.  Columns 1 and 3 are right though.  
Thanks to for pointing this out after the talk!
Lesson: Don't make slides at 4AM before the presentation :)
@_date: 2015-12-27 01:56:38
Extrapolating out an exponential curve for 25 years doesn't work.  That kind of prediction is not going to be 20% off; it's going to be off by orders of magnitude.
The [LCS35](  time-locked crypto puzzle at MIT was started in 1999.  Rivest extrapolated out that we'd be running 10GHz+ CPUs by now.  Probably seemed reasonable, even conservative at the time.  Didn't work out though, as CPU clock speeds failed to continue increasing.  It wasn't gradual either; the increase was exponential right up to 3GHz, then completely stopped.
This is mostly just guessing, but I'm personally pretty pessimistic about CPU throughput going forward.  Storage, we've probably got one or two orders of magnitude left, and network bandwidth, from a technical perspective, also seems like we've got a decent amount of headroom.  But we really don't know, and making engineering decisions based on extrapolations of exponential growth is very risky.
@_date: 2017-12-19 05:54:52
Updating the graph is going to be the same problem as updating the utxo set; when an output gets spent, remove that edge on the graph, and when a new channel is created, add it.
@_date: 2018-05-01 13:29:56
Actually it's related to both LN and LND. The original name for lit was LND; I changed it to lit when I left the company.
@_date: 2015-12-26 04:00:00
Please, do not associate yet another pseudo-controversy with LN.  There are already enough people saying that "LN wants 1MB blocks", "Blockstream controls LN", etc etc.  (I say pseudo because I don't understand the controversy over RBF.  Anyone can run whatever policy they want and there's no way to even tell.)
LN does not need Opt-in RBF to be merged into Bitcoin Core to function.  below says that RBF instead hurts LN; I probably wouldn't go that far as I don't think mempool replacement policy is very relevant to how it will function.
Unconfirmed txs can be overwritten at zero cost, and it only takes 1 miner to run RBF, FSS-RBF, RBF-BBQ, or whatever else they code up to completely destroy whatever 0-conf properties one may be accustomed to.  For the average user it may be difficult to successfully double-spend, but for the average miner it's very easy.  This has always been, and will continue to be the case.  Sorry if people have been led to think otherwise but that's how Bitcoin works.
@_date: 2017-02-20 21:00:37
What's good about this comment is that it's not just false, but also falsifiable!
Try syncing up with 0.8, see how it goes.  Then let us know how all the core devs have been spinning their wheels everyday.
@_date: 2017-02-23 19:30:54
I agree with this, and think that exchanges are probably the first big use case.  Hopefully getting rid of the words "deposit" and "withdraw" from everywhere in Bitcoin.
There are some limitations, and it gets more complex as the majority of customer funds on an exchange transition into channels rather than utxos held by the exchange, but I think it could improve security a lot for the people who want it.
@_date: 2017-02-15 15:38:34


Right, but none of these transactions we're watching for have been confirmed.  They haven't even been signed, so we have no idea what the txid could even be. (With segwit, we already know the txid before it's signed.)


The 3rd party can't sign on your behalf.  You have to sign the transaction ("penalty" transaction, or in my code, "justice" transaction :) and send them the signature.  Since you're trying to spend from a tx that has not yet been broadcast, and your input refers to the txid, if the txid changes the signature is no longer valid.


Depends on how long you set the timeout period.  If it's 500 blocks, checking once a day should be safe.  That's also not something the user should have to pick though, and safe defaults should be provided.
@_date: 2017-02-14 15:40:32
Not really.  With a malleability fix (like segwit), OP_CSV works great.
Without segwit, OP_CSV and OP_CLTV do pretty much the same thing.
There is another way to get indefinite channels, but the funding process is real ugly, requiring 2X the coins.
@_date: 2017-02-14 15:50:55
This is an oversimplification bordering on incorrect.  What does "fine" mean?  Nobody has, to my knowledge, programmed any LN code to work around the current malleability problems.  The funding process is much more complex without segwit, with various tradeoffs that it'd be best not to expose to users.
Also, what do you mean by "Bitcoin node"?  Without 3rd party channel monitoring, you still don't need a full node, you can run a lite node, download the full blocks, search through the txids, and discard them.  This is what the 3rd party monitoring [code does now](
Without fixing malleability, 3rd party monitoring doesn't work, but I'd say more importantly channel creation doesn't work well.  Either the channel has a fixed duration, or the recipient of the channel needs to put up an equal amount to the channel amount, which can then be recovered after the channel is confirmed.  
There's a bunch of other problems too.  One of the biggest is that everyone programmed LN code using segwit, because... segwit is a pretty clear improvement.  If it doesn't activate for a while, then sure, there are levels of lightning we are prepared to accept.  But malleability sucks once you're doing anything more complex than regular old transactions.
@_date: 2017-02-23 20:29:27
Thanks-- Sure, I'm on IRC, e-mail, etc.  I admit that documentation could be better, but it's tough because the architecture and spec is still changing so people tend not to work as much on documenting it.
@_date: 2016-01-31 03:01:04
I'm guessing but I think the reduction in nodes is caused by the increase in easy to use SPV or other less-than-full clients.  Many people had no interest in running a full node but ran bitcoin-qt because that's all there was.
It's a tough trade-off between security and ease of use.  What problems users have had with non-full nodes have mostly been to mistakes and not malice (the "SPV mining" of July 2015; unverified signatures accepted on blockchain dot info).  I'm not aware of any attacks involving segmenting off an SPV user and sending them blocks with valid PoW but invalid transactions.
So it makes sense that a full node might seem like security overkill to many people -- why go to all this trouble to prevent attacks, when nobody is going to try to rip me off?  In some cases that may be an acceptable trade-off, just as some people don't bother locking their front door, while others install expensive security systems.  Making the security of running a full node cheaper and easier is another thing we can work on to help this.
In LN, nodes do need to keep track of all previous transaction states, and there are some efficient ways to do that ([if I do say so myself](  :) 
For a node to keep track of previous channel data is really cheap, on the order of a few kilobytes.  If you outsource the transactions which sweep the revoked past states, that does require a decent amount of storage (maybe 100 bytes per state, though I supposed you could send the monitoring node the elkrem receiver and get it down to ~75? about the size of a sig). 
So nodes that monitor the outsourced revocation / sweep transactions have an incentive to be full nodes (they kindof have to; in SPV it's easy to just not tell someone about a tx, and the whole point of the monitoring node is that it monitors everything).  That could maybe increase the number of full nodes a little.
Unfortunately the most likely and direct thing that would make people switch to running full nodes is probably a well publicized event where someone got ripped off because they didn't.
@_date: 2017-02-15 05:58:35
You're right, you could watch the input, but this is not very useful for 2 reasons:
1: The 3rd party doing the monitoring learns what channel they're watching, so they know where your money is and have an idea of how much you have.  With the non-malleable code, the 3rd party can't link the data you give them to any specific channel on the blockchain (unless the fraudulent transaction actually happens)
2: The non-mallable code doesn't just monitor, it actively constructs and broadcasts the transactions to move all the attacker's funds to you (not the 3rd party) without you being online.  With malleability, the best they could do would be to e-mail you or alert you somehow, saying "hey, looks like your channel got closed at an invalid state, better fire up your node and grab that money."  
This really isn't very useful because if you've got the connectivity to check e-mails, you probably also have the connectivity to sift through the blocks* from the last day or so.  Combined with the lack of privacy, 3rd party monitoring with txid malleability to me seems useless to the point where it's not worth coding.
[*] With a malleability fix, you don't actually need the blocks; instead you can download: headers, leaves of the merkle tree, and coinbase tx.  (Coinbase tx just there to prove your getting the txid leaves, not one step up the tree non-txids).  This isn't possible with malleable txids and all txs in the block would need to be downloaded and parsed.
@_date: 2016-03-30 23:15:31
@_date: 2017-02-14 16:04:25
Right; I think Rusty found some attacks that make levels 2 and 3 a lot closer than I thought.  There *are* ways to have indefinite channels with just OP_CSV but it requires a more complex, lengthy funding process where both parties have to put up money.
@_date: 2016-03-25 03:03:37
You don't have to "provide access", they already have it.  It's their server.  They pwn it.  Literally.
@_date: 2016-01-31 08:41:53
Hi dooglus, thanks for the post!  
I think you're right and the n-dimensional chain does on average have fewer hash operations.  Storage is the same on average for the receiver.
Honestly the reason I went with the binary tree is that it seemed  simpler to code and explain to others.  In practice performing SHA256 20 times vs 40 times probably isn't measurable.  Keeping the data structure more like the merkle tree that's already in bitcoin seemed like a good trade-off for that, but I hadn't realized the savings; interesting...
Also thanks for the height calculation function, I will try that out!
@_date: 2017-02-16 02:47:17
No, you don't know the inputs for the penalty transaction before the commitment transaction is signed.
Not sure what you mean by "why" LN uses chains of unconfirmed transactions.  Being able to reliably spend a transaction that doesn't exist is a very powerful tool.  LN uses them in several places, such as when funding a channel (you want to make sure you can get your money back before you send it into the channel) and outsourced penalty transactions (you want someone else to broadcast a pre-signed transaction grabbing an output that doesn't exist and probably never will.)
@_date: 2017-12-19 01:25:01
I'm not being payed by a company; I work at the MIT DCI.  We could definitely use more funding to hire more people.
@_date: 2016-01-17 07:02:09
Compiled, but very quick:
    me time go build
    real	0m0.348s
    user	0m0.380s
    sys	0m0.048s
@_date: 2016-01-30 20:48:14
Concurring with a8r5gh here.  In LN, if you try to broadcast a previous channel state which is no longer valid, you will with extremely high likely-hood lose the entirety of the channel to your counter-party.  The revocation process where you invalidate the old state involves both parties revealing hash pre-images which you can think of as this "weapon".
Segregated witness, or any other reliable malleability fix will allow these revocation transactions to be outsourced, so you don't have to monitor the blockchain for the revoked state.  You can give the sweep transaction to your friends or third party companies and as long as someone notices and sweeps for you you're safe.
Also: one factor that mitigates the issue of many channels closing at once is that the timeout period is between when *you* broadcast the non-cooperative channel close and when *you* can sweep the resulting txout.  So if it seems that blocks are clogged and there is a risk that the timeout may elapse before your sweep tx would be confirmed, you can safely wait until blocks don't look clogged anymore.  It's still a theoretically possible attack / issue but seems more annoying / inconvenient than outright dangerous.
@_date: 2017-03-02 15:07:48
National banknotes often have the word "promise" written on them.  British pounds have a [picture of the queen, and the text "I promise to pay the bearer on demand the sum of __ pounds"]( implying the queen (or the bank? who knows) is promising you something.  
Bitcoin has no queen, and makes no promises.
Core devs can guarantee nothing.
@_date: 2016-01-31 03:03:47
Hah, yeah, "good" or "bad" depends on what you're doing!  
Great for people who want to use it to make cheap payments.  Bad for people who are trying to make a bunch of money off running a node.
@_date: 2016-01-31 02:22:10
LN doesn't directly require or encourage users to run full nodes.  It's still a good idea to run one to protect from getting ripped off.
The best reason to run a full node is so that you know your incoming transactions have been verified in a legitimate block.  If you're not running a full node, you are to some extent relying on (often unreliable, often anonymous) third parties to tell you when you've received coins.
An analogy I've used is that of a pizza shop checking the $20 bills they receive.  They *are* helping out the Federal Reserve, the Secret Service, the U.S. Bureau of Engraving and Printing, and the US economy in general when they spend the few seconds to hold a bill up to the light, mark it with a pen and so on.  It helps, but that's not why they do it.  They do it so they don't get ripped off.
@_date: 2017-03-02 15:55:03
...copy/pasted from [my post]( above.
@_date: 2017-03-13 16:00:09
Ad hominem?  is anonymous; there is no character to attack.
Signatures can be malleated in a number of ways.  (For those interested, I gave [a talk about it](  One way is by [modifying the S value]( of the signature.  The S-value modification can be performed without knowledge of the private signing key, or even knowledge of the message being signed.  Any ECDSA signature can be modified, given just the signature itself.  This modification will change the txid, malleating the transaction.  A full node is not required to perform this operation.
Completely unrelated to malleability: the reason to run a full node is to verify receipt of bitcoin payments without trusting a 3rd party.
@_date: 2017-03-02 13:24:46
Indefinite channels are borderline possible but yeah, not sure how "useful" it would be.
A big problem with dealing with malleability is UI.  You'd end up presenting info to the user and asking them to make decisions they really shouldn't have to.  How long do you want your channel to last? 
(slider bar)
(everyone cranks up the slider bar to the max)
If you give users a choice between security and convenience, or privacy and convenience, users will chose convenience every time.  Because privacy and security are in a way "anti" features, in that when they're working perfectly, nothing happens.
It's frustrating that segwit may not activate, or may take a year or two.  But Bitcoin works the way Bitcoin works.  Not the way I want it to.
[as memed before](
@_date: 2016-01-31 02:37:49
in LN, intermediate nodes can charge a fee to route a payment.  They can forward a bit less than comes in.  The optimal fee schedule on a local and global scale is one where transfers which unbalance channels (lead to a more lopsided channel with one party having more than half the channel allocation) are charged a higher fee than those which help balance a channel.
Users may be able to get some return on their bitcoin by running a well-connected, reliable node and forwarding many payments.  I'd warn that it will likely be a brutally competitive market as barriers to entry are minimal and there is not much to distinguish one node from another besides fee.  Think mining but probably worse because you won't need custom hardware or lots of power, just a computer and some bitcoin.
@_date: 2016-03-30 13:52:33
Yup, there are certainly risks with SPV validation when using LN channels; "fake" channels like you've said, is one risk, but not too dangerous in that you can wait a few confirmations before accepting routable payments through it, and blocks are pretty costly to fake.
A trickier issue is that with LN, not finding out about a transaction can cause you to lose money: when one party tries to close a channel with a revoked previous state.
You need to know about this, and since in most SPV modes you ask nodes to tell you about relevant transactions via a bloom filter instead of downloading all the blocks yourself, nodes could omit sending you that transaction.  This could potentially be cheaper than mining some blocks.  I've added "hard mode SPV" to the LND SPV code which doesn't use remote bloom filters and downloads full blocks (but discards the blocks after parsing them) to mitigate this threat.
For the best security, always run a fullnode.  If you can't, we'll try to figure out ways to keep it safe enough for most uses.
@_date: 2017-03-13 14:47:33


Complete nonsense.  Anyone with the most basic understanding of these terms will immediately recognize this statement to be false.
But this is what's so difficult about online forums!  here is anonymous, and can post misinformation to forums at no cost.  If you're new to these technical terms, the post sounds reasonable, and perhaps even like a good idea.  And everyone starts off new to bitcoin.
Myself, I remember being very confused by the bitcoin wiki in 2012.  Later on I realized that Mike Hearn and Greg Maxwell had been in something of an edit war over the "scalability" page there, so this jockeying over the dialog and information presented to noobs has been going on for a while.
I don't know what the solution is to this type of misinformation.  Reddit style moderation doesn't seem to work terribly well, but this is a popular forum, so we're kindof stuck with it.  Lots of noise though.  Is this all a conspiracy to spread misinformation and undermine bitcoin?  Eh, probably not...
I'd venture a modification to Hanlon's razor for reddit:
Never assign to conspiracy that which is adequately explained by trolling.
@_date: 2016-01-31 03:41:32
We could make our software such that it requires a full node to talk to and only works over json-rpc, but that would limit users who don't want to run a full node.  And someone would probably take our code and make it connect to a single full node somewhere over port 80 or something.
One issue is that you really can't prove you're running a full node.  You personally can verify your computer is running it, but I don't know of any way to make a compact verifiable proof of that.  It seems... hard, to put it mildly.  And not just theoretically, there's [actual software]( out there which pretends to run a full node while writing nothing to disk.
@_date: 2019-03-20 18:45:25
There are some similarities with SPV and client-side filters but important differences.  SPV proofs for non-existent coins can be produced, it just takes mining a (invalid) block.  For utreexo, an attacking bridge node can't produce proofs for non-existent coins even if they mine blocks.
(Hm OK technically they can if they can find hash collisions.  So 2^75 hashes for an invalid SPV proof vs 2^128 hashes for an invalid utreexo proof.  Which might not *seem* like a huge difference (75 is like 60% of 128...?) but actually is.  2^128 is the security parameter for bitcoin so all bets are off if the attacker can do 2^128 of anything.
@_date: 2016-06-10 17:01:56
When creating a channel, the refund transactions spending from the channel outpoint need to be created BEFORE the channel funding transaction is signed and broadcast.
The attack is that due to malleability, you can't reliably spend from an unconfirmed, let alone unbroadcast transaction.  So one of the channel participants could attempt to modify the funding transaction, which invalidates subsequent refund transactions.
The coin in the channel would then be stuck unless both parties co-operated to move it, which could end up being a kind of standoff situation.
The main safety / trustless aspect of LN is that at any time, any user can close all their channels and get all their coin back, without the participation or consent of any other LN user.
There are ways to do the funding tx safely using OP_CLTV, but it's sub-optimal in many ways.  If segwit takes a long time to activate I'll probably change some code to implement the OP_CLTV method though.
@_date: 2016-06-15 22:01:35
Nit to pick:
Saying "the mempool" is inaccurate.  Everyone has a different mempool, and those mempools are of different sizes and have different transactions in them.  If there was a single mempool, we wouldn't need proof of work, mining, blocks... we wouldn't need Bitcoin.
If you run bitcoin, and would like a smaller mempool, you can set it in ~/.bitcoin/bitcoin.conf by adding the line:
Then your mempool will never be more then 2 MB.
If instead you would like a multi-gigabyte mempool, that's also possible by setting maxmempool and minrelaytxfee in the config file, and creating millions of 0 fee transactions.
Sorry if this is a nit-pick but I do think it's important to keep in mind that everyone's mempool is unique, and everyone can have as big or small a mempool as they would like.
@_date: 2016-06-25 04:46:56
I can get lnd running on testnet3, probably this weekend.
I kindof like segnet4 because it's smaller and I have so many of the coins.  I think I'm the only one using it though :)
@_date: 2017-01-21 21:34:14
Thanks!  Glad the explanation helps.
Note that while I did somehow get a t-shirt that says "Bitcoin Core" on it, I've never actually submitted a PR to the github.com/bitcoin/bitcoin repo.  So depending on your definition, (and according to mine) I'm not a Bitcoin Core developer.
(I would like to contribute but am right now focused on lightning)
@_date: 2016-06-26 01:05:17
Hi- I haven't run the latest, merged segwit code so there may be some changes but I doubt it.  Pretty much everything you've said is in there.
It shows the witness field as well as sigscript field.  The wtxid I think is called "hash", right after txid.  If you do getrawtransaction on the coinbase tx, you'll see the witness commitment in the op_return, as well as the witness nonce, which right now is just zeros.
It also tells you a bunch of sizes, which can be a little confusing.  There's "size" which is witness size (size of tx including witness data).  There's "vsize", virtual size, which is the discounted size (non-witness, plus 1/4 witness data), and that's what miners should look at when choosing txs, because block vsize is limited to 1M.
I think there is or was "strippedsize" which is the size minus the witness data but that might have been taken out from the rpc call.
I can give you example json output for some txs if that'd help.  Or you can try running on segnet or testnet3 and see how it works.  Hope this helps.
@_date: 2017-01-12 14:27:43
This kind of confusion is why I'd appreciate clarity on this point; I'm not.
@_date: 2017-01-08 22:45:59
Yeah, having a p2sh address with OP_CLTV in it would allow you to re-use the address, but why would you want to do that..?
As to which is better, I agree there's not too much difference, but I'd lean towards the nLockTime txs.  Space-wise OP_CLTV is smaller if you die, and nLockTime is smaller if you live.  Optimize for life.  Privacy-wise, nLockTime is better in all cases: if you die, it's just a p2pkh tx with nLockTime set, which is common (the bitcoin-core wallet sets nLockTime).  If you live, you don't even have to use nLockTime at all.
(And yeah, I realize comparing saving a few dozen bytes on a computer network with whether someone lives or dies is rather brutal ... but hey, 'dismal science', right?)
@_date: 2017-01-12 02:27:52


Who is "we"?
Who are the members of this "lightning community"?  
@_date: 2017-01-21 18:25:18
Here's what I think is one of the big misunderstandings: 
(note that I'd much rather assume honest misunderstandings than misinformation :)
People have explained the signatures as being "separate".  After all, it's called "segregated witness"!  And we have, in the code, "witness transactions" and "witness blocks".
Even as a coder, when I first heard those terms, I thought, OK so a new node that supports segwit will download the old, traditional block, and then download the new "witness block" as well, and with both those things be able to verify everything.  Because that's what it sounds like.  And with that understanding, I can see how you can argue, blocks aren't bigger, there's just this... other new thing that wasn't there before, separate (segregated) from the block.
First day I started coding (re-implementing segwit in golang from the BIPs without looking at the c++ code) I realized, nope, that's not how it works.  The "witness block" has everything, including witnesses.  The new software doesn't touch non-witness blocks.  The blocks are bigger.  I have a script that will spam testnet and make 3.7MB blocks.  It's not a 800KB regular block with txids and output scripts, and a 2.9MB witness block with just a bunch of signatures.  It's a single block, that looks pretty much the same as old blocks with a few extra requirements, that's 3.7MB.
Whether people like segwit or not, (I have my nits to pick with the design, but I've coded so much that depends on it that I really want it to activate :) it's important to be arguing from the same page, which is that segwit is a block size increase.  It's kindof a weird one, and kindof a hack, but as coded today, it's unambiguously an increase.
(PS the block size increase is not why I care about segwit.)
@_date: 2017-01-21 21:41:06
I coded some serialization, sighash, signing, parts like that -- basically just enough to be able to create segwit transactions that bitcoind nodes would accept and put in blocks.  Roasbeef took the code from there, changed and added a lot, including all the consensus code, and has a [PR to btcd](
Right now my [lit node]( imports a slightly modified version of that PR; hopefully it can get merged soon. 
(&amp; yes, definitely open source)
@_date: 2017-08-28 19:39:51
Hi - 
In the case of the discreet log contracts, it's not 2 of 3, it's 2 of 2 multisig.  I mention 2 of 3 multisig type contracts and the problems associated with that model in the video at around 16:00
@_date: 2017-01-08 20:44:59
You don't need OP_CLTV for that, just the nLockTime field.
Have coins at utxo A, which is your pubkey.
Have a tx which sends from utxo A to address B (kids).  This tx has the nLockTime field set.
Give the kids the private key for address B and the transaction.
Or the kids could give you the B address, but in this scenario handing over private keys is probably OK. (I'm generally wary of moving private keys)
@_date: 2017-01-08 23:11:41
Similarly, you also lose the ability to make channels of indefinite duration.  Same problem; can't sign any kind of refund tx until the fund tx is confirmed, so you need to use OP_CLTV / OP_CSV when you start.
@_date: 2017-01-12 07:05:30
I'm aware of the repo; I named it.  I'm not clear on who/what lightning.community claims to represent.
@_date: 2017-01-04 21:56:25
Schnorr signatures would have immediate benefits for lightning network transactions - mainly that the 2 of 2 multisig output would turn into a single pubkey hash output, indistinguishable from other single-key addresses.  That saves space, mostly when closing the channel (1 key, 1 signature instead of 2 keys, 2 signatures) and provides better privacy because channels would look the same most other transactions.
While it would require a bit of coordination (everyone involved would need to close their channels at the same time), it would also be possible to close many channels in a single transaction, and combine all the signatures.
This wouldn't have quite the space savings, as the pubkeys for each channel would need to be revealed (33 bytes each).  It would save on the 71 byte signatures though, so space savings would be pretty good.
Another caveat is that with segwit, the witness data (pubkeys and  are "discounted" 75% already, so despite the actual size in bytes of the closing transactions going down dramatically (maybe 40% smaller? I'm guessing) the fee savings wouldn't be as much.  It still saves space though, improves privacy, and would be worthwhile to code.
@_date: 2017-08-26 04:35:32
small numbers are not zero.
If a sign in Home Depot advertised a brand-new refrigerator, that runs for free!! ... and then I see it just uses a hand crank generator instead of plugging in to the wall... I'll say that's not free.  In fact it's much worse and more costly to run.
Requiring transactions to have proof of work is what Bitcoin does. Bitcoin gives you the option of paying someone else to do the work, but you are always free to use the IOTA model and mine your own block.
@_date: 2017-08-26 02:28:29
Saying IOTA has zero fees is exactly equivalent to saying that bitcoins are free.
You have to do proof of work to get an IOTA transaction confirmed, right?
Well, all you have to do in order to get as many bitcoins as you'd like is some proof of work.  By that logic, bitcoins are zero cost.
And in fact, since you only pay transaction fees in bitcoin itself (which are generated purely from proof of work) all bitcoin transactions are also zero fee!
@_date: 2016-11-09 13:33:33
Soft / hard forks don't directly describe consensus being maintained / lost.  It's more about adding / relaxing rules, and the order in which changes are made; i.e. reversing a soft fork is a hard fork.  
A soft fork can split the network into two, and generally will if it activates with a minority of hash power enforcing it.  A soft fork with the majority of hash power behind it will maintain one network.
@_date: 2016-12-22 19:06:16
If you're going to use SGX, why deal with channels and all the complications and limitations that leads to?  Just have the SGXs send each other private keys.
No routing, no channel creation, no timeouts, instant confirmation, unlimited scalability...
Just seems really weird; LN works the way it does because of how bitcoin works; with a trusted environment you can do ~anything.
@_date: 2016-11-25 03:24:58
Yeah you can do LN without segwit.  It's less efficient, and there are some features you won't be able to do.
With segwit, you can have a 3rd party "watch" your channel for you in case your counterparty tries to broadcast an old, fraudulent transaction.  The 3rd party can automatically grab your money back for you.  And the watcher doesn't even know about your transactions or your balances while watching.  
That whole feature is pretty much gone without segwit.  You'd have to tell the watcher everything about your channel, and the only thing they'd be able to do is e-mail you to let you know if fraud occurred.
The other main disadvantage to segwit-less LN is that channels would have a preset duration.  That's a pretty big downside.
If segwit doesn't activate after a long time, we could re-program some of the current code to work without segwit.  I think everyone's hoping we don't have to as that'd be a bit disappointing, but doable.  As I meme'd at scaling HK, [there are levels of LN we are prepared to accept] (
@_date: 2017-08-28 19:57:51
Hi- 
I think it "works" but... it may make caching signatures too difficult / expensive, which would probably mean it won't get soft-forked in.  The problem is that the signatures in a block look different than the signatures already seen in the mempool, so even though you have seen the transaction and marked it as valid, you have to recompute the signature verification.
This would add a (probably unacceptable amount) of latency to block validation.  If you're just doing IBD though it works great, but the space savings aren't worth increasing latency for miners.
I'm hoping to find some way to mitigate the re-calculations, or cache partially aggregated signatures or something...
@_date: 2016-11-14 19:16:11
I really don't think "routing" is the most difficult part of LN, and by "routing" I mean "finding a route that works.  (Once you find it, or finding the *best* route, that can be trickier)
It seems hard because it's got to be this giant distributed network that keeps changing, with no one node aware of the full network.  That's PhD thesis level stuff there!
But just like how Bitcoin "cheats" and achieves consensus in a very different way than PBFT and other research, LN can also use that aspect of Bitcoin to make things much easier.
The LN graph is just a bunch of edges (channels), and you need some kind of data of which ends of the edges overlap to make vertexes (nodes).  The important thing is: the # of edges can never be bigger than the # of UTXOs.  Because each edge *is* a UTXO.  So if you run a full node, you've already  got the LN graph (well, the edges anyway)
The data for to link edges into vertexes is compact, on the order of 100 bytes each.  So even in a worst case scenario where every node has degree 2*, you need somewhere around 2X the disk space of storing the UTXO set.
So, run a full node, pass around the extra data linking channels, have the full graph, and run Dijkstra's or whatever when you want to route.
It doesn't feel very scalable, and it isn't, but Bitcoin is already constrained in the exact same way.
Approaches like Flare are cool, and are somewhat like SPV mode in that they don't need all the data.  But having the full LN graph on your hard drive will always be possible as long as running a full node is also possible.
[* worst case in terms of data storage; Every node having degree 2 would be very decentralized!  Unusabley so!  Just a giant ring...]
@_date: 2017-08-08 05:11:13
Semi-off-topic (&amp; I do appreciate &amp; agree with Rusty's article)
In keeping with the recent naming wars where people argue over what words to use to refer to things, the BIP / code / developers are probably not going to call whatever gets implemented "Schnorr" signatures.  It might be called "BN signatures" after the authors of a [paper]( about multisignatures, or might just be called "aggregate signatures" or something more general.  I'm totally for this idea, and hope many people agree to not use the term "Schnorr" signatures, as his patent on the really straightforward 
    s = k - h(m, R)x 
equation pretty directly led to ugliness that is ECDSA and set implementations of real world multi-party signature schemes back by quite a while.
It might save 50%+ from txs with many inputs, but that space savings is in the already discounted witness area, so throughput increases may not be as significant as they would otherwise be.  Still really cool research though!
@_date: 2016-12-12 18:14:04
This is not the case with LN channels.  Thanks to OP_CHECKSEQUENCEVERIFY, they can remain open indefinitely.
@_date: 2017-08-28 19:53:09
Thanks for writing this kanzure! :)
@_date: 2016-11-14 19:49:53
If there's 10 btc in the channel, and you want to make a payment of 0.005 btc, you can just send it and it'll probably work.
You can't make payments comparable in size to the capacity of a channel.  In those cases, you should just use a regular bitcoin transaction, or make bigger channels.
@_date: 2017-08-25 20:09:53
That's easy: the people who switched what software they are running are the ones who have switched.  The people who are still running the same software they had 2 years ago are still using Bitcoin.
@_date: 2017-08-26 04:14:33
What does "1/10000 of electricity" mean?  100 nanoJoules? nanoWatts?
Assuming you mean some small amount of energy, then yes, electrical energy and monetary value are directly comparable.  Various mining calculator sites can give you the exact rates.
@_date: 2016-11-08 23:34:43
Technically it's a soft fork.  Soft forks can render existing UTXOs unspendable.
Not sure it's the best analogy, but a hard fork would be more like the introduction of a new, strange looking 1000 rupee note nobody had seen before.  Some users would think it was fake and wouldn't accept it.  Users with new mental "software" would accept both old and new style rupee notes.
@_date: 2016-12-22 19:42:46
(disclaimer: I've never worked on SGX)
If you simply send around encrypted private keys to existing UTXOs, then yes, you'd be limited to those values.  But it seems like you could also create a transaction with 2 outputs (1 to the recipient, 1 change output), send the encrypted private key for the non-change output, and attest to the "erasure" of the initial signing key.
On the receiving side, you get a signed transaction spending to an output, as well as the private key to that output.  That tx isn't on the blockchain, but could be broadcast.  You also get a promise that  the input won't disappear because it's diabled in the SGX enclave of the sender.
... that's, on its own, isn't scalable though because then eventually you get huge chains of unbroadcast txs.  So you'd also needs some kind of "cut through" functionality which allows the "disabled" private keys to be re-animated.
...OK now that I'm sketching it out a little more it does seem a bit complicated, so maybe staring off with an LN-like structure make sense.  It does look possible to do better than LN if you're using SGX to restrict private key usage though.
@_date: 2017-08-26 02:31:47
Shameless plug:
I think Discreet Log Contracts are a nifty idea. [paper]( / [video of talk]( (slides also in youtube link)
@_date: 2016-12-10 18:53:21
Bitcoins held in a 2-party lightning channel are not "locked".  The opposite is true: coins in functioning channels can be moved more quickly, and with lower fees, than standard utxos in your wallet.
Another (trolly) way to look at it:
"P2PKH coins are locked because you have to get permission from miners to include your transaction in an artificially space-restricted block in order to move them.  Even after permission is granted, delays of hours are common.  Coins in an LN channel can be reliably sent within seconds, without miners or the wider network aware the transaction."
That's more factually correct but also kind of misleading.  
Also, you probably won't make any money off routing fees.  Similar to how all the people who bought piles of 5870s back in the day didn't make money either.
@_date: 2016-11-22 14:40:23
Srsly??  Aw man I gotta get me some of that vampire squid money! w
@_date: 2016-12-12 20:57:11
Here's a big reason to monitor it yourself, instead of leaving that to a 3rd party -- disk storage. (this ties in to the "potentially much bigger than the bitcoin blockchain itself" part above.)
If you're watching it yourself, you can store O(log n) data, where n is the number of states in the channel history (roughly the number of payments made and received).  The 3rd party must store O(n).  For channels with low activity, it doesn't make too much of a difference whether you store 3KB or 3MB.  But if people use this for novel use cases like micropayments, and have billions of previous states, then 4KB vs 60GB is a big difference.  For normal use, monitoring will be cheap / free, but for highly scaled out usage, it may make more sense to keep it to yourself.
The reason unlinkability of 3rd party monitoring helps is not just because it encourages people to use a 3rd party monitor who otherwise wouldn't.  It's also that the monitors can then ask each other for data.  Maybe you've uploaded your channel data to lnwatcher.berkeley.edu.  But maybe lnwatch.redcross.ch grabs data from Berkeley's server.  When you're not sure how many people are watching the channel, trying to fraudulently close gets very risky.
@_date: 2017-11-16 22:08:18
Unfortunately, no, they might just be offline.  For example:
Alice has 5 coins, Bob has 5.  Alice makes a backup to her SD card at state 43.
Alice sends Bob a coin in the channel.  Now it's A:4 B:6, state 44.
Alice restores her backup to a different computer, and sees that Bob's offline.  She broadcasts A:5 B:5 state 43.
Bob comes online a few hours later and detects that Alice has broadcast a fraudulent transaction; Bob's software immediately and automatically grabs the A:5 output.
So in this case, Alice is accidentally malicious because she forgot that she had given Bob and extra coin, and tried to take it back.
If Alice and Bob know each other and are nice, Bob can give Alice back the 4 coins that were supposed to be hers at the most recent channel state.  But he doesn't have to; he can keep them, as he can't be sure that Alice wasn't trying to catch him off guard.
@_date: 2017-11-16 21:09:26
Unlike hashes, names can collide.  In the 2nd collision there, looks like some kind of parent-transaction kind of thing :)
@_date: 2017-11-16 22:45:40
It's possible, but Alice really shoudn't ask Bob what the channel state is.  Bob can lie in various ways:
Bob can say "yeah I have 8 coins and you have 2, let's close the channel"
Bob can say "yeah we're at state 43" when actually he's at 44, so he'll be able to use a justice tx against Alice if she tries to close.
Bob can not respond, but try to close the channel at a state where he gets more coins, because he's pretty sure Alice can't construct a justice transaction.
Safest thing to do if you've lost your channel state information is to go offline and wait for the counterparty to close it, probably at the correct balance.
@_date: 2017-11-16 21:13:52
This is a valid concern, and the software needs to prevent it.  In my code, the your counterparty's signature is overwritten on disk before you reveal any information which would allow someone to justice-tx you.  So you never have data on disk which could be dangerous to broadcast.
There are still risks though!  If you back up your files on a USB drive and then restore that, your software won't know that it shouldn't broadcasting the wrong thing, and your counterparty can broadcast a justice-tx.  Backups are dangerous in LN :\
@_date: 2017-11-09 23:17:20
I *really* don't like the term "IOU" in context of the Lightning Network / payment channels.  
O: There's no debt, no sense of "owing".  Everything is delivered up front, anyone can disappear at any time, and that's OK.  
U: And there's also not really a "you", in that you may not know who you are connected to.
Maybe this sounds like a nit-pick, and I know Andreas gets it; he goes on to explain that there's no debt involved, that it's trustless, and he's right about that.  But people latch on to words!  People say "lightning hubs" a lot, and I've never used that term; I've never heard a technical definition of it (I'm guessing a node with a degree greater than 1?).  The LN whitepaper doesn't contain the word "hub".  And people attack LN for having "centralized hubs", when we never used that word.  I worry that "IOU" will be used in a similar way.  Not sure a better term to use as a substitute, maybe "balances" or "payments" or something.
@_date: 2016-02-02 03:51:29
I agree that it's pretty quick to see that w can be computed from i just from the i in the n-dimensional tree.  In elkrem if you know the height h you can determine it as well:
Given index `i` and height `h`, index `w` is derivable if
`w &lt; i &amp;&amp; w &gt; (i+1 - 2^(h+1))`
It's not as visually apparent in the binary representation but still quick to calculate.
Elkrem does have 2 hash functions, but they're each 1 line of code and almost the same.  N-dimension chain needs various bit-flips before the hashing stage which isn't needed in elkrem.
I think they're both useful methods and if people really like the n-dimensional chain I'll code that and make it work in our repo, but the elkrem tree structure seemed more intuitive to me.
@_date: 2017-04-30 02:18:24
I agree that users do seem to like using a website (e.g mybitcoin.com) instead of downloading and running software.  But if the website is being run on someone else's computer, you're at that person's mercy.  There isn't really any way around that.  So it's important to discourage people from using a web wallet, and thinking that web wallets offer security and privacy.
Mobile apps like .apks are better but I don't know that ecosystem, something to look at.
If users can run their own website, that would work.  The problem there is that many people would then try to run the site on a "cloud" provider such as AWS, again losing the security and privacy of having your own computer.
@_date: 2016-02-02 01:41:52
I guess the whitepaper does say it's "possible to just disclose private keys" (pg 27); we should clarify that maybe.
It would be indeed be possible to do it that way but that's not what we're programming it.  It's better to use hashes and pre-images the same way the multi-hop HTLCs do.
The main advantage is that you don't have to keep track of many private keys, and can use one set for the whole channel, and just keep track of pre-images, and put the pre-images into a tree-like data structure to save space.
@_date: 2017-04-18 12:21:22
Unlikely to be usable for exiting utxos; It will probably only apply to new utxos created after a Schnorr-signature soft fork which introduces a new witness version.
The space savings are substantial: inputs currently are
32B txid + 4B index + 33B pubkey + 71B sig + 4B nSequence = 144B
with Schnorr sigs
32B txid + 4B index + 33B pubkey + 4B nSequence = 73B
Or around 50% per input.  One of the inputs does need a signature, which is amortized over the rest.  The 71 byte savings are in the witness though which would already be discounted, so you can't actually fit 50% more inputs.
The reduced load on the network may allow lower fees to clean up non-schnorr dust though.  Keep trying on weekends with low fees; worst that happens is that it doesn't confirm.
@_date: 2016-02-28 18:31:42
Agreed -- probably the most important variable in the topology is the (min / median / mean) degree of nodes.  1 channel per node and it basically doesn't work.  2 channels per, and it's functional but not great.  3 seems maybe OK. 4 per node with a power law distribution of higher degree nodes (eg 1K nodes have 10 channels, 100 nodes have 100, 10 nodes have 1K) and the mean path length gets surprisingly short and fees very small.
Making channels cheap to maintain and easy to open is very important in making a well functioning network.
@_date: 2017-04-29 23:25:35
Sorry, not sure what you mean by "red team" and "hub" and "risk" here.  So I'm pretty much guessing on this; let me know if these guesses are wrong :)
If "hub" is defined as a node with degree &gt; 1, the majority of nodes will be "hubs", hopefully.  The degree of nodes will very likely follow a [Pareto distribution](  If, as a user, you want to try to reduce the  parameter of the degree distribution of the entire network, you could set up your node to preferentially connect to nodes with a low stated degree.  However, remote nodes could be lying, or really just omitting channels that they have, and have a higher than stated degree.  They cannot, however, falsely prove participation in a channel (well, without a whole lot of not-really-scalable collusion).
If you set up your node this way, I'm not sure what you'd call it, but maybe "anti-preferential attachment" or something (see [preferential attachment](  
On one hand, this is highly sub-optimal from a graph traversal perspective: if you try to connect to lesser-used nodes with fewer edges, you'll probably pay higher fees, have worse reliability, etc.  But it might not be that irrational!  An real world analogy I can think of is people who eschew chain retailers, restaurants, and popular culture such as hollywood movies, and instead participate in local / indie markets, like things before they were cool, etc. 
I dunno about this though; there's not much visibility in what your LN node does; and it gets into a weird mix of definite metrics and hard to measure cultural factors.
Decentralization for decentralization's sake is really hard!  Most things get more efficient when they are centralized, and there seem to be powerful centralizing / converging forces in all sorts of economic systems.  Much like Bitcoin, LN allows users the option of peer to peer transactions without intermediaries.  If users instead choose to use a site like mybitcoin.com (maybe mylnchannel.com) then there goes the whole point.
But we can't simply blame the users for abdicating responsibility and sending all their coins / channels to a centralized custodian.  As a programmer / designer of LN it's also my job to make use of LN attractive enough to users that they are less likely to use a custodial / centralized service.  That's why I think discussion of these aspects is so important... and I should do it more!
@_date: 2016-02-03 22:13:35
SPV clients that do not upgrade can benefit from Segregated Witness.  SPV clients are able to receive outputs from the new transaction types with no loss of security.  When they spend though, they will not employ the new transaction type and won't see space savings.
@_date: 2016-02-28 19:34:05
I'm hardly unbiased and not taking issue with most of this article but I just want to point out that the first diagram is confusing and seems incorrectly labeled.  The top graph, labeled "More decentralized" has a single vertex near the left side which if eliminated would segment the graph into 2 unconnected graphs.  The middle graph, labelled "Less Decentralized" is the same but with 2 edges added, eliminating the single point of failure.
Any way I look at it, the middle graph is more decentralized.  Same vertices, two extra edges, no more single point of failure, sounds good to me.  It's not like you've got one vertex with an outsize degree; there are lots of vertices with degree 5 on the top graph, all of which are unaffected by the addition of 2 edges.
I'd also argue that the bottom graph, labeled "centralized", is actually MORE decentralized than the one on top!  Sure, there's that vertex at the top with degree 13.  That's a lot, and maybe that gives a bad gut-feeling.  But as in the middle graph, it's a *superset* of the top, only adding edges and reducing points of failure.  
People might argue "but there's this supernode / hub / evil central node in the middle!"  Which is true but all the other edges are still there.  If in the bottom graph many of the edges had been eliminated and the *only* path was through that top supernode, I'd agree it was more centralized.
The larger problem is we don't seem to have agreement on what "decentralized" means in mathematical terms.  Everyone (or almost everyone) seems to agree that decentralization is good and centralization is bad, but without clear measurements of centralization people can get stuck in unproductive arguments despite wanting the same thing.
Not that I'm suggesting such a clear measurement or index.  Just [look here]( at how complex the whole topic of centralization can be!
@_date: 2016-02-02 05:14:18
That's true, and I'd like that better than modifying the bits of the preceding hash.  Actually your ASCII graph of the n-dimension chain made it make a bit more sense to me -- thanks. I might try coding it when I get a chance.
@_date: 2017-04-18 04:17:15
How many "centralization points" can you add before it becomes ... decentralized?
More independent nodes = less centralized.
@_date: 2016-02-06 05:10:52
What does that even mean..?  Nothing can solve ECDSA "malleability" on the part of the signer.  If you have a private key... you can sign different messages with it.  Otherwise... wh.. huh?
[Obligatory meme image.](
@_date: 2017-04-18 04:32:34
If only a few run it, then the Lightning Network will only have a few users.  Every user of LN runs a separate node.  It's a peer to peer network.  Nodes only need to be online to route and send/receive payments.
@_date: 2017-04-18 01:03:18
The main differences would be in the funding process and monitoring process.
Without segwit, when you create a channel, you would specify the duration of that channel.  Probably something like a few weeks.  There *is* a way to safely create indefinite-duration channels without segwit but it's a mess, and requires the recipient of the channel to put up coins.
The other downside is no 3rd party channel monitoring.  So you have to keep a node running, or sync up every day or so.
Neither are total deal-breakers, and I think it would still be quite useful even without segwit.  It's much nicer with segwit though, so I hope the network activates it.
@_date: 2017-04-29 22:26:46
Funding transactions just have a P2WSH output so don't look particularly different form any other script hash output.
If Schnorr signatures were enabled after Segwit, channels wouldn't even be detectable after the fact, as 2 of 2 multisig would look exactly the same as a single key.  That'd be pretty cool.
@_date: 2017-04-29 15:43:57
Segwit increases the maximum block size to 4MB.
BUT: There is a clever restriction which makes it backwards compatible with old software. Segwit nodes identify which nodes are aware of segwit, and which aren't, and omit some data (the witness stack) when transmitting blocks and transactions to non-segwit nodes.  Segwit nodes do this in a way that maintains compatibility, because to the old nodes, it looks like no signature is needed.
Since non-segwit nodes will not accept blocks greater than 1MB, segwit nodes ensure that the blocks with witness stacks omitted never exceed 1MB in size.
(There is misinformation in this thread which is concerning; it's really not that complicated and everything is open source and fairly well documented.)
@_date: 2016-09-24 03:35:30
Yeah, that and some other projects, thus the overloaded smiley / close parenthesis :)
sighash_single sounds cool for the first 10 seconds but then you realize it doesn't help anonymity.  I'm not aware of any cool uses of it.
Then there's the sighash I've wanted for a long time, sighash_noinput.  Would be really cool, and a soft fork, but several people think it's too dangerous (since you don't sign the input txid, those signatures could be replayed)
I'm only half joking with the smiley though; the simplicity of sighash = txid really does have some appeal.  Makes things more standard. Feels a bit like schnorr sigs, where mutlisig looks like single sig.  Or like BIP69.  
(Oh, also, everyone use BIP69!  Almost nobody uses it, and it doesn't work unless lots of people use it!  It's really easy to do, and it helps!)
@_date: 2016-09-24 15:13:36
By "shared key" do you mean public key?
You can have multiple addresses from a single private key.  The main way you'd see this in bitcoin is compressed vs uncompressed addresses.
A public key is a point on an elliptic curve.  Bitcoin uses y^2 = x^3 + 7.  Or y = sqrt(x^3 + 7).  When you take a square root, you get two answers, positive and negative, so this curve is symmetrical over the x-axis.  For a picture and more detail look [here](
So to write down your public key, you say the x and y components.  Then anyone can get out their graph paper with the curve on it, find the point you've said, and make sure it's on the curve.  This works, but is inefficient!  You can just say the x value and whether y is + or -, and everyone can find the point that way.  This takes half as much space. (It's called "compressed" because it leaves out redundant data)
Bitcoin supports both compressed and uncompressed public keys.  There is no reason to use uncompressed keys.  They take up an extra 32 bytes when you spend from them, costing an extra 1500 satoshis or so.
You can't use the compressed public key to spend from an uncompressed address.  The addresses are hashes, and will look completely different.
Another way to have the same private key result in different addresses would be to use p2sh, with the script just being &lt;pubkey&gt; op_checksig.  This would result in an address starting with a 3 instead of a 1.  I don't know of any software that does this, but it'd be easy to do and would use about as much space as addresses that start with 1. 
There are other ways to do it as well but those are the most straightforward.
TLDR: yes, one private key can create a "compressed" and an "uncompressed" address.  Never use uncompressed, it wastes money.
@_date: 2018-02-19 02:59:58
Yup, in [lit]( the watchtower functionality is built in and can be activated on any normal node.  The data overhead is about 100 bytes per state being watched, so not too much. 
 The fact that you basically never use it to reclaim funds for the watchee doesn't actually help that much since you still have to try to match every txid of every new block to everything you're watching.  Building the "justice transaction" is very quick in comparison. (No EC ops, just moving some bytes around and broadcasting)
@_date: 2018-02-19 02:53:22
It's great to hear that there will be people who want to help the network -- I'll set up a computer to do so as well.  Here's one of the downsides / problems: spam / DoS.
Since the data provided to the watcher gives no information about the channel being watched or the transactions being watched for, it's very possible that the channel doesn't exist and the transactions haven't happened; the client can just make up a bunch of noise and ask the server to watch for it.
I think there are several ways to address this: you could watch your friends' channels, since you're pretty sure they're not trying to fill your hard drive up just to annoy you, or you can offer to do it anonymously, but charge some per megabyte fee.  It's very cheap to do and scales well, but if it's completely open to anyone it can be spammed.
@_date: 2018-02-19 03:04:41
It certainly seems like the best incentive for the watchers to get paid when they successfully defend a channel from fraud.  But it's actually quite tricky to implement.
It's difficult to prove to the watcher that they're going to get paid without reducing privacy; in the current model the watcher isn't sure if the channel they're watching even *exists*, let alone how much money is in it, let alone if they'll get paid by the transactions they can broadcast.
So there's a tradeoff between incentivising the watcher and preserving the privacy of the watchee.  In the more private mode, the channel data can be shared and transferred among many watchers, who may not know who they're watching it for.
@_date: 2018-02-20 20:24:51
Watching all the channels of peers you have shared channels with does seem like a reasonable thing to do, but I would be hesitant to make it a default in the software.  Maybe with some restrictions.
Or some kind of metric based on the capacity of the channel(s) you have with the peer; for example, I'll store &amp; watch up to 1GB of data for every BTC of channel capacity with them.
Also you don't really know how many channels your peers have; they can have channels they don't advertise to the public network, but still want others to monitor for them.  It's even possible to aggregate channel watching data so that the watcher cannot group transactions by channel, though a significant cost in efficiency.
Awkward wording... as an example:  The setup right now as the client send messages to the watcher, one per transaction.  The watcher knows that msg1 is for channel1, and msg2 is for channel2, and msg3 is for channel1.  There are 53 prev states in channel1 and 87 prev states in channel2.  So the watcher knows how *many* channels they're watching but not where those channels are on the blockchain (or if they even exist).  
It's also possible to do it so that each state message is independent; the watcher has 140 messages, and there might be 140 channels, or just 1, or anything in between, and they don't know.
To answer your question though, generally it's all the same size either way and it's pretty small, on the order of 100 bytes.
@_date: 2018-02-23 04:29:27
It's unfortunately O(n) space where n is the number of states watched.  They all go in a big key:value store where the key is a partial txid and is ordered so it's quick to find (in O(log n) time) and the value is the signature and a bit of other data.
In practice it scales pretty well as it can be partitioned among different disks or machines.  Getting it down to O(1) per state, or really O(m) where m is the number of different channels seems possible but would require some very fun soft forks.  (Well I think they're fun, but many other bitcoin developers think they're too dangerous, and I respect that stance.)
@_date: 2018-02-23 04:48:20
An oracle exit scam can be a pretty good attack in that they can enter into a whole bunch of contract which they know they will win, so there doesn't need to be any bad privacy on the part of normal users.  Still, they need coins to start out with, and they need to build up a reputation first.
It *is* trusted, and I don't think you can take that away; I think when it comes to real world data, we'll need to rely on real world reputations as well.  My hope is that this won't be a big stumbling block, as it seems that it's not a big problem in finance today: I haven't heard of Bloomberg reporting incorrect prices in order to change trade outcomes.  
But then in normal finance there are courts and lawyers and if e.g Bloomberg did report incorrect data, the courts wouldn't hold contract parties to it, whereas in DLC the blockchain would!  Also the counterparties can be anonymous, and in different countries.  So I think the best case will be oracles that also have real world reputations and already report market prices, like exchanges and brokerages.
There are bunch of other weird lightning-like counter-intuitive edge cases which we also need to caution people about (for example: restoring from a backup can make you lose all your money.  yikes)
@_date: 2016-09-24 02:17:31
I don't mean to disagree with your general assessment &amp; I think there's a bunch of problems, but I think it *does* in fact solve the N^2 hashing problem.  From my understanding, the sighash is identical for all inputs of the tx, and it's just sighash = txid.  Which is kindof cool in it's simplicity actually.  (At the cost of no more sighash flags, so everything is just sighash_all.  But who uses anyonecanpay &amp; single anyway? :)
I can see how one would want to get rid of nSequence for txins, because that's 4 bytes that's been completely useless.  But lightning channels will start using those 4 bytes.  (actually they'll only use 2 of them, as OP_CSV is limited to 2 bytes)
I'm not sure how you can make OP_CSV work with a tx-wide lock.  It'd be a big change to the current code, and for what...?
Overall though I agree.  The cost of hard forking is so high, the upside needs to be huge for it to be worth it.
@_date: 2016-09-01 13:53:59
Adding to jl_2012's comment:
Yes, LN transactions can be made without access to the internet, with some (important!) limitations.
Channel creation and destruction require transactions to be confirmed in the Bitcoin block chain, which requires some kind of internet access, even if it's not direct.  But once a channel has been set up, no information about that channel's state goes on to the block chain until the channel closes.  If Alice and Bob both set up a channel at home on the internet, then go on a mining expedition together deep under the antarctic glaciers, they can still update their channel's state.
Also, if Alice, Bob, and Carol have channels (A-&gt;B, B-&gt;C, but no A-&gt;C) and are in the glacier mines, Bob can route payments between Alice and Carol, still without internet.
This seems pretty cool, but there are some limitations.  If the channel timeout period is short, and the channel is closed at an invalid state, someone could get ripped off because they have no way to monitor the blockchain.  One solution would be for timeouts longer than the time you intend to be offline, which may work.  But really this is only a problem when one party is offline, and one party is online.  If Alice, Bob, and Carol are all offline at the same time it's safe.  If the timeout period is shorter than their mining expedition, and Bob has secretly stashed a sub-space ULF communicator, he can defraud Alice and Carol.  If Alice can broadcast but not receive, it safer for her (she can transact offline, but one-way broadcast to a trusted online party with outsourced revocation information... and hope it gets there!)
So, basically, yes, LN does allow some transactions to be made without an internet connection.  The limitations are significant though, and I'm not sure to what extent this aspect of the system will be used in practice.  One use of LN may be on other planets or star systems where the speed of light limits direct access to the bitcoin block-chain for interplanetary trade.  (Still can never mine on other planets though)
(Joking about the last part)
(For now anyway!)
@_date: 2016-10-15 14:33:05
I like segwit, and use it extensively in my code.  That said, I'm not surprised at the reaction to it.
I think one reason for the opposition to it was the way it was presented as *fait accompli*.  Sipa gave the "reveal" talk about it at scaling HK last December, and was clearly excited about it.  But it came off (to me at least) as quite top-down, somewhat akin to the recent ethereum message [here]( 
(ok, not that bad of course, but the same kind of idea -- "hey guys!  we figured it out!  OK, done!")
A lot of people in bitcoin development really don't like politics and PR and that kind of stuff (myself included), so I understand why this would happen.  It makes sense from the segwit developer's perspective -- they found a way to double the blocksize, **as a soft fork!!!!**  They didn't even think you could **do** that!!
But, as soon as the talk was over, I remember telling people "this is going to be a mess..."
There's a bunch of stuff I don't like about segwit (postponing address specification for what seems like political reasons, the ugliness of nested p2sh, neglecting to build txhashes as a tree of txins and txouts...) but those are just my personal views / complaints, and I don't get to dictate what goes in to bitcoin. 
On the whole it's an important and useful update. I've been testing it for months on testnet (I think all the 3.7MB blocks on testnet3 are mine) and I'll run and use it once it's active on mainnet.
@_date: 2015-11-07 17:51:33
Hi- We just added a "[Technical Design Overview]( on our site.  Not sure if it quite reaches ELI5-certification but close.
It's decentralized by design.
@_date: 2016-10-24 14:51:27
Segwit is safe to the point where *miners* can not upgrade, and still mine!
Bitcoin.com has been mining on testnet3, and they are running a miner that doesn't know about segwit.  [Here's a block they mined today.] (
(note that the previous and next blocks are segwit blocks, but this one isn't.  Easiest way to tell is look at the coinbase tx, it'll have an op return with "aa21a9ed" indicating the witness commitment)
They don't include any segwit transactions (which is most of testnet3 at this point, because it's for testing new stuff!) because to their node it's non-standard.  But they accept blocks with segwit txs, because non-standard means you reject it from the mempool, but accept it in a block.
So in testnet3 you have a majority of segwit miners, and some miners who have no idea what segwit is, and it still works!
Note that this is a really bad idea when real money is at stake -- bitcoin.com's node could accept what appears to be an OK block which the other segwit-aware miners will reject as they can see and verify the signatures.  But if everyone runs "nice" node software, even miners can be a mix of segwit and non-segwit nodes without orphaning blocks.
(seriously though don't try this on mainnet, nodes are not nice, they will try to rip you off.  This is just an illustration of the safety properties of the segwit soft-fork.) 
@_date: 2016-10-31 15:59:44
Title is probably right; whole article is full of wrong.
Bitcoin Unlimited splits with itself depending on which ~/.bitcoin/bitcoin.conf options people use.  "Emergent consensus" means you have to check block explorers or reddit to see what settings other people are using.
I started skimming through the text once it started throwing around terms like "impossible" and "25% security".  (I only use networks that are 99.99% secure)  The thesis here is that the chain with bigger blocks is better, so everyone will move to that, and a minority non-fork will die off.
Nah.  The biggest flaw in this text is the assertion that the minority chain is congested and it takes much too long to get confirmations.  (In the text: "Of course, all of this assumes that demand for this chain will remain the same as it is now.")  That assumption doesn't make sense.  If you actually had 75% of miners and 75% of users head out on a forked chain, there would be no difference in the congestion of the network.  Capacity of the network goes down because blocks take 40 min to arrive, but there's fewer transactions happening on this network, because most of the users are gone!  So it would work about the same.  Then after a few weeks, the difficulty would drop, and blocks would come out closer to every 10 minutes, and the minority network would be right back to it's original message capacity, but 75% of the users have left.  Even better than the segwit discount :)
Minority non-fork sure looks viable to me.  Unless the majority perform a "firm fork", or as some call it, "evil fork".  But none of XT/Classic/BU/whatever's next do that.  Which is probably a good thing.  Maybe they haven't see that code.
@_date: 2017-05-11 11:48:53
If you run a full node and don't update it to different incompatible rules, by definition you will never see a hard fork.
(Other people may hard fork but your node won't see it.)
@_date: 2017-05-07 12:44:58
Hi- this hasn't gotten any feedback on the mailing list so I'm somewhat hesitant to say "here's this new cool thing that works!" because it's quite possible that either 1) it doesn't work or 2) someone else already wrote it up.  Possibly both!
The idea is independent of the idea to have interactive signature aggregation, and the two could be combined.  Interactive aggregation would be easiest to implement in a single wallet, where adding 3 inputs into a transaction could have just a single signature that serves as a signature for all the inputs.  This signature would appear in only 1 of the inputs, saving a lot of space.
With block-wide aggregation, a miner's node would take all the signatures, remove them from the transactions they're in, aggregate them, and add a signature somewhere in the coinbase transaction.
It's not possible to actually do non-interactive signature aggregation of Schnorr signatures (it is possible though with BLS signatures).  But it seems possible to aggregate *half* of the signature.  Signatures are composed of 2 elements, and R and an s value.  The R values would stay, but the s-value could be removed and aggregated, so that the remaining data is only ~32 bytes long instead of ~64 once they're in a block.  This is in addition to any savings from interactive aggregation.
There are some downsides / complications I listed in the mailing list post.  And I thought of another one: reorgs can be a bit ugly as miners may not be able to mine transactions that have been reorged out of blocks into the mempool.  
 
I'm wary though because: the idea is pretty simple, there's a bunch of smart people working on Bitcoin, and I've never seen this proposed.  So there may be some cryptographic problem which breaks this aggregation.  It's the weekend so the dev mailing list is quiet, but I'm looking forward to feedback in the next few days (also questions on reddit!)
@_date: 2015-11-19 19:23:59


I agree that talk would be nonsensical.  Fortunately I haven't heard any.
@_date: 2017-05-10 15:41:33
Note that this user is likely the author of bitaddress; keep this in mind when deciding on or recommending  paper wallet software.  Unless you can personally inspect the code, paper wallet generation software demands a high degree of trust in the developers when storing large amounts of funds.
As a developer of lightning network software (and the person who came up with the name) I'm used to attacks like these and don't let it get to me.  It is concerning though when the person doing the attacks writes software which is probably responsible for safeguarding many thousands of bitcoins, and which I have told people to use (no more).
@_date: 2015-10-13 17:16:32
Payment channels do use proof of work, but in a different way than normal bitcoin transactions.  The difference is that payment channel transactions have specific time constraints, using lock_time, OP_CLTV, or other methods.
Proof of work is a way to come to consensus on the sequence of messages; payment channels use additional, message-based time and sequence constraints which are enforced by miners and proof of work. 
@_date: 2015-10-13 19:39:10
There are only 2 members of a channel.  They both have to sign updates to the channel allocation.  
"Consensus" when there are only 2 participants is much easier and does not need proof of work.  Whatever is the most recent, as signed by both parties, is the current state.
@_date: 2017-05-10 15:53:02
If the full graph is known, finding the shortest path can be done with Dijkstra's algorithm.  
If every utxo in bitcoin is a LN channel, then the storage size for the entire LN graph would be about double the size of the utxo set.
If you can run a full node (store the utxo set) then you can have the full LN graph and find routes in O(E + V log V).  I don't thing anything fancier than that is needed.
@_date: 2016-10-24 14:42:47
Any type of SPV-style / lite client *cannot* verify anything about the inputs.  So it won't even be able to tell that it's coming from a segwit input.  Only core or another full node based wallet would be able to tell that it's a non-standard tx.  It will reject the segwit tx until it's been confirmed in a block, so it wouldn't show anything unconfirmed.
Lite/SPV wallets will show segwit txs while unconfirmed.  Why they do this is another story, since for a lite client "unconfirmed" could be "comple nonsense"
@_date: 2017-05-11 11:54:57
Initial SPV nodes worked that way, before bloom filters were introduced in 0.8.  Bitcoind's use of bloom filters have a set of problems that make them unsuitable for use with lightning network.
It still saves a lot of bandwidth and disk space as you can start downloading recent blocks, ignoring years of history.  It also still provides the same level of assurance of validity: "I have no idea if this is valid, but a bunch of mining power seems to think so because these hashes have a bunch of 0s in them."
In this release, bloom filters can be enabled with the -ez command line option.  That code worked a few months ago but hasn't been tested recently. 
@_date: 2016-05-17 16:12:58
You can add fancy steps inside a LN channel, but the thing you're trying to accomplish is outside the channel.  
You could modify the on-chain transaction to reveal data causing a state change in the channel, but it's not really worth it.  If you want to make on-chain transactions, just modify your channel to do it.
    Inputs: 
    0) Your channel fund txo
    Outputs: 
    0) A new, smaller channel
    1) The place you wanted to send money
This is just as fast as a normal wallet if your channel counterparty is online.  If they're not online, you can't use the channel anyway.  If they refuse to cooperate, you have no choice but to close the channel to reclaim your funds anyway.
TLDR: If you have a live, operational channel, you can make on-chain transactions from it just as fast as from a normal wallet.
@_date: 2017-05-07 19:21:46
Sorry, followed your link but don't see anything related to signature aggregation.  By "this", do you just mean Schnorr signatures in general?  Certainly agree on that.
(Though I think we should call them something else; Schnorr's largest contribution was really to give us ECDSA :\ )
@_date: 2015-10-13 19:03:22
Reliable re-allocations of coins within a channel without a 3rd party or public broadcast is the entire point of a payment channel.
Other than "they can't", do you have a specific criticism of payment channels?  
The basic idea is A signs half a tx, sends the sig to B, and B has the option but not requirement to sign and broadcast...
@_date: 2017-05-10 17:45:58
The full graph can be propagated in a similar way to the bitcoin blockchain.  If your node holds a ~full graph, it can send that to any node which requests it.  If both nodes hold the utxo set, the sending node can provide a cryptographic proof for each channel that links it to an existing utxo.
There can be nodes that are unknown and don't announce themselves.  These nodes and channels don't exist on the graph for path discovery purposes.  Offline nodes cannot route payments but may still have their channels in the graph, which can lead to a routing failure if a payment tries to route through an offline channel.  This does not result in loss of funds, but may delay the payment as a new route is found.
To receive any payment with LN the receiving node must be online.  In the current implementations, nodes communicate with each other by creating direct TCP connections.  Later on it would be better to have a mixing network for messaging as well.
@_date: 2017-07-04 15:30:46
There are lots of cool things about Schnorr signatures -- the interactive signature aggregation is a definite help for scalability.
Another improvement which I've been looking at and may help further is that it seems to be possible to non-interactively aggregate signatures.  This would be done by miners, so instead of 1 signature per tx, there would be 1 signature per block.  It doesn't work on the entire signature, but does work on half of it, so that 64 bytes signatures get cut down to 32 bytes, and then there's one 32 byte aggregate value per block that you can verify all the signatures with.
There's a bunch of issues, such as the mempool wtxids would be different from the in-block wtxids, possible attacks, and so on.  But it might be worth implementing as if could save a bunch more space on top of the per-tx savings.
post about it [here]( further discussion welcome.
@_date: 2016-05-02 20:28:45
If you want to prove possession of an ECDSA private key, but don't want that proof to be public, just use ECDH.
your private scalar * their public point == their private scalar * your public point == ECDH shared secret
Tell him your public key, and ask for the ECDH secret.  That way you know he has the private key, but to external observers the ECDH shared secret doesn't prove anything, because you could have (and did) calculate it yourself.
But that would be too simple, and fraudsters like obfuscation and complexity to hide in.
@_date: 2015-11-19 18:52:55


LN nodes do not hold bitcoin on behalf of other people or nodes.
That's the whole point of LN.


LN is built on smart contracts, which can be extended.
@_date: 2016-05-23 15:19:52
Except for the initial state, clients can (and by default, will) disallow channel exhaustion (the situation where one side has all the funds in the channel).
Since both sender and receiver must sign to transition to a new state, either client enforcing this rule will cause it to be in effect.  This will ensure that there is no zero-cost invalid channel close attack.
@_date: 2017-05-12 19:16:45
This is a silly question.  Are you going to make 10M tx/day?  Because with LN, you only transfer / store / verify the transactions in your channels.  You never see the transactions in other channels.
A node which can handle 1M tx / day costs about $35.  That's about 10tx/sec, which can be done on a raspberry pi.  Storage per tx is O(log n)
@_date: 2015-10-13 17:06:16
Lightning very much depends on proof of work.  The opening and closing of a lightning payment channel are publicly broadcast transactions, which need to wait for confirmations just like any other P2SH transaction.
Once the channel is open, however, payments can happen more quickly using the lightning layer.  These payments are not in a block, but CAN be broadcast by either party.
Lightning is built upon and requires proof of work.  (Or some other consensus mechanism but Proof of Work seems to :)
@_date: 2017-05-11 11:23:31
In the release, it works by doing SPV mode (which I learned last night is somewhat broken in calculating difficulty adjustments, but there is a fix courtesy metalicjames) but by downloading the whole block instead of using bloom filters.
Also developed, but not disabled in this release (still too buggy but look in logs for "created justice transaction"), is the ability to ask other nodes to watch channels for you.  You can do this without revealing which channel you're asking them to watch, and only revealing the number of transactions you make within the channel, but nothing else about those transactions.  This would let you ask many peers to monitor your channels, and as long as at least one of them is online and operational, you're safe.
@_date: 2017-05-11 11:17:45
No, but metabolically speaking, I do subsist primarily off of free food from the [media lab FoodCam](  
The foodcam was introduced in 1991, coinciding historically with the fall of the soviet union.  I'll let people come to their own conclusion there.  Clearly, if someone (or something) wanted to, the foodcam would be a prime vector to introduce a foreign substance into our precious bodily fluids without the knowledge of the individual.
@_date: 2017-05-07 13:47:02
It would be a 50% space savings per signature, but the signatures would already be discounted, and aggregated, so maybe something like 15% more transactions per block?  Which would be worth it, I think.
(total guess though as space saved depends on many factors)
@_date: 2015-10-04 21:49:16
Segregated witness does solve the problem in the "right" way, but there are issues with path dependence.  Since you're changing a pretty low-level part of how bitcoin stores and references transactions, it's a whole lot of different code and a relatively ugly hard fork.  If bitcoin had SegWit from the start it'd be quite simple.
Something like SIGHASH_NOINPUT on the other hand, could be put in as a soft-fork.  It's not as clean in some ways, in that it isn't compatible with address re-use, but it's a much smaller modification to the existing code.
@_date: 2017-07-08 23:00:16
Thanks!  And coming up with the paper is hardly work.  Programming it all, that's the part that's work :)
My guess is that cryptographic oracles will be something of a natural monopoly; if there are a couple big oracles that report everything and are reliable, everyone can just use those.  (For free and without the oracles knowing) This design doesn't prevent the low number, but tries to minimize the negative impact of an oracle oligopoly.
I think it will have a real world reputation attached to it.  For example an exchange could report their prices with this method.  In the current setup, the exchange can already run off with everyone's coins, so trusting it to report accurate prices seems like a significant reduction in required trust, especially to those already having funds on the exchange.
@_date: 2016-05-18 00:29:27
Given two different signatures from the same public key, signing the same message, it's not possible to determine which used RFC6979 without access to the private key.
You can determine that at most 1 of them did.  Maybe neither.  Can't be both, because they're different.  RFC6979 is a good idea but nobody can tell if you're using it.
@_date: 2017-07-11 17:48:20
Obviously *I* don't consider my worldview wrong :)
It all hinges on the "we" in "we decide what Bitcoin is and not the miners".  Who is we?  "We" is really hard to figure out in the identity-minimized network that makes up Bitcoin.  I agree that miners don't set the rules, but I don't see how bip148 or 149 differ in allowing miners to produce blocks without validating.
It's technically trivial for a miner to set bit 1 of their version field and otherwise ignore segwit.  But that means the miner is setting bit 1, and thus actively agreeing to segwit, which it seems they don't want to do.
With bip149, they can pretend that they disagree, and ignore segwit entirely, and still be able to tell people "yeah segwit is stupid, we don't support that!" with a straight face -- something they can't do if they start asserting bit 1.
I agree this is really dumb!  But I think it's more likely to work with little disruption.
If you really want to decide what Bitcoin is and not deal with miner oligopolies, it's pretty straightforward: change the proof of work.  Instantly destroy all the ASIC capex and NRE with the stroke of a key.  But... that change also hinges on who "we" are and how to define and coordinate "we".  If it were simple, "we" would have already done it.
@_date: 2015-11-07 18:43:33
You don't **need** a malleability fix to implement lightning.  You can make a limited version using just op_cltv.
But having a fix like sighash_noinput makes it much more efficient, and helps with usability and reliability.  (Users would be able to trustlessly outsource revocation) 
Sighash_noinput can be implemented as a soft fork, either as P3SH mode, or a new sighash opcode, but implementing it as a hard fork is a lot cleaner, code-wise.
@_date: 2017-07-03 21:02:10
This is a really cool simulation, thanks for coding it up.
My guess on how this would differ from an actual deployment of LN:  Mostly this simulation is very uniform.  Which gives a good idea but in real usage many things will have a power law distribution.  I think 14 channels per node is actually quite high, and higher than we'd see in practice, but it will be unevenly distributed.  Uneven distribution, where some nodes have 2 or 3 channels, and some nodes have 50 or 60, makes the path length much shorter.  In the spec there is a max distance of 20, which I think is overkill as I doubt there will be any real payments which go more than 8 hops.
It's encouraging to see that even in a simulation with a very challenging setup (uniform degree for nodes) the network can still route payments with pretty good reliability.
If I knew any OCaml I'd try to extend the code on github but I've never seen it... looks cool though.
@_date: 2017-07-11 11:58:14
They don't get any of it; the transaction just sends all the money to addresses you control.  This is good and bad; there are no direct incentives / rewards for them to monitor the blockchain for you.  But they might still do it if they are your customer / merchant / exchange partner / whatever, and the marginal cost of monitoring is small.
People say lots of crazy stuff about lightning.  To me the whole point of developing it is that it allows people more control of their money in situations where today they don't have that control (eg exchanges).  I think the other people working on LN (Rusty / roasbeef / Acinq) have the same idea.
@_date: 2017-05-18 16:41:48
I'm not advocating a PoW change; I actually have very little say here. (which is good). I'm just saying that *eventually* if mining power gets too entrenched and non-competitive, and actual users want different things from the miners, the users will probably leave.
I don't think sha3 is a widely held candidate; I think on the mailing list the best idea for an alternate PoW was something like 100 rounds of blake2b.  (I also agree that would probably make the most sense)  But many don't like discussing it on the dev mailing list because the whole thing would be such a disruptive mess.
@_date: 2017-07-11 03:19:24
This is from a while ago; it's implemented in  but there's still a bunch of work left.  
You can ask another node to monitor your channel, in case you go offline.  They don't learn the details of your channel or payments made within it.
The newer revision is such that they don't even learn which blockchain / coin your channel is on.  So you ask the watcher "Hey what networks do you use?"  They reply "Bitcoin, Dogecoin, Litecoin", and you say "OK, cool, watch this channel for me: [bunch of random looking data]"
If they even see a fraudulent channel close on any of those networks which matches your data, they'll grab all the money for you.
The multi-coin thing is something of a gimmick as I'm not super enthusiastic about 5,000 altcoins, but maybe they can be a useful testing ground for outsourcing / anonymity.
@_date: 2017-07-08 21:38:38
Hey- I've heard of that! :)
Here's [the paper]( which is unfortunately not linked in the article.
feedback / questions welcome
@_date: 2017-07-11 17:27:11
It may be possible but it's not so simple.
Monitoring is blinded, so the watcher doesn't get to see the transactions, or see where they're coming from, and how many coins are moving.  So the costly part of monitoring (storing blinded transaction data, trying to match txids to the set in the database) would have to happen without knowing about the reward.  The cheap / rare part (reconstructing and broadcasting the tx) would be the only thing with incentives.
This would also prevent the monitoring data from being passed around between nodes.
There are probably ways to get it to work but it's not as straightforward as it might initially seem.
@_date: 2016-07-11 23:51:49
The chart linked has data that extends to around 2011, which is 5 years ago.  In the last 5 years, hard drive prices per byte have not gotten significantly cheaper, as can been seen in [this chart with more recent data](
We had 2TB drives for about a hundred bucks 5 years ago.  By this exponential extrapolation we should have 20TB drives for about a hundred bucks today.
For better or worse, Moore's law is over.  If we find some new technology which enables a return to exponential growth, great.  But we can't rely on continuation of Moore's law to solve these problems.
@_date: 2017-07-06 15:47:59
I think bip148 sets a bad precedent and has the potential to be messy.  Possible outcomes:
* bip141 activation before bip148 deadline.  One chain, segwit is activated, fees drop.  Cool, the 'threat' worked.
* Aug 1, majority of blocks assert bit 1, minority of miners enforce bip148.  Chains diverge.  Core nodes are on majority hash power chain, bip148 nodes are on minority hash power chain, eventually both chains have segwit active.  Possible big reorgs.  Sounds like a mess, no?
* Aug 1, minority of blocks assert bit 1, minority of miners enforce bip148.  Chains diverge.  Core nodes on majority hash power chain, bip148 nodes on minority hash power chain, bip148 only has segwit active.  Also a mess.  Possible big reorgs.
* Aug 1, minority *or* majority of blocks assert bit 1, ~no miners enforce bip148.  Still just one chain; Core nodes don't notice anything, but bip148 nodes see the network halt.  Actually not that much of a mess as the bip148 users just have to download Core to see the network operating.  May further delay segwit activation.
I like the idea of bip149 better.  Bip148 is **requiring** miners to agree with something.  Think of it from the miners' perspective.  That's no fun, and it's not an agreement if it's forced.  It's sortof like the "New York Agreement" thing.  I didn't agree to that -- nobody even asked me.  That's [Ethereum style consensus](
Granted, it's different with miners, because they get **paid**.  So it would make sense that they would have less say in what code to run than non-mining users.  Carrot is better than stick though.  Bip148 is saying "do exactly what we want, or you're fired!" where bip149 says "Hey, if you upgrade to this new software, we'll pay you more!  If you don't, that's OK too."  If a miner wants to save face and pretend segwit doesn't exist, they're free to do so.  They can even write "AD8/EB9/ZG2" or some such in their extranonce field; no problem.
Bip149 isn't requiring them to do anything they weren't already doing.  Miners **can** cause a chain split by actively modifying their software to make invalid segwit transactions.  So bip149 with a minority of mining support could also result in a split if the miners actively try to cause the split.  But that's on them.
Anyway that's my take on bip149 / bip148 which is a mix of technical &amp; philosophical preferences.
@_date: 2015-10-18 02:46:13
Number of nodes is not at a 6 year low.
I don't think anyone has precise numbers for back then, but there were not many nodes in October 2009.  6 Years ago, the difficulty was 1.  1000 nodes CPU-mining would have resulted in higher difficulty.
If OP has data supporting this assertion I would appreciate a link.
@_date: 2015-10-05 00:21:23
I agree; Segregated witness is certainly a better system once it's up and running.  Transitioning from the current txid setup to Segregated Witness is tricky though.
One risk of SIGHASH_NOINPUT being adopted first would be that it may reduce motivation for adoption of segregated witness, which would be disappointing.  So it seems like a trade-off: SIGHAHSH_NOINPUT could likely get in to nodes quicker, segregated witness would probably take longer.  If either gets adopted, it reduces the likelihood of the other being adopted.
I'd personally like to see NOINPUT get in sooner, and then segregated witness into a later hard-fork.  Both have their advantages.
@_date: 2016-07-03 14:09:50
Technically yes; once you've generated the public key from the private key, there are two acceptable ways to encode this public key: compressed and uncompressed.
A public key is just a point on the curve.  The curve (which you can kindof visualize like [this]( is symmetric about the X-axis.
Uncompressed encoding has 32 bytes for the X-axis value, and 32-bytes for the Y-axis value, resulting in a 64-byte pubkey.  (Which is acutally a little longer due to inefficient encoding)
Compressed encoding has the X-axis value of the point, and then just a 1 or 0 for whether it's above or below the X-axis, so it's only 32 bytes. (well actually 33 as that 1 bit takes up a whole byte, 0x02 or 0x03)
Bitcoin accepts either of these encodings for public keys in the script.  When you hash a public key to make an address, hashing the two different encodings results in different addresses despite it being the same private key, and sortof the "same" public key.
There's pretty much no reason to ever use uncompressed though and it wastes space, so really there's only 1 address you SHOULD have per private key.
There are other ways to generate multiple addresses from one private key (eg 1 of 1 multisig p2sh) if you really wanted to for some reason, but I can't think of any useful reason to.
@_date: 2017-06-24 15:57:22
Sure, and it only really works if they refuse to mine on top of blocks that include the types of transactions they don't like.  That's a softfork, perhaps a unilaterally miner activate one (UMASF?)
I'm not worried about something like that because if it ever got to the point where miners were coordinating consensus changes to freeze utxos, users will just switch the proof of work and "fire" the miners.  It's not even really a choice at that point; one chain is "PoW change with messy hard fork", the other is "you lost all your money".  I think miners are smart enough not to go there.
@_date: 2017-06-24 13:10:26
When things are working well (hopefully the vast majority of the time) you won't be able to tell a transaction involves a lightning channel, even when it's closing.  So miners don't really have a way to "reject" the transactions.
The transaction to create the channel just sends to a (segwit) P2SH type address.  So nobody can tell what those are.
When both channel parties are online and cooperative, the closing transaction is just a normal 2 of 2 multisig, so no way for the miner to tell there either.
Caveat: When someone goes offline or becomes uncooperative, you can unilaterally close the channel.  That commitment transaction is maybe detectable (single input with 2 of 2 multisig, two outputs; one p2pkh, one p2sh).  The subsequent transaction to get your money from the OP_CSV time-locked p2sh output does clearly indicate that it was a channel, but that's after it has closed.
Other caveat:  If you advertise that you have a channel to the public, miners could get that data and refuse to mine closing transactions.
It would be a lot of work and I doubt any miner would even try though.  Do miners oppose transactions sending to and withdrawing from exchanges?  Those transactions allow many trusted off-chain transactions to occur.  To my mind miners opposing LN channels makes about as much sense as opposing, say, Gemini.
@_date: 2017-06-24 13:14:51
Your counterparty could broadcast any of the previously signed channel states whenever they want.  So you have to remember how they revoked each one.
While you do need to remember a secret for every previous state, you can store these secrets in a kind of backwards merkle-tree so you only need log(n) space to store n secrets.  So the space needed is minimal.
@_date: 2017-06-05 04:35:46
Shameless plug of a paper I put out Friday:
[Discreet Log Contracts](
Futures contracts settled in Bitcoin.  It does use a trusted oracle to report prices, but the trust required is quite limited.  The oracle never knows if anyone is actually using its data.  Treats signatures as private keys which is a fun trick and *probably* works, but would certainly like some peer review.
@_date: 2017-06-12 22:13:09


No it doesn't.  You need to store a series of previously revealed secrets in order to create penalty transactions, and this is O(log(n)).  So if you have 1 million previous states, you need to store 20 hashes (binary log of 1M) of 32 bytes each, which is 640 bytes.  1 billion states, 960 bytes, and so on.
Also you can export this to 3rd parties if you're offline so in theory you wouldn't need to keep track of the old secrets.  But they're so small that there's no reason not to.
@_date: 2017-06-25 13:36:33
I'm not assuming anything.  I wrote exactly what I believe the appropriate and very likely response would be to miners freezing utxos: everyone switches to node software with a different proof of work.  It's easy to code; nearly every altcoin changes the PoW.
The current gridlock is very different; nobody's money has been confiscated.  If miners attempt to destroy users' funds, there won't be much argument that they are providing "security" to the system, especially to users who have their funds destroyed.  The  messy part is the coordination to make sure that everyone switches to the same new chain.
@_date: 2017-06-27 19:00:46
Anonymous FUD?  Why bother to respond?
... yet [I must.](
"To simplify the calculations, we will ignore the possibility that a branch on the tree could link to another branch already on the tree (such as an ancestor or cousin)."
Yeah, no, that doesn't work.  You could make a graph like that.  It would look [like this.](
That's... not what random graphs look like.  Random graphs have cycles.  Lots of cycles.  Lots of redundancy.  If one channel goes down, you can use another.
I don't want to oversell LN, as IMHO people overselling Bitcoin has led to a lot of the conflicts / arguments / misunderstandings.  But LN is not custodial, there's no debt, and scale-free networks work pretty well.
 
@_date: 2017-06-12 22:32:18
Aha, perhaps so.  Hopefully people can still see it.  It also clarifies that it's not even a few kB, it more like a few hundred bytes :)
(not that the difference matters when, as you say, you need to download 120GB first)