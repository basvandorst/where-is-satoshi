@_author: davecgh
@_date: 2015-12-14 01:14:34
Thanks for your numbers.  The machine I've been testing on definitely is not seeing that large of an increase.   The machine is admittedly a few years old and has an older Hitachi 7200RPM HDD and only 16GB of RAM, so clearly isn't anywhere near as powerful as the system you're testing with.
I took so long to reply since I just did a sync with 0.12 in order to ensure I have the most recent numbers.  My most recent attempt with 0.11.2 was last weekend and was through block 387028.  So, for fairness, I allowed 0.12 to sync through the same height.  Both instances have dbcache=12288.
Here are the results:
0.11.2: 20 hours 55 minutes  (1255 minutes)
0.12: 18 hours 15 minutes (1095 minutes)
So, 1255 / 1095 ~= 1.15x
There is no doubt that is clearly a very noticeable and nice increase, but it's not even close to the stated 4x improvement in the post I was replying to.  Even using your numbers, it's still only ~2.29x increase.  I stand by my claim that it definitely is not going to improve by 4x, even moreso for users with average to slightly above average hardware.
I also personally wouldn't classify going from just under 21 hours to just 18.25 hours on hardware that isn't top of the line as a huge improvement from the perspective of most users.  Don't get me wrong, it's an *extremely* nice improvement, and I'm not attempting to disparage the work at all, but for all intents and purposes, most of us will still have to effectively wait an entire day for the chain to sync.  From that perspective, it really doesn't make much of a difference.
EDIT: I should also point out that those times are significantly faster than the current btcd code in master, so I'm definitely not casting stones.  I'm just being realistic about what effects it will have on the average user.
@_date: 2015-12-08 02:41:13
Whether or not the features of the coin end up being a successful experiment or not remains to be seen, but saying it is a scam either means you're intentionally trolling or have a lack of knowledge in regards to the community and company involved.
As mentioned by polygonrobot, the company behind this is the same one that has developed [btcsuite/btcd]( which is one of the only viable alternative full node clients to Bitcoin Core and is widely lauded for its clean, stable, well-tested, and well-documented code.  The company has been developing btcsuite/btcd for something like 2.5 years now, so calling something that has further extended that project and brought several unique and non-trivial features a scam doesn't really make much sense.
@_date: 2015-12-12 18:25:06
This is somewhat accurate, but I want to point out that having faster signature verifications doesn't make a huge difference as that isn't the biggest bottleneck during IBD.
The main bottleneck is the massive amount of I/O it takes to step through every intermediate state of the utxo set in order to validate each and every transaction input, of which there are roughly 288 million as of the current time.  This is why increasing the dbcache size (which in effect lowers the amount of required I/O) and using an SSD as opposed to an HDD have such a large positive impact on IBD.
In other words, even though the signature verifications will indeed be a lot faster, the full observed sync time is most definitely not going to improve by 4x.
@_date: 2014-09-06 16:46:22
All things being equal, it is true that the performance of C/C++ can be made slightly faster than Go, however, that assumes that the code is using the exact same algorithms.
For example, btcd is currently faster than Bitcoin Core on the initial block chain download due to using a headers-first approach that is more efficient.  A user confirmed yesterday that it took him around 5 hours on an Intel i7 with an SSD to sync the full chain from scratch with btcd.  Bitcoin Core currently takes days.
I'm sure that won't be the case for long as Bitcoin Core is currently in the process of implementing a headers-first approach too, which will I suspect will bring that time down to something very similar, however, I wanted to illustrate that performance of a complex system is not completely dictated by raw language performance.
Also, another factor is Go provides outstanding concurrency primitives.  Even if performance of single-thread linear code execution is slightly slower, strong concurrency primitives which make it easier to implement parallelism and take advantage of multiple cores usually results in more code which actually does so.  The net effect, in the general case, is more code that takes advantage of multiple cores which leads to a faster overall system.
@_date: 2014-08-30 16:55:46
I didn't respond to it, because these long posts are quite time consuming and I'm typically extremely busy writing code that contributes to the ecosystem.  I don't really like to spend time engaging in these debates, because it takes away from time I could be using to that end.  For example, currently I'm working on a highly secure and scalable wallet address manager that, to my knowledge, is the first one to offer encryption of public data.  It's certainly the first one in Go if not in general.  However, instead of working on that right now, I'm on here responding to this.
Anyways, back on to the issue at hand, the problem is you *seem to be* intentionally wording things in the most negative light possible.  For example, given the exact knowledge of the issue you've posted in your reply with the facts as you currently believed them to be, rather than saying there was a bug at one point 3 months ago where a user was running a modified version of the code, you say things like "mysterious" and "innocent", insinuate it is a common occurrence, and *appear* to take every opportunity to latch on to any possible negative thing you can to spread FUD about btcd.  That is the perception that myself, and others who have sent me private messages, have gleaned from your posts.  For example, here is a quote from one pm that I received from somebody (not a part of the Conformal team) that said "10:37 &lt;******&gt; who is this midmagic?  he has a serious hard on for btcd..."
Meanwhile in the same time frame (since May 27th as shown in the linked pastie) there have been no less than 7 crashes reported on Bitcoin Core (including the most recent one with getutxos) which I have not seen you going on every thread about Bitcoin Core posting about.
* 
* 
* 
* 
* 
* 
Regardless of any of that, I'll repeat, I have no problems whatsoever stating that btcd has bugs.  It most certainly does, just like every other piece of software on the planet.  I'm actually quite happy when one is reported because it means we can fix it.
No, the user was not lying and I did not say he was.  I said that it was a mix of several modifications between the Go-runtime, the kernel, and the application itself that led to the crash.  When I said "I hope you don't honestly believe the garbage collection thing", I was referring to the way you worded it to insinuate that Go (and by extension, btcd) has an unstable garbage collector.  I've asked the user who reported the initial issue to clarify, so we can clear up any misunderstandings.
In regards to the additional implementations, Justus hit the nail on the head with his response.  I can't state it any better than that.  The mere existence of alternative implementations (note I'm not specifically referring to any one in particular here) has already led to several positive things such as greatly increased test coverage in the Bitcoin Core JSON test data itself, a pull-tester block acceptance comparison tool, work toward separating the core consensus script logic into a library, etc.
So, let's start with a clean slate.  I'm glad to see that you're *pro* alternative clients.  Your actions on the btcd threads have led me to believe otherwise, but I'm happy to be wrong about your stated motivations.
@_date: 2014-03-02 04:26:50
Another implementation, which is a full node implementation that does nearly everything bitcoind does is [btcd](  It is written in Go , has separate packages for all of the components, ample documentation, and is well commented.
There is also a blog post [here]( which discusses the architecture (though that blog entry is slightly dated, it is still pretty accurate).
@_date: 2014-08-30 18:53:05
Ah, thanks for clarifying!
@_date: 2014-08-29 02:49:46
The wire protocol is implemented by btcwire.  Visit  and click on the test coverage badge which is updated real-time with each new commit to view the in-depth, line-by-line coverage statistics.
Other fundamental packages such as btcnet ( and btcec ( have similar coverage.
As Justus pointed out, the code base is highly modular and the btcd repo itself is basically a daemon wrapped around all of the fundamental component packages.  The bulk of the test coverage, therefore is in the fundamental components which are what matter.
@_date: 2014-05-26 01:02:11
Thanks for pointing that out.  You are of course correct about the time frame.  I overlooked it because the issue was caught well before it ever had any effect on the Coinvoice service.  It was also fixed within 3 hours.
The commit which fixed the issue was committed "Tue Feb 4 03:13:23 2014 +0000".  The block timestamp was "2014-02-04 00:24:45".  So, to be exact it was fixed in 2h49m.
I'm going to update the blog accordingly.
@_date: 2014-09-21 18:59:17
Please open up on an issue on github as behindtext suggests.  I'd like to get your leveldb logs so we can work with the upstream goleveldb author to track this issue down.
@_date: 2014-11-19 02:26:49
This is a prime example of what the original post ended with.  "Part of keeping a system decentralized is to be wary of centralized decision making. Be wary of the ones who pull the strings."  The only people really still pushing this fallacious argument anymore are those heavily involved in Bitcoin Core.
Let's assume for a moment that a group of individuals decides to follow this advice. So, they start with the Bitcoin Core code base.  Now, in the forked version, they clean the code up, refactor it, and update it to use more modern coding practices. Being humans, having no spec, and a code base with very little test coverage, the updated code accidentally breaks a few consensus corner cases that go unnoticed. They also decide to add some new features users desire which allows this new forked version to become popular.
The threat model is the nearly the same, if not identical.  In fact, history has already shown that you don't even need to fork the code base to cause a chain fork.  Bicoin Core has already forked against _itself_ though that is conveniently left out of the argument.  The point is that mistakes can be made which cause a fork which points to the fact that the consensus mechanism, as it is implemented today in Bitcoin Core, is more fragile than it should be.  The more important part is improving the ecosystem to identify all of these supposedly unknown issues that makes it so unsafe which in turn ultimately _reduces_ the chances of it happening again in the future.
Further, there is more than one way for a miner to mitigate the risks to begin with.  In fact, it would be in miner's long-term best interest to setup mitigation so that future accidental forks within Bitcoin Core itself can be handled gracefully unlike the one that has already occurred.  Those same mitigation techniques extend to alternative implementations.  The combination of miners properly setting up their infrastructures to mitigate risks and the fact any issues can be fixed rapidly, means that the forks those pushing this argument are so afraid of today, can essentially be made a non-issue.
@_date: 2014-05-26 01:09:35
I've added an edit to the blog which calls this out.  Thanks again for catching that.
@_date: 2014-09-21 20:34:19
The release notes call this out:
"NOTE: CPU mining on mainnet is pointless as the difficulty is far too high. This has been provided for testing purposes such as for the new simulation test network"
It is extremely helpful for developers that are doing simulation testing and other work such as testing theories with alts which change the block structure such that existing miners are incapable of generating valid blocks.
Also, keep in mind that it is disabled by default and therefore not eating any cycles at all.
@_date: 2014-08-29 16:22:04
btcd works great on mac, however it is just the core daemon.  I'm guessing from your post that you're actually referring to a GUI wallet, and in that case, you are correct that we don't have a realistically usable GUI wallet like Armory/Bitcoin-qt.  btcd intentionally does not have the wallet integrated.
@_date: 2014-09-03 14:19:21
I believe it is normal during the initial block download.  An inbound node will connect, notice your node has a chain that is way far behind the rest of their connected nodes, and disconnect.
You'll also see a lot of inbound connections from crawlers that connect, gather some information, and disconnect right away.
@_date: 2014-05-26 01:03:24
There have been no forks as a result of btcd mined blocks.
@_date: 2014-09-02 17:06:18
 Thanks for posting this.  I did notice you have an extra space after the final slash in the `go get` command in step 2.  It should be:


It still works with the extra space, but then you're only building the `btcd` binary and not the utils (`addblock`, `btcctl`, etc) which are in the subdirectories.
Also, it is possible to use Debian stable if you download the Go source and compile it from   However, I agree that it is easier to install when there is a new enough pre-compiled Go package available such as in Jessie.
@_date: 2014-05-26 04:52:31
That's a pretty broad question.  Speed could refer to any number of areas. Are you asking about how quickly it can verify signatures, how quickly it downloads the chain to the final checkpoint, how quickly it can fetch a block from the database, etc?
In general, btcd is faster at certain things, and the original bitcoin client is faster at others.
For example, since btcd supports headers first downloads and has a checkpoint that is later than Bitcoin Core currently has, btcd can download the block chain quite a bit faster.  Btcd also has a highly optimized crypto package that is specifically tailored to secp256k1 which is faster than OpenSSL.  This may have changed without me noticing, but I believe Bitcoin Core still uses OpenSSL for the secp256k1.  However, I believe there is a faster library that will probably be switched to at some point which will likely close that gap.
On the other hand, Bitcoin Core currently generally has faster database operations since the C++ leveldb implementation is better optimized than the Go implementation.  This is something we plan to improve in the future, but that's really more of a benchmark game than anything at this point in time since the database speed difference really isn't all that noticeable for most use cases.
@_date: 2014-09-03 00:27:22
You should watch the linked talk by Gavin in acoindr's comment.  He specifically addresses why this argument is short-sighted and why there needs to be multiple implementations in the long run to _increase_ the robustness of the entire network and ultimately reduce the chances of this type of thing from happening.  Let's not forget that Bitcoin Core (bitcoind back in those days) has already forked against *itself* proving that a single implementation does not solve the issue.
I agree getting to the point Gavin discusses will be challenging, but that's why it's important we embrace changes that are ultimately better for the overall Bitcoin ecosystem instead of actively discouraging them.
@_date: 2014-08-29 14:38:06
I hope you don't honestly believe the garbage collection thing and are simply continuing on your alt implementation prevention campaign.  You are of course free to continue to put forth your viewpoint, but please do so with the actual facts.
The "issue" you are referring to was not inserting a GC call into some innocent place.  It was a user making code changes on a custom kernel and patched Go run-time.  Your argument here is akin to me running a modified kernel, a modified version of C++, opening any given project's codebase, adding a free(nil) call in a completely "innocent" place, and posting in an IRC channel that I modified the code and ended up some having some "mysterious" segfaults.  Then, having another 3rd party user [midmagic] who happened to see my IRC message completely out of context, go onto reddit and claim that the project and/or C++ is the cause.
That said, I'm fully aware, have stated publicly many times, and will continue to do so, that the btcd code base is not bug free. *NO* code base is bug free.  While it's true that it is an extremely clean, well-tested, and well-documented code base, that does not exempt it from bugs.
I have stated publicly more times than I can count that we are fully aware of forking risk.  It is not that we don't care, on the contrary, it's that we *DO* care *deeply*.  The fact of the matter is, even with having a single implementation, it has *already* forked against *itself* and it's going to happen again unless the entire system is strengthened.  Strengthening the system against alternative implementations is *also* strengthening it against new versions of Bitcoin Core itself.  I know the standard arguments like to conveniently ignore this fact, but it is true nonetheless.  The end result will be a huge win for the entire ecosystem.
@_date: 2014-03-09 10:01:34
I can't answer on behalf of behindtext on all of the points, but I would like to offer a correction on the point of attribution to bitcoind.
You claimed that you pointed out ten examples of non-attribution.  The very first statement on the public btcd RPC API wiki states "btcd ultimately aims to provide a JSON-RPC API that is fully compatible with the original bitcoind/bitcoin-qt".  The RPC interface is specifically being made to match bitcoind for the express purpose of allowing btcd to be a viable alternative that existing infrastructures can make use of with minimal to no changes.  Thus, every single instance of an RPC, which is almost every instance you listed, is in fact, attributed.
Also, while you are indeed accurate that certain behaviors surrounding what is, and is not, considered non-standard are not consensus critical, let's not leave out the important part.   Anything that is considered non-standard is not relayed by bitcoind which comprises pretty much the entire network.  As a result, alternative implementations, particularly those which don't having mining support, don't have a choice but to match bitcoind on what is considered standard if the transactions are to ever realistically make it into a block.  Naturally, one could argue that the non-standard transactions could be sent directly to a miner, but realistically speaking, for the average user, that is not how the network functions.  Until there is more diversity on the network, that will continue to be the case.  I realize I'm not telling you anything you don't already know here.
In regards to the HasCanonicalPushes, if you follow through to the issue referenced from the commit, it has "Make signatures with non-canonical data pushes non-standard, to match bitcoind."  Another recent example is the commit   Notice "This mirrors a recent change in the reference implementation" is the first sentence.  Attribution to bitcoind has most definitely been provided all over the place such as in the code itself, in the commit messages, and via the issue tracker.
In regards to bitcoin-cli, yes the cli functionality existed as a part of the daemon for years, but the actual separation into a separate utility is what I suspect IanCormac was referring to.  btcd split this out into a separate utility btcctl on **Oct 8, 2013** (  The separation into bitcoin-cli branch was started on **Oct 21, 2013** (
There are a more instances of the above, but I don't see much benefit to enumerating them.  All of that said, none of this is helpful.  I, for one, am sincerely happy to see that some of the improvements are making their way into the bitcoind/core.  Perhaps it's all a coincidence and we just see the same problems and end up coming up with the same solutions.  Either way, it's all a net win that the community benefits from.
Let's work together to improve the diversity and strengthen bitcoin for the entire community.  That is what everyone involved wants, right?
@_date: 2014-09-21 18:57:18
A quick clarification, it will use up to how many ever cores you have in the system after the final checkpoint rather than just 6.
@_date: 2014-10-25 20:26:47
The problem is that figure suffers from the classic micro-benchmark mistake of assuming some theoretical maximum based on a set of unrealistic assumptions is achievable when reality is a much different thing once real factors come into play.
I have done some parallel benchmarking of verifying the **same** signature.  As stated above, this  is not how it really works when in production and therefore is biased heavily in favor of a theoretical maximum which is never actually achievable.  Keep in mind this is 100% discounting everything else that has to happen such as loading the signature from disk, deserializing it, batching it to the verification threads, and so on.  It also means major speedups you see on micro-benchmarks like these due to things like signature caching, memory buffers, and TLBs in the CPU don't actually happen in a real functioning system.
Nonetheless, I did the following raw benchmarks with both OpenSSL and btcec (the crypto package from btcd that is highly optimized specifically for secp256k1 and is quite a bit faster than OpenSSL for secp256k1 calculations as a result) using two different CPUs.
The first is an AMD FX-6100:
btcec: 3900 verifies/s
The second is an Intel Core i7-4770:
btcec: 8997 verifies/s
The results for the Intel CPU are very telling since the CPUs mentioned in the wiki and the one used for this test are quite similar.  Using the same logic in the wiki, with an average of number of inputs per transaction around 2, halving those numbers means ~4500 verifies/s for btcec.  As you can see, btcec is even exceeding the value set forth in the wiki as far as signature verifications per second when doing these micro benchmarks.  However, once everything that has to be done in a real, functioning system comes into play, those theoretical maximums go out the window.
@_date: 2014-08-31 02:37:33
What?  I did not reverse stances.  For the record, the "issue" was resolved a _long_ time ago (not long after it was reported).  That you didn't know this, even though I all but explicitly stated that in my opening reply, is more evidence to support what I've been saying the entire time in regards to you bringing up an old issue, that wasn't really an issue, without having the facts.  It was ultimately due to a custom sysctl, hence my reference to a custom kernel, which was my attempt to keep it at a reasonably high level to avoid confusion.  In other words, it's not an issue as I can make anything crash with custom modifications, which was the point of my original little comparison.  I added the extra information about the patched Go-runtime and additional code modifications to further illustrate the point that you picked some super random "issue" you happened to see on IRC without having all of the facts and have since been trying to use it as a way to influence others against using btcd.
In regards to the free(nil), I meant attempting to free a pointer that is pointing at unallocated memory.  You are correct that I did not use the proper syntax.  It should have been free(unallocated); where unallocated is not initialized and therefore pointing at unallocated memory.  Good catch on my mistake there!
It's FUD, because you are trying to make users fear using btcd and doubt its stability.  You, me, and I suspect the vast majority of the people reading this thread, know exactly what you're doing.  I'm not implying anything about your contributions.  I don't know anything about you except that you show up in nearly every single thread about btcd and post negative comments.
I have also stated many, many, many times, that I do *NOT* want btcd to completely supplant Bitcoin Core.  The ecosystem would be no better off in the long run having the majority of users  on *any* single implementation, regardless of which one it is.  I want a good mix of implementations.
Anyways, I'm not wasting any more time on this.  Regardless of what I say, you try to take it and spin it.  I think it's clear to anyone reading you have a bone to pick, contrary to your stated motivations.  Good day, sir.
@_date: 2014-09-02 22:18:45
I'm fairly certain that is a mistake in the guide, since you don't need to be root for `go get`.  All dependencies are downloaded into the path the `$GOPATH` environment variable points at.
Here is an example against a completely fresh home directory running as my normal user account:






EDIT: Note the above was run on OpenBSD, not Debian, but there is no reason it shouldn't be the exact same.
Also, I also think it's pretty cool to notice that it downloaded btcd and all of its deps, built the entire application and accompanying utilities, and installed them to the `$GOPATH` in just under 48 seconds.
@_date: 2014-10-25 22:35:07
Interesting you're seeing figures that high.  Do you have code for those benchmarks available?  I'd really like to see how it compares on my hardware.  I have not spent any time with libsecp256k1, so perhaps it is indeed orders of magnitude faster.  I can however say that on the same machines benchmarking OpenSSL with C code versus btcec results in btcec being quite a bit faster than OpenSSL.
I agree there are still two optimizations can be made in btcec in regards to WNAF and the endomorphism.  Both have issues open  and pending pull requests ( 
There is nothing unique or novel about the concepts employed in btcec in regards to the field math.  The field representation in particular is described in section 5.1.1 (Software Implementation -&gt; Integer arithmetic) of the Guide to Elliptic Curve Cryptography [GECC].  The fast modular reduction techniques come from the Handbook of Applied Cryptography ( [HAC] section 14.3.4.
Here is a direct quote from [GECC] section 5.1.1:
"The cost of carry handling can be reduced in some cases by use of a different field representation. The basic idea is to choose W' &lt; W and represent elements as a = Ea_i^2W'i where |a_i| may be somewhat larger than 2W' âˆ’ 1 (and hence such representations are not unique, and more words may be required to represent a field element)"  It further goes on to discuss normalization of said fields.  The choices in btcec were based upon this and described in the comments in detail here: 
Further references are:
* Fast modular reduction due to the special form of the prime --  -- [HAC] section 14.3.4
* Addition comes from section 2.3.1 [GECC]
* Multiplication comes from section 2.3.3. [GECC]
* Squaring comes from section 2.3.4. [GECC]
* etc...
Moving up to the group level, also described in detail in [GECC] chapter 3, the optimizations used came from hyperelliptic.org and are referenced in the code:
* 
* 
* 
* 
* 
* 
@_date: 2014-05-27 19:54:25
We had a Bitcoin Core node running and ensured all blocks generated by btcd were accepted by Bitcoin Core (via submitblock).  This node was isolated during this testing to avoid any issues should anything have gone wrong.  There were several blocks other than this specific block and none of them, including the referenced block, had any issues being accepted by Bitcoin Core.  Further, we also manually examined all of the blocks to ensure they were accurate before even submitting them to Bitcoin Core.
You are correct there was a large reorg around that time frame from what appeared to be somebody testing large reorgs with an ASIC farm.  Multiple blocks per second were showing up.  However, that had nothing to do with any of the btcd blocks.
Let's assume for a second that there was something wrong with the block.  There wasn't, but as a thought experiment, let's assume there was.  For a fork to occur based upon a block submitted by anyone (regardless of how it was created), it would have meant that some *Bitcoin Core* nodes on the network thought it was valid while others did not.  If that were the case it would mean there is a major problem in the Bitcoin Core consensus code and anybody wanting to be disruptive to the network could churn out these bogus blocks and cause forks all over the place.  That clearly is not the case, so there is no way the block could've caused what you're suggesting even if it were invalid in some way.
There are still several of those original blocks in the testnet chain which did not get reorged out.  For example, here are three:
@_date: 2014-09-01 01:19:33
Thank you for finally confirming you are here for the specific purpose you originally tried to say you're not.
I was not going to respond anymore, but now that you have asked specific questions, I will answer them in turn:


Yes, insofar as it was not a btcd bug to begin with.  The user has been, and continues to, run btcd on his systems today without issue.


I pinged the user to come onto the thread and clarify the specifics because you clearly try to spin everything that I say.  I was hoping that the answers coming from the original user that reported it would diffuse you.  Yes, of course we have been aware it was resolved for months, hence why I was so confused why you keep bringing it up.  I don't know if the user will respond or not.  At this point, it's clear that anything anyone says you will attempt to spin, so I wouldn't blame him if he chooses not to reply at all.


How could I "just tell you" when I didn't even know that you thought the bug was still unresolved until your most recent post?  All of your posts up until that point are worded such that you were using it as a smear campaign.  I thought it was more than obvious when I led with the **past tense** construction "The bug **was not**", that it was resolved.  Most unbiased, and reasonable people, would immediately recognize that past tense construction to mean something that is not still ongoing.  It wasn't until you finally decided to start asking questions about it being unresolved, that I realized you didn't know it had been resolved.


We worked directly with the user in IRC.  As soon as the issue was discovered to be an OpenBSD issue, rather than a btcd issue, there was no need to open a bug in btcd about it.






I already answered this in my last post.  I was attempting to keep the discussion at a high enough level that it was not confusing to people reading a **Bitcoin** reddit thread, not a thread about the specific details of *Operating System* kernels, however, I will agree with you in hindsight, I should have explicitly added the word "parameters".  That said, a custom kernel, as opposed to a stock kernel, could either mean that the kernel source has been modified (yes, this is the typical meaning), or it is running custom tuned parameters, which is the case here.


I already answered this in my last post too.  This is where you are again, twisting my words.  I did NOT blame the patched Go-runtime.  I pointed it out as one of the many pieces that were involved with the issue and used it as an example of things I could do to cause any number of applications to crash while somebody with a self-admitted bone to pick (you) will then take it and try to use it as ammunition in their crusade.


So, wait.  You are saying that something that causes segfaults regardless of the application, is the fault of the application?  Hold on a second while I go setup a VM with 256MB memory (this is how much the machine in question had and part of why the user was tuning things downwards to begin with), and tune some parameters that cause Bitcoin Core (and other applications) to segfault(!) and wait for all parties involved to say it's the fault of Bitcoin Core.  Fantastic argument!  Oh wait, you already dismissed something similar to this where the user's hardware was faulting in your last post.  Your hypocrisy is absolutely mind-blowing.
The "funniest" part of all this is, you clearly don't know me at all, because if you had picked anything that was a legitimate issue with btcd, I'd have no problem whatsoever saying that yes, it was/is a bug, and stating the current status of it.  I don't know how many times I have to repeat myself with you.  Every piece of software, *including* btcd has bugs. I have never claimed otherwise.
The problem here is you didn't pick a legitimate issue to hang your crusade on, and now you're trying to logic debate your way out of it instead of manning up and simply saying "my bad, I thought it was a legitimate bug that was still active".


Really?  So according to you, we haven't given any credit.  Let's see.














How about in the source files?












Clearly, we've cited and given credit to bitcoind/Bitcoin Core/reference implementation **at least** 37+22+79+17+8 = 163 times.


Your definition of encouraging is obviously not the same as the one in my dictionary.  The only thing I've done in this thread is answer questions and dispel your misconceptions, inaccuracies, and general vitriol along with calling you out on your shenanigans.  Please link me to anywhere I've said anything of the sort.  In fact, I've already said "that I do *NOT* want btcd to completely supplant Bitcoin Core".  That is the exact opposite of encouraging people to push for that.
Further I stated in another response on this post, "you are correct that we don't have a realistically usable GUI wallet like Armory/Bitcoin-qt", again pointing out the weaknesses.
@_date: 2014-08-16 07:02:45


I think your statement touches on a big reason *why* we need alternative implementations to help grease the wheels toward changing the current state of affairs where this is even a concern.  I believe that having alternate implementations will ultimately force solutions that are not as fragile as the current system.  The Bitcoin ecosystem needs the network to become robust against this type of thing.
For example, here is a possible scenario that could happen that isn't really too far fetched.  A group of individuals forks the core client and adds a couple of really desirable features that don't exist in the current code.  At the same time, they decide to refactor and clean up the script code and in doing so make a tiny mistake in some corner case which breaks the consensus, but it goes unnoticed for months.  In the mean time, since this fork has really desirable features, it will likely gain a large user base.  Everything is going great until months later, some new feature is added to either fork which ultimately ends up triggering the consensus break.
Let's also not forget that the bitcoin core client even forked against itself between versions in the past.  So, it should be clear that it doesn't take an alternative implementation to cause issues.
The bottom line is the system is currently too fragile and tackling that fragility head on rather than waiting for disaster to strike is really where I believe the focus should be instead of trying to actively discourage other implementations which will ultimately force the system to adapt and be a lot better off for it in the long run.
@_date: 2014-03-09 11:10:10
Allow me to be more clear then since it appears my post was not.  I am hereby loudly refuting the overstated claim that over half of the changes in 0.9.0 came from btcd.  That is clearly not the case.  I hope that clears up any misunderstanding.
You specifically asked for an example of a change that wasn't made to Bitcoin core first, which is exactly what I did.  I reached out to you with a mature and accurate post which provided what you requested with links.  I'm a little saddened that I offered an olive branch and your post still feels combative.  Hopefully that is just an artifact of the medium being text rather than your actual intention.
Honestly, I have better things to do with my time than go digging through commits about who added what first, or created a branch that sat for longer than the other.  Frankly, it just doesn't matter to me as it's not a competition to me.  Both bitcoin core and btcd are fine pieces of software each with their own strengths and weaknesses.  That diversity is exactly what I want to see more of for the bitcoin community.
This will be my last post on the matter as I will be busy writing code and have nothing further to say on the topic.  Have a good night and I'll say again that I hope we can work together as things move forward.
@_date: 2014-09-21 20:35:59
btcd was also around for a long time before bitcoindark came around and it's unfortunate they didn't take the time to do a quick name search before creating a confusing name collision.
@_date: 2014-05-27 20:40:50
I'll have to disagree with you there.
All blocks mined by btcd are run through the exact same consensus validation code path as blocks coming from the wire.  And as I already stated above, the blocks were also submitted via Bitcoin Core through submitblock.  If there were any discrepancies, it would have been immediately obvious as we would've seen the block rejected by Bitcoin Core and accepted by btcd (or vice versa, but a block rejected by btcd would fail the mining process and never be created to begin with).  That did not occur on the block in question nor any of the blocks mined.
Also, this block, and all of the blocks I linked, were released *before* btcd mining code was ever made public.  You are suggesting that somehow code that was not released, was intentionally being run in isolation, and was not consistently competitively mining during this period managed to cause issues against the 95%(?) majority implementation across hundreds of blocks.  That just doesn't make sense.
I understand that you and a few of the core devs don't like the idea of other mining nodes.  Let's not use that as a reason to try and lay blame where it does not belong.
@_date: 2014-09-03 06:22:34


I'm curious why this statement is thrown about so much.
Let's assume for a moment that a group of individuals decides to follow this advice.  So, they start with the BC code base.  Now, in the forked version, they clean the code up, refactor it, and update it to use more modern coding practices.  Being humans, having no spec, and a code base with very little test coverage, the updated code accidentally breaks a few consensus corner cases that go unnoticed.  They also decide to add some new features users desire which allows this new forked version to become popular.
How is that scenario any different than any other alt implementation?
@_date: 2014-05-26 13:51:19
The btcdb package already provides an interface for which any backend can be written.  I know one guy was playing around with a postgres backend.  There is already a memdb backend for testing purposes in the official repo as well.
I personally don't have plans to push for a mongodb backend because I don't like eventually consistent databases for financial data.  However, there is nothing stopping the community from providing whatever backends they desire.  Btcd was written in a very modular style to support exactly this type of flexibility.
@_date: 2014-09-21 19:16:13
Yes, I believe as of 0.9.0, btcd supports everything that Bitcoin Core (bitcoind) does plus a few more things that bitcoind does not yet.  Please note, that I'm talking about the core daemon of course and not the wallet or GUI as you pointed out.
One example is btcd supports headers-first mode on the initial block download whereas Bitcoin Core is sill working on it.  Another example is btcd supports websockets pub-sub notifications of new blocks and transactions while Bitcoin Core does not.
That said, I believe Bitcoin Core has branches under development that, if merged, will bring it very close to supporting the same additional things btcd currently supports that it does not.  All in all, they are really quite close in overall feature set.
@_date: 2015-05-07 20:11:00


It always amazes me that people will make blatantly erroneous claims without even bothering to spend 2 minutes doing some fact checking.
Let's quickly examine this claim by taking a look at the script engine, shall we?  Also, let's keep in mind that back in the time frame you're referring to, none of the Bitcoin Core (bitcoind at that time) script code was separated out like it is now, so it was an even bigger difference then...
**Bitcoin Core:**
Runs a big while loop that parses the opcodes on the fly and executes them inline via a big switch statement (
Parses the scripts up front into an array of parsed opcodes and uses an opcode array to map each opcode to a function which handles it (  etc).
Those are completely different approaches.  Obviously there will be similarities in many areas because they, necessarily, do the same things and have to maintain consensus.
Then there are other major differences like the fact btcsuite is much more modular with the protocol, database, script engine, chain processing, etc all being separate packages.  The Bitcoin Core developers are still working on modularizing their own code base to this day.
I guess our definitions of "line for line" differ, but I prefer to go with the definition provided by the dictionary.
@_date: 2014-11-19 06:23:04
@_date: 2014-08-29 22:43:22
I sense a bit of disbelief in your post.  Feel free to disregard this post if I'm misreading, but I can confirm behindtext is in fact the CEO of Conformal.  Feel free to see my handle on the btcd contributors list if you don't believe that I am qualified to confirm it: 
@_date: 2015-01-06 07:50:28
@_date: 2015-01-05 20:24:20
The problem is though, even with a consensus library, the issue still exists.  The same library compiled under a different version of the same compiler, or for a different operating system, or through the use of the different language bindings, etc... does not necessarily result in 100% exact same behavior.  In fact, the library compiled on the same machine with the same version doesn't even necessarily result in 100% exact same behavior.
That is what I've been trying to hammer home.  Such a core consensus library is not immune to forks either.  There needs to be something at a higher layer in the ecosystem which deals with this inevitability.  Once you have that solved, the entire debate about alts goes away, and more importantly, the Bitcoin network as a whole is much safer as a result.
@_date: 2015-01-06 09:03:12
No _miners_ should be running _any_ single implementation as their sole source on consensus, including Bitcoin Core.
EDIT: Running is a poor choice of words here.  I should have said _consulting_ as they don't need to physically be running something to query it remotely.
@_date: 2015-01-06 03:19:12
Did you read the article?  The point of it is not about reimplementations.  This comment is an exact example of the red herring that was discussed in the article.  Once again, the focus is being put in the wrong place.
In order to better understand, completely forget about alternative implementations for a moment.  Assume the only thing that exists is different versions Bitcoin Core.  There is _still_ no way to guarantee that a fork can't and won't happen.  In fact, it is extremely dangerous and naive to believe that throughout the rest of the life of Bitcoin, there will never be a mistake which leads to a fork like the one that has already happened.
The entire point of this post is that the focus and conversation needs to shift to the eventuality that a fork is going to happen before it actually does so that the infrastructure can handle it without taking down the entire network when it does.
Alternative implementations do not even need to enter into the conversation at all.
@_date: 2015-01-06 07:40:12
Well, what I've been trying to get across is that it's not for the benefit of btcd or any other specific implementation.  It's for the benefit of the network as a whole.  Just as the scenario described, it protects the network from forks and prevents disaster.  We are in completely agreement that we should minimize failures and that is what this is all about.
What is interesting is that when you take alternatives completely out of the equation, as I did above, everyone seems to agree that it makes sense why the ecosystem needs to strive to solve forking risk at a higher level and probably should be done in one form or another.
Let's keep the exact same scenario as previously mentioned and call Bitcoin Core 0.10.0 node A, Bitcoin Core 0.9.5 node B, and Bitcoin 0.9.4 node C.  It just so happens that if Node C is an Obelisk implementation, or a btcd one, the exact same properties hold except you gain an additional benefit of no longer being tied to a single implementation.  This is why I call it a red herring.  Why is it that the mere mention of an alternative implementation, when nothing else about the scenario changes, magically seems to take the focus away from the fact that the network needs to gracefully handle the situation regardless?
As stated in the article, I think a consensus library is a good idea and am glad to see it happening.  It's a solid preventative measure that makes sense to do, but I can't overstate enough that it's not a real or final solution and should not lull people into a false sense of security.  At some point, something somewhere in the Bitcoin Core stack, even with the reduced risk a consensus library brings, is eventually going to break in one way or another.  It really is inevitable that it will happen again, so why is it that the major players, who surely know this to be true, are basically sticking their head in the sand and saying "consensus lib will fix it!"?  Unfortunately, no, it won't.
Nobody can say with 100% certainty that a change to an OS disk driver, a newer version of a compiler, the latest and greatest quantum computers, a seemingly innocuous change to the consensus library code, or one of its dependencies, etc, will not cause just one single bit of difference which leads to a fork.  So what do we do when it happens?  I want to the ecosystem to be prepared now and put real preventative and restorative measures in place it before it ever does.
@_date: 2015-01-06 09:09:28
I can see that you really want to change the subject, but why aren't we talking about the the real problem -- The fact that Bitcoin Core has already forked, and will almost positively, at some point fork again, how the ecosystem is not prepared to deal with it, and what we should do to address it?
Notice in my previous post I said "Why is it that the mere mention of an alternative implementation, when nothing else about the scenario changes, magically seems to take the focus away from the fact that the network needs to gracefully handle the situation regardless?"  Your response did exactly that and completely abandoned the discussion about the subject at hand.
We were making good headway on the subject when you conceded that miners should probably be consulting multiple versions of Bitcoin Core.  I'm still waiting for some good discussion on approaches to make that a reality, potential pitfalls, etc.
If we're not going to discuss the real issue, I guess this discussion thread is finished as it adds nothing of value to discuss things that are completely irrelevant to the fundamental problem.
@_date: 2015-01-06 05:06:36
Not every consensus implementation, just more than _one_.  For example, I would be happy if the standard practice and infrastructure existed such that miners checked against the three latest verisons of Bitcoin Core.  
For a concrete example, we know that Bitcoin Core 0.10.0 is coming out soon.  What if there is consensus forking bug that slipped in there?  This absolutely can and _has_ happened.  If miners were checking against the latest version Bitcoin Core 0.10.0 as well as Bitcoin Core 0.9.5 and 0.9.4, both versions 0.9.4 and 0.9.5 would claim a block is either good or bad while the latest version 0.10.0 would claim the opposite.  The miner would immediately know that something was wrong.  They can then do several thing to avoid the fork from ever happening in the first place.  For example, remove the offending transaction(s) until all three agree.
Now, compare that against the current model.  Several miners upgrade to Bitcoin Core 0.10.0.  A block that is valid on Bitcoin Core 0.10.0 is built and submitted.  All of the older Bitcoin Core versions on the network reject it, but all of those running on Bitcoin Core 0.10.0 accept it.  This is a disastrous scenario.  Now you have significant hash power on both side of the fork competing and all sort of havoc that comes with along with massive amount of lost money.
Each individual full node still continues on exactly as it is today.  They are no more or less insecure than they are today.  They are not validating blocks multiple times.
@_date: 2015-01-06 01:13:33
I personally observe, and have been told by a few people that it uses around 4x less memory on average.
@_date: 2015-09-14 20:51:41
I completely agree about the need for multiple implementations.  We've been preaching this since we first started implementing btcd back in 2013 ( for those not aware) and is in fact one of the main reasons we started the project to begin with.  Unfortunately, most of the Bitcoin Core devs, and a large portion of the people who follow them, still disagree to this day and are very vocally are against multiple implementations, so it has certainly been an uphill journey.  Despite the protestations, btcd has been humming along fine for over 2 years now.
@_date: 2015-11-22 18:12:23
We are in favor of a block size increase.  Obviously we would prefer the community come to a consensus about the mechanism to enable it, but failing that we will most likely provide a flag to enable all parties involved to make a choice about which rule set they want to use.  Clearly such a flag, once enabled, would mean changing back to a different incompatible rule set would require redownloading the chain against the active rule set.
We don't believe that we, as developers, should be dictating economic policy.  Naturally, when there are technical issues at play, developers are generally better positioned to discuss the technical aspects of such changes so it generally makes sense to carefully consider their input as they will typically have a greater insight into the issues at play versus an average random user, however, when it comes down to it, all stakeholders will have to make the choice that is right for them.
Perhaps of note, we've been in favor of bigger blocks for quite some time.  We even wrote a simulation test tool back in Oct of 2014 to stress the limits and even back then, before many of the recent performance enhancements, the results clearly showed it is capable of handling larger blocks. The following link is an outdated blog post about it (many performance enhancements have been made since which would further increase the limits seen there): 
@_date: 2015-10-01 21:22:32
I'm a hesitant to make a guess on the percentage since I'm sure there are Bitcoin Core nodes out there that aren't reachable as well, so that would affect their total number of nodes too.  However, given that Core is typically reachable by default and btcd is not, the total reachable Core nodes is probably only a few percentage points higher than reported.  Making that assumption, perhaps it's closer to 2-2.5%.
Having been involved in the entire process of the reimplementing the consensus code, I can attest to the fact that it was fairly difficult to get right and has a lot of non-obvious subtleties.  Therefore, it is not something to be taken lightly.
That said, part of the difficulty when we were reimplementing it is the fact that almost the entirety of the Bitcoin Core (bitcoind in those days) code base was a massive hairball in a single file (main.cpp), had almost no comments, was completely monolithic (it still is in many ways, but is being improved), relied on fuzzy behavior of the underlying libs (OpenSSL signature parsing for example), had almost no test coverage, etc.
Fortunately, many of those things have since been improved and/or remedied.  The script unit tests (provided via JSON and thus btcsuite is able to test against the same set of data) have significantly improved over time and a consensus block tester tool was created that covers the majority of known chain-related consensus cases.  The combination of these things helps drastically reduce the forking risk between implementations (though it clearly does not eliminate it).  For example, our test coverage metrics show that all of the consensus critical script code lines are covered.  Of course line coverage of a scripting language does not equate to proving equality, but I say that as an example to show how far along the test coverage has come and that it seems that in practice implementations which pass all of them are not as dangerous as theory would have you believe.
As far as the block size, we are not opposed to raising the limit, but we don't want a contentious hard fork to do it.  We wrote a simulation test tool back in Oct of 2014 to stress the limits and even back then, before many of the recent performance enhancements, the results clearly showed it is capable of handling larger blocks.  The following link is an outdated blog post about it (several performance enhancements have been made since which would further increase the limits seen there): 
@_date: 2015-03-02 18:48:21
Thanks for your kind words.
@_date: 2015-03-04 17:30:05
I don't imagine that is at all why you were downvoted.
Since I'm extremely familiar with the topic at hand, I can figure out what your intent was, but your statement doesn't really convey the meaning you were aiming for.  Your statement essentially comes across like you know for certain about some outstanding vulnerabilities that would enable such an attack to occur, however there are currently no known attacks in that vain.  That doesn't mean there never will be, but the same is true between different versions of Bitcoin Core.
I suspect if you had worded your statement something like "Hopefully btcd starts using libconsensus soon so there might be less chance of being vulnerable to fake-conf attacks" you might have had more positive reception.
That said, your statement is highly debatable to begin with because the mere act of including the library does not at all mean it will magically become invulnerable to said attacks.  Including the library requires, at the very least, bindings, boost, and the use of cgo (which introduces several possibilities for issues with build versions and environment setup).  All of these things introduce additional areas for potential consensus issues.
Perhaps it would reduce the chances, or perhaps it would actually increase the chances due to the additional layers of complexity, but in any case, we can't make an authoritative statement like it's a magic bullet to an extremely complex issue.
@_date: 2015-11-30 16:42:38
For reference, and as recently announced, [btcd 0.12.0]( also supports BIP65.
Users should be updating to whatever their preferred full-node implementation is which supports BIP65.
@_date: 2015-10-01 17:35:06
I completely agree about the need for multiple implementations. We've been preaching this since we first started implementing btcsuite/btcd back in 2013 and is in fact one of the main reasons we started the project to begin with.
For the numbers you see on sites like getaddr, I do want to point out that they are skewed because only reachable nodes are shown and the default settings for btcd opt for privacy, so it does not do UPnP mapping (there is a --upnp flag for it, but it's not set by default) nor is there code to contact a centralized service in order to ascertain your external IP address (--externalip allows it to be specified) in order to advertise it in the initial version exchange.  The end result is that most users who run btcd and haven't explicitly configured it to be reachable won't show up on the charts.  I don't have exact numbers, but based on my own logs of seeing btcd nodes connect from different IPs, I would guess there are at least a couple of hundred nodes out there.  Nevertheless, that is still a tiny fraction of the total nodes.
In regards to forking, there was one instance when btcd was still in _alpha_ in early 2014 that it forked on the main network.  I'd have to look through the logs to get the exact time, but I believe the fix was deployed to master within 3 hours of the incident.  There have not been any other forks since that time.  Naturally nobody can say for certain that it will never fork again, but the same thing is true of Bitcoin Core which has already forked against itself on more than one occasion.  This is exactly why multiple implementations are needed.  With a single implementation, the entire network is at risk when it forks since you have roughly equal hash power competing against each other on either side of the fork.  With sufficient diversity of hash power using multiple implementations, only the users on the implementation that doesn't agree will be affected and the bitcoin network, as a whole, would continue business as usual.
