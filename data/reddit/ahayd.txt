@_author: ahayd
@_date: 2014-11-02 03:57:34
I'm talking about squishing focused (small) feature/bug-fix branches, larger project-branches can be more commits. *However* the important thing IMO is that git history should not be is a meandering history of how a developer attacked a problem:
- feature A first try
- fix
- actually I thought of a better way to do feature A
- ok, finally got this passing tests, wohoo
This should be a single commit for feature A (with a nice, descriptive message).
Like I say project-branches are a bit different, and I agree needn't be squished, but the idea is the same: they shouldn't "meander".
Rebasing is an absolute pain if stepping over untested meandering.
@_date: 2014-11-01 23:56:11


Many projects require you to squish your commits before merging a branch (Note: that a branch should be on a single topic i.e. one feature or one bug), IMO this is the correct way to use git. Small commits are ok, provided they are self-contained (as above, and ideally pass the test suite), what you don't want is commits pinging back and forth between implementations (before you settled on a solution for a feature/bug), that leads to merging/rebasing nightmare for everyone else in the team (and you).
@_date: 2014-11-01 23:30:24
Yes it may get merged, that does not mean one commit is as *valuable* as another e.g. a small typo, vs. a "adding feature A" or "fixing bug B".
Making all commits is IMO silly, and incentivizes the wrong behaviour (it's better to have fewer high quality, feature/bug-fix complete commits), e.g. branches squished to a single commit.
@_date: 2014-11-02 05:02:15
The problem with merging IMO is two fold:
1. hides potentially non-empty commits (which resolved merge-conflicts)
2. makes history more confusing / less transparent...
I like rebasing as it puts the onus of resolving conflicts cleanly in the rebased commits. Again, I'm talking here about rebasing small branches (for a feature or bug-fix, not larger project-branches), so this is history that no-one cares about.