@_author: fussylogic
@_date: 2013-05-12 09:18:03
Hey -- my pleasure.  I'm glad it was useful.
@_date: 2013-05-12 09:17:18
... I'm an idiot.  Thanks for the heads up, fixed now.
@_date: 2013-05-09 12:51:21
I wrote a "bitcoin explained" series a while ago that tries to give a dispassionate explanation of how Bitcoin technically operates, with a few economic notes for context.  Perhaps this will be useful to some:
@_date: 2013-06-04 11:30:36
- A maximum number of bitcoins that used up all of 64-bits worth of resolution instead of wasting 11 bits in every single transaction?  i.e. the sum of the geometric series should have been 2^64
- Pay to script hash
- Separation of transaction chain from blockchain.
- BitTorrent-like functionality for block data transfer. I'd like to have seen every object identified by hash and then the peer-to-peer features implemented simply as a distributed file system that given a hash returns a binary blob.  Then it would be for higher layers to interpret that blob.
- Big endian would have been nicer, just to keep with the tradition set by most other TCP/IP protocols ntohs(), et al sort out the swapping for us anyway.  The Internet Protocol spec requires it for all packet headers, and many other protocols.
- Even if not big endian; it would have been nice to be consistent.  There are big and little endian values in the bitcoin protocol.  Making it necessary to check the protocol documentation to be sure, instead of just remembering one.
- Putting a locally-determined address and port number in an application-level message was a bad idea.  Local applications don't know what their globally visible address is -- they can be behind NAT.  It's not like the remote peer even needs it -- that information is handed over by the operating system when connection is established.  FTP has demonstrated for years what a nightmare this is.
- Is verack even necessary?  Connect.  Client says "I speak version 10".  If the server is willing to speak "version 10" it can answer "I will speak version 10" (regardless of its true version); if it is not then it can say "I will speak version 5", the client can decide if it is willing to speak version 5 and continue or hang up.  verack isn't necessary and makes start up more complicated than needed.
- Did we really need RIPE-MD and SHA256?  If you want 160 bits of hash, then just truncate the SHA-256 hash.  They are meant to be evenly distributed, so there shouldn't be any grouping issues.
- Why use double SHA-256 for the message checksum?  Checksums are there to ensure that data isn't unintentionally corrupted from A to B.  That checksum doesn't need to be cryptographically secure.  Even if it were -- what advantage is there to double hashing for a checksum?
- Block download should have been most recent first.  Each peer must know what its current block chain tips are.  Those should be requestable by a command.  Then getblocks should have sent the one requested and then its parent, then its parent, etc, etc, until we hit the genesis block (or any other checkpointed block for that matter).  For comparison, see how git stores its "branches" -- the branch is simply a pointer to the commit at the head of that branch.  This would make it possible for a new client to begin instantly, with the blockchain continuing to download in the background.  As it is every new client has to wait until all previous history has downloaded before they can do anything.
- In the same vein.. A simplified client has no way of picking out just the bits of the blockchain that it's interested in.  If I receive a payment to my address, all I'm interested in is the blocks that chain the coins I receive back to their genesis; but I have to download the entire blockchain and analyse it in order to check the payment is valid.  In short: the protocol makes it close to impossible to keep a sparse chain (note, with enough sparse chains, the whole chain is always available, and everyone is incentivised to keep the history of their own coins).
- And further... there is no way to ask for "the block that contains transaction X", even though every client must calculate and keep that information.
- There is no way to query a node for the transactions it has queued.  If I've been disconnected for a long time, I can use getblocks to find out what I've missed.  There is no way to find out what transaction broadcasts I've missed.  This is relevant for early confirmation indications.  Instead of waiting ten minutes for confirmation, I can at least get a hint that the transaction is queued by my peers.
- 64-bit maximum resolution for VarInt type storage?  The message header will only allow you to send 32-bits of payload; making it impossible that any particular vector in a message will ever need 64-bits to specify its length.  On the same theme: the messages are limited to sizes that are way smaller than 32-bit lengths.
- Considering how freely 64-bit fields have been chucked around, the time fields are 32 bits in some places.  64-bit times are useful.
- ... but not for the version message... which uses 64 bits to store the number of seconds since the unix epoch.  Why?  That's 584 billion years of resolution.  Why not have specified it as number of microseconds past the epoch, in case the extra accuracy is ever useful?  That'll still get you 584 thousand years.
- Why break the version field on base-10 boundaries?  Base-16 boundaries make everything easier to process (not needing division for display) and readable in a hex dump.
- The services field is underused.  What about flags to say whether a node is a generator, whether it will accept transactions, whether it will broadcast transactions, whether it keeps a peer directory (for the addr message), whether it keeps a full block chain or just headers, whether it should be noted down as a seednode?
- It's possible to request only the header of a block, but not to request only the body.  A headers-only client has to download a load of bytes it already has when it wants to look at the chain in detail.
