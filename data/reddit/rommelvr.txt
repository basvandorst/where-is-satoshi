@_author: rommelvr
@_date: 2014-08-25 16:23:05
[Stealth addresses](
@_date: 2014-08-13 13:45:10
That is not how BIP39 works.
BIP39 takes whatever 'mnemonic' you provide it, runs it through HMAC-SHA512 2048 times, and then uses that as the seed.  Word lists are only used for **generation and validation**.
See an implementation [here]( and an explanation [here](
@_date: 2014-12-08 03:24:45
Using git as intended I see.  /s
@_date: 2014-10-03 23:37:02
HASH160 is the [Bitcoin term]( for `The input is hashed twice: first with SHA-256 and then with RIPEMD-160.`.
@_date: 2014-09-24 11:21:40
The project also uses [tip4commit]( however that does mean trusting a 3rd party service...
@_date: 2014-04-04 02:53:43
!bc has always been easier for searching blockchain.info; and has existed for several months atleast.
@_date: 2014-12-09 01:20:56
An example on how this occurred can be found [here](  Developers should be fully aware of this can happen, so as to stop it from happening [again and again and again.](
@_date: 2014-09-24 22:55:46
Premature optimization.
Compiler could have figured this out no problem.
This is also in the constructor, with a `std::vector` resize immediately after... modulus optimization is the least of the his concern.
should submit a PR to make the code cleaner.
@_date: 2014-08-13 13:32:54
You're mostly right.
However, the same word list does not have to be used.
BIP39 was designed in such a way that the word list is irrelevant except in generating or validating [, not importing] a mnemonic. 
@_date: 2014-09-22 04:32:43
The majority of nodes still use 5460 as the dust limit.  The latest dust limit is [546](
@_date: 2014-08-05 17:28:10
Multisig addresses are P2SH addresses, and they are encoded with a different prefix.  Your post is incorrect as you need to double your total address space.
There is no combining or sharding of private keys in multisig.  You may be thinking of Shamir's secret sharing.
@_date: 2014-08-24 11:58:07
Only if you want to validate the mnemonic afterwards.  BIP39 allows a user to provide any UTF8 encoded mnemonic.  
@_date: 2014-07-29 06:05:29
bitcoinjs is a lot more restrictive in what is deemed as acceptable inputs, and will throw exceptions in most (but not all) cases.
@_date: 2015-04-01 02:08:41
SPV has the potential to offer you less privacy however.  I guess it just depends on who you trust more.
@_date: 2015-04-01 01:02:22
Don't forget that libraries like [bitcoinjs]( are some of the tech that fundamentally backs this project.  Bitcoinjs has a tip4commit [here](
@_date: 2015-02-26 02:30:04
Its both, nodes create/relay transactions, miners create blocks.
Miners publish transactions (in blocks) which the nodes then relay.
@_date: 2013-05-05 23:09:52
Did anyone make sure to verify this is actually her?
The donation address posted in the [article]( was: [1EoUJadqQWyuNwgs9ez1hsGewNkK7BrmpF](
Perhaps before you all start tipping, she could sign the message with that address.
@_date: 2013-08-11 17:17:46
To be fair, it isn't `bitcoinj`'s fault that `java.security.SecureRandom` is crap, it is an industry standard.
Though, I wouldn't have trusted anything *but* `/dev/random` tbh.
@_date: 2013-08-11 17:28:36
That is correct; and that is also what bitcoin-wallet is [now]( using.
@_date: 2013-08-03 18:34:07


@_date: 2013-08-11 14:52:09


The main technical argument presented in that thread is that the `k` value used in the signing is causing a repeat in the `r` values of the resultant ECDSA signature. From what can be seen in the links above, the `k` value appears to be generated from `java.security.SecureRandom`, which should be good enough (afaik).


It seems like `bitcoinj` is doing the right thing, but as for `java.security.SecureRandom`: [its up for debate](


I'd say we're in the dark at this point.
**edit**: No longer in the dark.
So [looks like]( it was `java.security.SecureRandom` after all.
@_date: 2013-08-11 13:12:41
Both of the most popular wallets on Android ([bitcoin-wallet]( [blockchain.info]( are using [bitcoinj]( for the key generation/signing.
**edit:** As described [here]( it appears that `k` is being [chosen *correctly*]( and is using `java.security.SecureRandom` in both cases...
**edit2:** spongycastle is what `bitcoinj` uses for ECDSA.
@_date: 2013-04-15 09:00:32
holy crap
@_date: 2013-09-19 10:45:46
The issue wasn't that you used Bitcoins. The issue is that it was without escrow.
@_date: 2013-03-28 09:14:00
@_date: 2013-07-17 14:05:57
And you can only break the security of private keys which have had their public keys exposed.
Unspent addresses do not fall into this category. It would hurt Bitcoin, but it wouldn't break it.
Source: 
@_date: 2013-07-06 20:10:53
0-conf accepted payments are *always* going to be a risk. That is the point, they are unconfirmed.
@_date: 2013-09-06 06:47:15
[Nope]( you should read 
@_date: 2013-04-30 23:27:01
To anyone with a linux background, `strings -20 blk(omitted).dat | less` is not a very complicated process, infact its not even extraction.
It simply says interpret the streams of characters (`strings` at least `-20` chars long) within binary data (`blk*.dat`) as text and pipe them to an output that is a scrollable backbuffer (`less`).
@_date: 2013-12-31 06:41:48
Be careful who you trust.
@_date: 2013-09-06 00:29:54
In a transaction, the (destination, or) output address is actually a hash of a public key controlled by the receiving party.
Assuming the hash function is actually one way, there is no way to determine the public key from that hash; and therefore, the funds are safe.
When you use an address as an input in a transaction, you expose the public key for that address, leaving it open for possible exploitation in the event of a cryptographic attack on any of the algorithms that contributed to make up that public key (ECDSA, in this case).
Thereby, it is commonly stipulated as good practice to not re-use addresses (aka, any address for which the public key has become public).
@_date: 2013-07-15 15:52:39
if it gets too big, make it smaller.
Utter genius.
@_date: 2013-05-25 04:52:47
like in, high explosive.