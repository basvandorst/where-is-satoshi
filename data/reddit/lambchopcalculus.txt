@_author: lambchopcalculus
@_date: 2014-04-17 17:47:05
What makes you think unix is immune to malware?
@_date: 2014-04-17 18:32:54
You're probably right, but it could also be CSRF. I am leaning towards siding with you, though.
@_date: 2014-08-04 12:57:08
Hey guys! Have you ever heard of MySpace? It lets you have your VERY OWN WEBSITE! Look at mine! I can type in whatever I want and it shows up!
You sound like this. Bitcoin uses public key cryptography for signing messages. But Bitcoin did not invent those crypto algorithms. It just uses them in one particular way for one particular application. Saying that we should use Bitcoin's message signing for authentication as if it's some new innovation is just ignorant.
@_date: 2013-12-03 18:55:58
Can you give some specific examples of collisions you've found?
Also, please elaborate on how Benford's law applies here. Benford's law is about the appearance of certain digits in human-generated data and how that differs from truly random data. Benford's law is only about how specific digits are not uniformly distributed in data that arises naturally, and how attempts to generate FAKE data usually fail to take this into account. As I understand it, this has nothing to do with cryptographic random number generation, so please explain what you mean when you say it applies here. 
@_date: 2013-11-17 16:58:31
I don't think any sort of automatic adjustment of the maximum block size is built into the protocol, at least not to my knowledge. It can be increased with a change to the protocol, according to 
@_date: 2013-10-31 18:48:16
bit = **b**inary dig**it**
@_date: 2013-08-12 15:30:57
Why do you think this is secure?
@_date: 2013-11-14 05:14:20
The transaction fee is entirely arbitrary. The fee associated with a transaction is simply any amount not spent out of the inputs used in the transaction. A simple example: If I have a freshly mined 25 BTC in address 1ABC and I make a transaction that sends 5 BTC to address 1XYZ, then I pay 20 BTC in fees. What? Crazy? No, this is how Bitcoin works. Normally your client will make change and send the remainder to a new address or the same address you sent from, but that's a sort of behind-the-scenes function of your client.
Some clients help you to set the fee to whatever you want when you make a new transaction. However, it's entirely up to the miner whether or not to include any given transaction in a block, so naturally they will prefer the ones with the highest fees. That is why paying a higher fee will get your transaction confirmed more quickly, and why a transaction with a low fee may take much longer to be confirmed.
@_date: 2013-09-12 04:42:05
First, a wallet involves many keypairs, one for each receiving address and one for each change address. Some clients will generate change addresses as needed, others will reuse addresses as change addresses from a pool, and some will allow the user to specify the change address directly.
Transaction signing is done with ECDSA, which involves a random number for each signature, often written as `k`. If you reuse the same `k` with the same private key for two signatures, even if they're of different messages, then it is trivial for someone to figure out your private key from the messages + the signatures. See [this wikipedia page]( for a slightly more technical explanation. They mention that the PS3 signing key was stolen due to this flaw; it's basically the same idea with bitcoin wallets.
SecureRandom had a bug in it which meant that the seed it used for random numbers was not random enough. This makes it much more likely for `k` values to be repeated, and even if they are not, it makes it much easier for an attacker to guess the right values. Because the Android bug makes it more likely for repeats to happen, people have just been scanning the whole blockchain looking for any repeats they can find. This makes it much more likely that you'll manage to steal some coins as opposed to trying to crack one particular private key.
tl;dr: Signing a message/transaction with a private key requires that a unique random number be generated for that signature and never used again. If you use that random number again for another signature with that private key, someone can do some simple math to figure out the private key based only on the signed transaction data, which, of course, is publicly available.
@_date: 2013-11-15 16:27:16
No, but you can only fit so many transactions into each block, so you want to choose the ones that maximize your profit (i.e., you want to maximize the fees you collect, since that's the only part of the reward which varies).
There's a few factors involved here.
One is the size of an individual transaction itself, and size doesn't mean the amount of coins, but instead the amount of inputs and outputs. If you send 10 BTC from one address directly to another, that's one input and one output (that's not always true, but bear with me.). If you send 10 BTC from 1000 addresses with small amounts, you need to gather up all those small amounts and send them to the destination, and that transaction would be about 1000 times as big.
Regarding the actual size of the block itself, it would actually take longer to mine a large block versus a small one, but I think it would be a negligible amount.
@_date: 2013-09-12 02:02:42
This isn't true. It doesn't matter where the keys of the wallet were created; the bug on Android affected any private keys used in transactions signed by a client running on Android using the Java SecureRandom class. Keys generated using that flawed version would also be weak, but the real danger was in sending BTC from an Android client with the weak RNG. Again, this would affect even wallets generated offline and transferred onto the smartphone.
Summary: Only the first two are required.
@_date: 2013-12-04 01:22:43
In the algorithm that Electrum uses for deterministic wallets, the keys are generated as sha256 hashes of the initial seed + a nonce. You're claiming that sha256 is "not as random as it should be". 
This means you're claiming that sha256 values are not uniformly distributed. It is generally accepted by the entire cryptography community that sha256 is, in fact, close enough to uniformly distributed for cryptographic purposes.
@_date: 2013-10-30 19:24:05


ugh