@_author: furbertle
@_date: 2019-07-19 21:19:56
They've run out of space, so this time must be for real.
@_date: 2017-02-26 22:04:19
bitcoin-ruby is dependent on `OpenSSL` in many places, so, the build of OpenSSL on the Pi could be where the issue lies as well.
@_date: 2017-02-28 00:38:50
Ok, here's something new, but I'm pretty sure it's bad news.


This hashing process seems to start with a compressed version of the public key.
When I generate a keypair on my laptop and ask bitcoin-ruby for the compressed version of the public key, I get a 66 character hex string.  Based on what I see in the code, that seems reasonable.
However, on the Pi, the compressed public key that the address generation starts with is consistently just the uncompressed public key with a leading 0 stripped off. 
No idea why it would do that, but the code for compressing the public key is down in `::OpenSSL::PKey::EC.new("secp256k1")`
Never-the-less, garbage in, garbage out.  Seems like the address generation was supposed to be working with a certain form of the public key, and it was not provided what it was expecting.  
@_date: 2017-02-26 19:16:22




Apparently wasn't the problem. Bad assumption on my part. According to the instructions in the provided link, both are little endian.  Bummer.
@_date: 2017-02-26 18:16:03
Below is the key generation script.  I'll PM a key generated on the Pi shortly (easier than looking/waiting for your PGP key. ;-)
    require 'bitcoin'
    require 'rqrcode'
    
    namespace :bitcoin do
      task :generate_keypair do
        keypair = Bitcoin::Key.generate
        address = keypair.addr
        privkey = keypair.to_base58
    
        puts "Public Address: 
        puts "Private Key58: 
    
        privcode = RQRCode::QRCode.new(privkey)
        pubcode = RQRCode::QRCode.new(address)
    
        common_opts = {
          resize_gte_to: false,
          resize_exactly_to: false,
          fill: 'white',
          color: 'black',
          size: 120,
          border_modules: 4,
          module_px_size: 6,
        }
    
        privcode.as_png(common_opts.merge(file: "
        pubcode.as_png(common_opts.merge(file: "
      end
    end
@_date: 2017-02-27 20:30:42
Thanks so much for your time and suggestions!  I really appreciate it.
I was just able to do a quick test and confirm that both `Digest::RMD160.hexdigest` and `Digest::SHA256.hexdigest` give identical results on the Pi vs the laptop.  As you said, SHA256 seems ok, but I think that rules out RIPEMD-160 being the culprit.  I'll poke around more later and report back any interesting finds.
@_date: 2017-02-26 21:47:05
Yeah, the problem is almost certainly something to do with either  bitcion-ruby, the Raspberry PI, or a combination of the two.  As the script works great on my laptop, I'm inclined to put more blame on the Pi, but considering that it's not the endianness that's an issue, then I'm at a loss.
The very first thing I checked after discovering the issue was the QR codes, since that was really easy to check (as I'd stored both the qr codes and the `puts` outputs.  They match consistently, so the issue is somewhere in the key or address generation.
Since posting this thread I loaded up one of the private keys back into `Bitcoin::Key.from_base58()` and had it re-calculate the public key (pre-hashed to address) on each system and I get different results on each.  So, that seems suggest that the problem isn't (or isn't only) in the hashing of the public key into an address.
@_date: 2017-02-26 18:20:54
Thanks for the tips and links.  I'll work on this ASAP and report back my results.
@_date: 2017-03-10 22:47:56
The OP's question/speculation is *entirely* about approval outside of the SEC's jurisdiction.  In that context, the SEC regulatory requirements are completely irrelevant.
@_date: 2019-09-21 20:06:36
*than*