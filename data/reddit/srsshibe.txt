@_author: srsshibe
@_date: 2014-11-02 21:19:07
That's a good point, I did not think of that.
So if I understand you correctly, the block will indeed be invalid but only for a short period of time.
The timestamp must be network-adjusted time + 2 hours.  So an attacker that makes their block timestamp equal to that will cause some nodes to mark it valid and others to mark it invalid.  However, you are saying that once a few extra seconds pass, the block will be recognized as valid by all.
I will probably have to take a look at the actual code since the description is a bit confusing here: 
So for example..
Imagine that two nodes A and B have network-adjusted times of 2:58 and 3:00 respectively.  A new incoming block has a time of 4:59.  Node A should reject it (it is 1 minute after the deadline).  Node B should accept it (it is 1 minute before the deadline).  2 minutes then pass and the times change to 3:00 and 3:02.  Both of these nodes now claim this block is valid so the attack only lasted for a few minutes.
A sybil attack involving many fake nodes could also prove bad.  At best it could be used to DDoS the network.
@_date: 2014-11-02 15:18:43
This is something that I had actually been thinking about (and worrying about) for the past year.  I will ignore the economic incentives that may or may not prevent an attack.  Instead, lets look at the technical side.
The issue comes down to treating all information that decides if a block is valid as a pure function.  Imagine a function called isValid that decides if a block is valid.  All parameters to this function are identical for every user on the decentralized network except for the "network-adjusted time".  Since this parameter relies on the nodes each user sees, this can cause different users to believe a block is valid while others believe it is invalid.
The timestamp T is valid if:
T &gt; X &amp;&amp; T &lt; Y
X is determined entirely on prior blocks, and therefore is a pure function.  All users will agree upon the result of T &gt; X.
Y is determined using the timestamps of neighbouring nodes, and therefore is not a pure function.  All users will not agree upon the result of T &lt; Y.
This will potentially cause two users to disagree upon the validity of a block.  If we assume that user A and user B disagree upon the validity of the block, a fork would be created.
It seems that a fatal flaw is that the calculation of block validity depends on something other than the blocks themselves.  This potentially means that difficulty adjustment is not safely possible in a decentralized system.
I hope someone can clear this up for me and explain why I'm wrong.
Now if we take the economics and incentives into account, does it make sense for a bad actor to do this?  A fork would certainly cause a panic and the price to drop.  It would also yield their 25 BTC unrecognised by one of the forks.  The attacker could short Bitcoin.  The question now becomes, is the profit from shorting Bitcoin enough to offset the mining cost to deliver the attack.  Unfortunately, I think the answer is yes, but only if their mining power is very large.
@_date: 2014-11-02 21:19:29
Edit: Deleted this post because if this 2nd timing attack I came up with works, it would be very bad.  I need to think about it a bit more before posting it.