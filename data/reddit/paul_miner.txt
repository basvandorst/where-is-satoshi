@_author: paul_miner
@_date: 2016-08-15 15:44:10
Many years ago I ran a Tor exit node. I quickly learned why you don't do that when I found myself IP-banned from various sites.
@_date: 2016-08-05 15:05:11
I did some reading up on BIP32 and BitGo's API yesterday so I could pick apart some of the [alleged blocks involved with the hack]( From [BitGo's API](




Three xpub keys are needed to create a wallet, rooted at child path /0/0 on all three chains. Then from there, every time an address is created, it gets a new chain path, so receiving addresses will have a path like /0/0/0/0, /0/0/0/1, /0/0/0/2, etc.
All three pubkeys used in the redeem scripts appear to be unique across all addresses (I don't just mean the combinations, but taken individually, a pubkey in one address doesn't appear in other addresses). This is to be expected based on how BitGo's API says addresses work, since each address gets a new chain path. It also implies that the keys at the wallet level are also unique, since you would expect wallets to have the same chain paths (e.g. every wallet has an address at the /0/0 chain path, and if you examine enough addresses, it's likely you'd find two using the same chain path). This doesn't rule out that these keys are child keys of some master HD key though.
However, for the backup key (which I thought was the key in cold storage), I'd have expected to seem some duplicates since some addresses would have the same chain path. So it could be the case that they're generating child keys for their cold storage key before sending them to BitGo. Hopefully it's not because they're generating new root backup keys at the same time as the user key and actually keeping them hot.
For what it's worth, I was able to verify the signatures on a few transactions and confirm that it was the first and third keys that were used, which corresponds to Bitfinex's user key and BitGo's key. The backup key was not used to sign the transactions.
@_date: 2016-08-05 14:45:54
From reading the [BitGo API]( it doesn't look like a client can get a fully signed transaction from BitGo. The client (Bitfinex) can create a transaction, sign it with their own key, but there doesn't appear to be an API to get a transaction signed by BitGo but not released to the network. The final signature by BitGo seems to be paired with broadcasting to the network.
@_date: 2016-08-13 03:21:23
1. Generate key offline.
2. Set computer on fire and throw it in the trash. 
@_date: 2016-08-03 15:23:46


The compromise of Bitfinex's key aside, this is really what I'm interested in finding out about. As I understand, the whole point of using BitGo is to eliminate that single point of failure, or at least reduce the damage that can be caused by a key compromise.
Here's what I want to hear:
* What safeguards/limits were configured for Bitfinex's BitGo account?
* Assuming there were limits in place, are they configurable/removable from a console as was suggested by [this comment](
@_date: 2016-08-03 18:33:57


This is the piece I'm most interested in; while the key compromise would have resulted in some lost funds anyway, the loss would not have been nearly as substantial if BitGo had stopped the transactions because they exceeded reasonable limits put in place. As I understand it, having these restrictions in place independent of the exchange is the value that BitGo brings: a second line of defense to mitigate the potential damage from a key compromise.
@_date: 2014-02-18 17:43:37
This is a specious argument. I doubt that Wikipedia's technical contact is aware of every last possible vulnerability on their site simply because there's a wiki page on it.
A more useful way of judging this would be, if you didn't already know about transaction malleability, how would you have found that page? The issue wasn't even known until a couple years after Bitcoin's inception, so it was hardly obvious (and clearly an oversight).
However, as a major exchange, they do bear greater responsibility in maintaining good quality software. And in that view, TM was actually the smaller error; their bigger mistake appears to have been poor accounting in their wallet, and an even worse workaround that simply created new transactions.
@_date: 2014-02-18 17:15:39


This is the heart of the issue. TM is a problem, but in this case, it was just an exploit vector. I think their real problem is that double-spending was happening in their software regularly, and their "fix" was to issue new transactions automatically. Which worked fine, until this was exploited using TM.
EDIT: I should clarify, it worked "fine" as in it covered up the symptoms of the problems. Such accounting issues are definitely not fine.
@_date: 2014-02-22 18:20:23


The voting around here is confusing to me sometimes. I think it must be at least partly because of real-world impact of influencing opinion on this topic.
@_date: 2014-02-18 16:55:14


I agree. But that doesn't mean that TM is blameless.
And as I said, TM was merely the exploit vector. I believe the real issue is that their accounting was implemented poorly, probably as a workaround to concurrency issues.
@_date: 2014-02-22 17:33:20
@_date: 2014-04-06 18:46:20
Starting with a power-of-two number of transactions doesn't give the merkle root any interesting properties. If anything, it makes it less predictable. If you start out with a transaction count that isn't a power of two, it gets padded with other transaction hashes, which if anything would make it easier to analyze.
And really, if your goal was to make manipulating the merkle root easier, why would you include any transactions besides the coinbase? It would be easiest to only include the coinbase transaction, which is the only transaction you can alter anyway (e.g. extraNonce).
@_date: 2014-02-18 15:27:49


I believe it is a book-keeping problem. Here's my theory of what happened:
As an exchange, MtGox's wallet sees a lot of traffic. When dealing with a large number of transactions, you will eventually have to deal with concurrency. That is, multiple transactions happening around the same time, or otherwise overlapping.
My suspicion is that MtGox's software did not properly implement locking of the inputs used in a transaction, which would result in double-spends. Since double-spends would not make it into the blockchain, customers would legitimately complain about failed transactions. Simply resubmitting the same transaction with the same inputs would also fail. Repeat enough times, and MtGox implements a workaround: when a complaint comes in, and the transaction does not appear to be in the blockchain (this is what the transaction malleability exploits would later attack), then just create a new transaction with new inputs and submit that.
This worked okay, until transaction malleability was exploited. Poor concurrency handling in the wallet was worked around by resubmitting new transactions (it's cliche, but this is a very PHP attitude to solving problems), but since transaction malleability was being exploited to hide the transaction from MtGox's software, the resubmission of the transaction was erroneous.
@_date: 2014-03-07 13:54:58


Unfortunately, on the whole that is not the MO of this subreddit.
@_date: 2014-02-18 20:07:47
Wow, that's a lot of volume. Good luck with the analysis!
@_date: 2014-02-18 16:43:15


I don't know what kind of analogy you're trying to make here, because it doesn't make sense. The situations are not analogous.


I think you're providing an exception for this situation. Ids are typically considered immutable and a reliable way of uniquely identifying something. Which is what transaction ids do, *after* they've been confirmed in the blockchain. This is where the behavior deviates.
A transaction id has two behaviors, depending on what stage it's in. It can be used to uniquely identify a transaction that has been confirmed. But due to transaction malleability, it is not a reliable way of looking up a transaction in the blockchain. This is not intuitive behavior. In most environments, you would find this to be a faulty API or data model.
The problem was caused by not having a canonical representation of a transaction. The protocol wasn't quite tight enough, which allowed for transaction malleability.
@_date: 2014-02-22 17:42:16
Okay, I see what you're saying.
If you're looking for BTC owners though, is this subreddit significant, or are there other forums (e.g. bitcointalk) that are of greater importance?
@_date: 2014-02-18 15:35:23
I don't see the fault here as a cut and dried issue. MtGox (and other implementations) should have worked around transaction malleability, but the fact that the issue exists in the first place is a sign of a problem. It's further compounded by the misleading name "txid". It's an id but with behaviors that deviate from how ids are commonly understood to behave by programmers.
While it was documented in the wiki, it strikes me as one of those things you'd only find if you knew to look for it.
@_date: 2014-02-13 20:53:02


Actually, cryptographic hashes are frequently used as IDs, because they're specifically designed to be collision-resistant. See: 
But that's besides the point, because the issue wasn't a hash collision, but rather a misleading name.
@_date: 2014-02-18 17:49:01


I theorize that poor concurrency handling led to double-spending of some inputs in their wallet on a regular basis. The poor book-keeping part is where they ignored this and just created a new transaction. If an input was really being double spent, then their should have been an entry in their database somewhere showing where it was spent.
Before TM was being exploited, they could have pointed out another transaction that it really had been spent on, and that would explain where they actually tried to double-spend the input. But when TM was being exploited, there were effectively inputs that were being double spent, but for which there were no valid transactions. Good accounting would show that the numbers would not add up, and this should have been caught right away.
But the fact that they likely handled accidental double-spending by re-issuing transactions is symptomatic, so it's no wonder they didn't catch the accounting mistake either.
@_date: 2014-03-05 14:13:04
It'd be kinda funny if whoever cracks it just takes the money without posting anything.
OP, you need some kind of plausible deniability that whoever withdraws the money isn't you.
@_date: 2014-02-14 14:03:38


I don't think you understand how collision-resistant a strong cryptographic hash is. There are no known collisions for the SHA-2 family. Zero. Not only are collisions difficult, but even getting a few leading zeros is difficult, which is why Bitcoin uses it as a proof of work function. The Bitcoin [Target]( is the the maximum hash value that can be used as proof of work, which is currently "0000000000000001A36E00000000000000000000000000000000000000000000". Even at the current [global hashrate]( of over 20 quadrillion hash computations per second, it takes several minutes to find a hash that merely has 16-17 leading zeros. Let alone matching all 64 digits.
But let's suppose you didn't use hashes as an ID. What are your alternatives? You could hand out IDs from a central authority, but that creates a single point of failure, and goes completely against the decentralized philosophy of Bitcoin. You could have clients generate GUIDs, but that's even worse than hashes, because then there would be no relation between the ID and the transaction (which in turn would mean that there would be nothing stopping someone from maliciously creating duplicate IDs for completely different transactions). Cryptographic hashes are by far the best choice. If you think you have a better way of generating IDs, lay it out for us.


They are used as IDs and as a way of uniquely identifying data (read the wiki link I posted in my previous reply). Your statements completely miss the important details and place the blame on the wrong part of the system. The actual problem is that there isn't a required canonical representation of a transaction, not a hash collision as you imply.
@_date: 2014-03-09 01:32:57
Thanks, I was using the wiki earlier today. Went to pick up where I left off, and was getting 522s.
@_date: 2014-04-06 18:19:40


It is far more difficult to manipulate the merkle root than it is to change the nonce. This theory doesn't make any sense. The best explanation appears to be related to mitigating a possible exploit when the transaction count *isn't* a power of two.
@_date: 2014-03-06 19:31:28


It's a common grammar mistake, since the contraction for "have" and even the full pronunciation of that word sounds like "of", e.g. "I could have done that" --&gt; "I could've done that" --&gt; "I could of done that".
@_date: 2014-02-18 16:53:30


Yes, there are IDs that change, but that's typically due to the id having a "lifetime" over which it is valid. For example, a process ID is only valid over the lifetime of a process.
But a transaction id is valid forever, but only after confirmation. Before confirmation, TM can interfere. Off the top of my head I can't think of an ID that has a similar life cycle.
@_date: 2014-04-06 18:49:04


If this were true, their best chance would be to only include the coinbase transactions. There'd be no reason to even include other transactions.
@_date: 2014-02-21 19:17:59


Quoting from a [prior comment](


Approximately 0.4% of transactions would be vulnerable to txid mutation via DER encoding.
@_date: 2014-02-18 17:25:15


A cryptographic hash *is not just a number*. It has an additional property: it is in practice impossible to alter the contents of the transaction without also altering the hash. This provides a level of integrity that a mere identifier does not. There is effectively a one-to-one correspondence between the transaction data and its hash.
Because of the contents of a transaction are unique, the transaction hashes are also unique. So it is an identifier (and is used as such after being accepted into the blockchain). Where this breaks down is where TM allows an identical transaction to be submitted with a different hash, because of some looseness in the transaction representation. This breaks the one-to-one relationship.


I have no idea how this relates to the topic at hand. But as a sidenote, transaction ordering is actually important for banks, and there have been lawsuits over this (hint: overdraft fees).
@_date: 2014-02-13 22:37:28
As I understand it, the root of the problem is that transactions do not have a canonical representation, or at least can be submitted without being in a canonical representation. So two transactions (in terms of blocks to be confirmed) representing the same logical transaction can be submitted for mining, at which point which one is actually incorporated into the blockchain is up to chance (or access to better hardware).
The problem is that although the two transaction blocks represent the same logical transaction, they have distinct transaction hashes, which is referred to as the "txid" (transaction id). Because it's an "id" which has certain connotations, some implementations did not take this into account. So if an implementation or exchange went to check a reported failed transaction and performed the lookup via txid, it would appear that the transaction had indeed not succeeded.
The exploit comes from the re-issuance of a new transaction (as opposed to re-submitting an identical transaction), particularly if this process is automated. It needs to be a new transaction: the old transaction would be invalid because the money has already been spent in the alternate transaction that had the same logical value, but a distinct transaction id.
I don't know the internals of how exchanges handle their bitcoins, but I think the reason an exchange may issue a new transaction is due to the problem of concurrency. From what I understand of Bitcoin, transferring money simply points to the previous transaction(s) the money you have came from. If you are running an exchange, the money you hold could be "fragmented" over a large number of transactions until you aggregate them into a single transaction. I don't know how often (if ever) exchanges aggregate money, but I would guess not often because of both the cost in terms of fees, and the disruption to service if there was not enough remaining money to handle transactions in the interim.
If your code does not ensure that transactions are performed atomically using locking mechanisms, it might be possible for two transactions occurring at the same time to use the same source transactions, creating a double-spend. Since only one of them will work, this would create a legitimately failed transaction. And if this happens regularly due to a combination of transaction volume and code that does not enforce transactions being performed in an [ACID compliant]( manner, you might find it easier to just automate the process and assume that failed transactions are probably your fault, and they should just be recreated and resubmitted.
@_date: 2014-02-23 20:48:35
When I look around this subreddit and see the constant stream of accusations of outright theft that are made against Gox without good evidence... it says something about the mentality of people that Bitcoin seems to attract on the whole. Your family member would probably be one of them.
@_date: 2014-05-03 16:51:28


Brain size is definitely relevant. See: 
@_date: 2014-03-09 20:12:00


Unfortunately, it's even easier to *not* write these scripts.
@_date: 2014-02-18 16:37:12


It was documented. I would not consider that wiki page to be "well-documented". Few people even knew what that was before it recently blew up. And to my point, even the reference wallet implementation had problems with relying on the transaction id.
That said, while transaction malleability is a problem that needs work, I think the real issue is MtGox's accounting. I've gone over this in other comments, but the short version is that double-spends should have been a red flag, and should not have been worked around by resubmitting a new transaction. To me, this was their real failure. Transaction malleability was just an exploit vector for that issue.
@_date: 2014-02-18 19:09:55


I didn't mean accounting as in the CPAs, I meant the book-keeping done by the software. So yes, a technical and management failure.
@_date: 2014-02-18 19:08:06


That's interesting, I didn't know that. From a leading-zero perspective, that makes sense though.
Outside of MtGox, would there be a heuristic that could identify what transactions were exploiting them? E.g. transactions for the same amount, going to the same recipient, within a range of time (cap it to a reasonable amount), where the first transaction was potentially exploitable. I don't know if the volume of transactions would make this a feasible search, or if it would produce reliable results.
@_date: 2014-02-18 17:04:25


This is not a unique key. There is no central authority for "date", and Bitcoin allows transactions to be pretty loose with date.


It's nothing like that. Something that makes many analogies lacking is that transaction id is a cryptographic hash, not a sequence number.
EDIT: I should add, the proper way to look it up is by transaction inputs. But that's not as amenable to indexing, and more difficult than looking up by id as was intended before TM was discovered.
@_date: 2014-02-18 16:57:37


If transactions required a canonical representation, then confirmation would have been irrelevant. A transaction id would have uniquely identified the transaction, because the signature would properly enforce the transaction's immutability. It's only because of a minor oversight that TM is possible.
@_date: 2014-02-22 17:36:06


Given their lack of communication, I don't see this applying.
@_date: 2014-02-22 01:07:04
@_date: 2014-03-14 21:15:31


Ask yourself this question instead.
@_date: 2014-02-18 15:15:55


It's not that severe (the problem has been around for years, and multiple implementations did just that). But also consider that there was a time when relying on IP address was actually used to somewhat uniquely identify clients.


Well, it actually is a problem with IPv4. Which is why there's a push for IPv6, because NAT creates a lot of issues caused by the limitations of IPv4. Now the limitations of IPv4 have been known for a while because TCP/IP has been around for decades. But transaction malleability is not that old of an issue. Combined with the misleading txid name, more than one implementation got it wrong.
Security and reliability is strengthened by layers. While I believe MtGox definitely has an accounting problem in their back-end, the transaction malleability was a weak component, and if that problem hadn't been present, MtGox's accounting may not have developed a problem.
@_date: 2014-02-14 14:11:21


Major companies that *specialize* in storage all rely on the collision resistance of particular hash algorithms to guarantee the integrity of both their data and their customers' data. What you're forgetting in your calculation here is the probability of a collision, which is so close to zero that no collisions have been found for algorithms such as the SHA-2 family, despite the efforts of computer science and cryptography researchers around the world over many years.
Not to mention, that again, this is all besides the point, because transaction malleability has nothing to do with hash collisions.
@_date: 2014-03-06 14:23:42
Html collapses whitespace. Consequently, two spaces in html will collapse into one. It can be preserved in the browser, but it takes special effort. However, the collapsing is merely done when displayed, and are preserved in source unless the server does some processing on it.
EDIT: The two spaces thing is just something from the typewriter era. Even on computers I was taught to put two spaces after periods, but the past decade on the internet has changed that habit.
EDIT2: A quick Ctrl-U on that reviews page shows that there are indeed two spaces after periods.
@_date: 2017-04-07 21:20:11


A trivial problem to solve; dependent transactions can simply be omitted or their parent transactions not replaced. Not an issue.


I just picked the [latest block]( to look at, and this isn't true. The transactions were not ordered by fee amount.
@_date: 2017-04-07 20:08:24
That's the higher effort way of doing it. Much easier:
1. Build a normal block with a normal amount of transactions, say 2000 transactions.
2. Keep a pool of unused transactions on hand, say 20 transactions, split into two pools of 10.
3. To generate candidates for both the left and right subtrees of the Merkle root, substitute each of the 1000 transactions in the subtree with each of the 10 transactions in an unused pool, for a total of 10,000 candidates per subtree. I don't have to bother recalculating the hash of any transactions, and recomputing the Merkle subtree hash will take around 10 hashing operations per candidate.
4. For each combination of left and right candidate, hash the subtrees together to calculate the Merkle root (1 hashing operation). Stop when you have a sufficient number of collisions.
No complex shuffling logic needed, no rehashing transactions. Just an initial candidate generation cost (10 hash operations per candidate), and 1 hash operation per collision search. I think this should be faster than messing with extra-nonce in the coinbase as well, because you have to pay the extra cost of hashing the transactions.
EDIT: Also, it's indistinguishable from a normal block. No weirdness in the extra-nonce, weird version numbers, transactions that always move your own coins, etc. Just one normal transaction getting subbed out for another normal transaction.
@_date: 2017-04-06 02:58:18


Partial recomputation of the Merkle tree. If only the coinbase is modified via extra-nonce grinding, then only the subtrees containing the first transaction need to be rehashed. If there are on average about 2^11 transactions in a block, the Merkle tree will have 11 layers, which means 11 hashes to recompute, plus however much hashing is needed to compute the transaction hash.
This is the naive way of generating Merkle roots for a collision. The paper outlines a smarter way that involves generating candidate left and right subtrees of the Merkle root. The left subtree candidates are generated through the aforementioned extra-nonce grinding in the coinbase transaction. The right subtree candidates are posited to take more work in that it will need to rely on larger changes to the Merkle tree, perhaps by re-ordering the transactions used to generate the tree (which requires recomputing a larger portion of the subtree hashes). But I think it is computationally cheaper to substitute a transaction from a pool of unused transactions, minimizing how much recomputation is needed. It may even be more efficient to use this substitution approach to both the left and right subtrees, since any single transaction could be substituted for any transaction in the unused pool, there would be plenty of combinations possible to generate candidates. 
Once you have your sets of left and right candidates, each combination of left and right candidate can be used to generate a new Merkle root using a single hashing operation. Store all the results, and via the birthday attack you'll find collisions (note that only the last 32 bits of the Merkle hash as stored need to collide). The larger the set of collisions, the greater the savings from reusing the work used to extend the second block of the header into the hash function's internal state.    