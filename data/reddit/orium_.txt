@_author: orium_
@_date: 2018-09-23 21:49:55
The block validation rules are a prime candidate for formal verification.  For almost all kinds of software formal verification is too much work.   But for a reasonable small amount of code were the rules are mostly static and that the consequences of breakage are very high, it would certainly be worth considering.
Does anyone know if something like this was already considered?
@_date: 2014-02-18 03:27:08
This whole "cash" thing smells like a huge ponzi scheme!
@_date: 2014-07-29 20:06:06


[Yes, and it should not take long.](
@_date: 2014-10-08 21:24:16
That's why I always fake-cough when generating private keys.
@_date: 2014-11-26 15:28:49
sure. and by december 2015 the price will be 1M$ -.-
@_date: 2014-01-16 22:38:08
It will take many years... and that's good. If amazon start accepting bitcoins now the btc price would sky rocket and inevitable would fall which would cause mass distrust on the currency. I think it is important for the adoption to start from small companies to larger ones, so no abrupt change of bitcoin value happens and the volatility decreases smoothly over time. A good start would be for ebay to offer bitcoin as an alternative payment method that sellers could opt-in.
(This is my opinion, I have absolutely no authority on economics.)
@_date: 2014-08-14 16:05:14
linus, c++, naaah
@_date: 2014-06-01 16:33:30
Actually more: $1,263,432,587
source: 
@_date: 2014-11-25 16:03:56
I like the blockchain one.
@_date: 2014-07-25 04:51:04
I have tried every string from length 4 to 9 that begins with "adv", with the charset a-z 0-9.  No luck.
@_date: 2014-07-04 04:10:20
The all time graph with logarithmic scale makes is easier to see the linear growth which begun when the blockchain reached ~17MB.
@_date: 2014-07-04 03:46:26


Those are some compelling points, but the blockchain size grows linearly:
[Last 2 years with logarithmic scale]( This is obviously a logarithmic curve.
@_date: 2014-10-10 14:49:28
I use bitcoind.  For me everything is fine, but I would really like to see [armory]( in *community*.
@_date: 2014-03-04 03:22:21
* Total bitcoin market cap: [8⋅10⁹$](
* Net worth of world richest person: [73⋅10⁹$](
* Highest market cap company: [504⋅10⁹$](
* Bank with most value (assets):  [2954⋅10⁹$](
@_date: 2014-11-22 04:49:57
Comprehensive answwer. Enjoy a cheap coffee @_date: 2014-11-12 23:12:50
Same here. Tipped cgp gray, vsauce and veritasium 3 days ago.  No tip collected.
@_date: 2014-07-29 21:19:37
[There are plans for it](
@_date: 2014-11-09 02:12:32
There is tendency to pick adjacent letter of the alphabet, by that order: i, j, k ; p, q; m, n... And as said it is common practice to use these in mathematical expressions
@_date: 2014-11-18 03:43:07
You know what would be awesome. A website where people could do arbitrary SQL queries in the database.
@_date: 2014-01-21 14:14:11
Adding to what OP said: 
Headers-First, parallel download chain sync. check [Core Development Update 
@_date: 2014-07-30 08:23:48
thanks :)
@_date: 2014-07-26 06:48:32
anybody knows how are floating fees comming along?
@_date: 2014-07-04 03:36:48
It is linear: 
@_date: 2014-11-02 19:22:45
I bet the CEO of bitcoin will come up with a great ideia!
@_date: 2014-10-20 16:42:26


That would be awesome.


Why is performance a problem?  The node only has to verify, on average, one block per 10mins.
Edit: grammar
Edit: I realize that the node may have to verify many blocks if they are invalid (for instance in a DOS attack), but by verifying that it matches the target difficulty and the previous block hash we can quickly* reject those blocks.
\* well... intuitively I think that it is fast to compute (I assume there would be an opcode to compute the block hash to verify it matches the target difficulty)
@_date: 2014-10-20 16:28:18
From 


@_date: 2014-05-30 23:45:29
A bitcoin potato can only give me luck:
@_date: 2014-05-10 16:43:52
Happy 000000000000000082ccf8f1557c5d40b21edabb18d2d691cfbf87118bac7254.
@_date: 2014-07-25 02:30:04
all letters lowercase?
@_date: 2014-07-26 17:20:56
My mistake, I haven't actually loaded the wallet -.-
Bruteforcing this is extremely slow bacause bitcoin does a lot of key iterations. I'm only testing ~40 keys per second.  This means I can check for every word of length 6 (assuming "adv" prefix), but no more.
I can improve the probability of finding the key if you can narrow down the charset for me:


Of these chars which ones are you positively sure were not part of the password?
Which chars are likely to be the forth one (ie. after "adv")?
@_date: 2017-08-24 17:38:46


Is there any website that shows the percentage of segwit transactions per block?
@_date: 2016-11-10 23:18:25
Actually Armory 0.95.1 was released recently with some bugfixes for 0.95.0, but I think largely missed the Armory 0.95, so I linked to that.
@_date: 2017-11-06 11:45:51
This might still change before the final 0.15.1 release, but the important stuff seems to already be there (Network fork safety enhancements). 
@_date: 2012-12-15 21:29:55
@_date: 2018-03-06 13:10:27
But that is given the *public key*, which in bitcoin is not public. What is public is the hash of the public key (i.e. the address).
@_date: 2018-02-17 01:05:55
@_date: 2018-03-06 17:03:28
Right, that is true.  You will have a problem if you reuse addresses.
Edit: you will also have a problem if a quantum computer can break find your private key quickly enough and create another transaction before the original transaction confirms.
@_date: 2017-09-04 01:02:23


you would need to create a new signed transaction every time you use your bitcoins.
@_date: 2015-04-30 03:29:35
That is not the estimated time remain to synchronize.  That is the age of the last block synchronized (i.e. your client has verified every bitcoin transaction older that 6 years 15weeks).
It should take about a day or so to synchronize, and it will use ~39GB of your disk space.  If that is not reasonable for you consider a lightweight wallet such as multibit.
@_date: 2017-10-25 18:38:53
You should count with 0.15.0 which is just as good.
@_date: 2015-03-28 19:33:07
The last satoshi will be mined around 2140, but by 2024 about 96% of all bitcoin will have been mined. See 
@_date: 2015-03-29 17:14:36
There is a `-datadir` flag to pass to bitcoind.
@_date: 2015-02-02 21:32:00
For me it is ~10GB/month of download , ~195GB/month of upload.
Edit: and it is using 1.2GB of memory (actual resident memory) with 114 connections, so for me it is hard to believe that people can use this on Pi 2. (maybe with a limit 60 or 70 connections that is possible?)
@_date: 2016-07-09 17:10:40


That was an example.  I have no idea what the extra latency would be.
PS: After googling I found [this paper]( and it seems that the latency increases ~80 ms/KB for 50% of the network (see Figure 4 and Sec C).  This paper is from 2013 and the network changed a lot after this.  If you do the math you will see that the delay doesn't match what we observe now, but it shows that the propagation time per size seems to be constant, which means we will have double the delay that we have today (which is around 5s for 50%).  (Of course this might not extrapolate to higher block sizes)
@_date: 2016-07-09 10:53:02
And latencies.  Bigger blocks mean that it takes more time for nodes to download them from other nodes.  This makes the time of broadcast of a block to a given percentage of the network, making orphan blocks more common.
@_date: 2016-07-09 14:34:28
I don't know how much more common (I'm sure with some fancy math it is possible to get an estimation), but it will be more likely (a 2MB would almost certainly not make a sigificant difference, but it will be there).
But can give an idea on why the likelyhood of orphan block increases: the probability of a block getting orphan is proportional to the time it takes for the block to be known (and validated) by 50% of the miners (actually by 50% of the hashpower-holders). The reason is that once miners are aware that a new valid block exist they will start mining on top of that block.  If they receive the new block with a 30 second delay then they can find a new block on that 30s interval and maybe get ahead of that new block (making it orphan).
Bigger block will take more time do broadcast since you need the whole block to validate it before you start mining on top of it. The miners will take more time to get the block (it's not only their download time, each "level" of propagation in the network will add some extra latency if the download time is larger).
Edit: grammar
@_date: 2015-02-22 14:58:45
I was hoping for floating fee support (by calling bitcoind RPC estimatefee).  Cool release nonetheless.
@_date: 2013-11-25 01:56:07
I just changed the name of that section to "Unauthorized Mining", which makes a lot more sense.
@_date: 2013-11-09 19:02:38
Bitcoin addresses are derived from a 256 bit private key so there is a 1/2²⁵⁶ probability that you generate a given address. There are about [100K]( unique addresses. The probability of a colision is about 100000/2²⁵⁶ ≃ 8.6*10⁻⁷³ = 0.000000000000000000000000000000000000000000000000000000000000000000000086%
edit: minor fix