@_author: redditeraya
@_date: 2019-03-30 12:13:08
Source: 
@_date: 2019-03-19 22:04:22
Very helpful information! Thanks for sharing!
@_date: 2019-03-19 22:02:56
brilliant, thanks a lot!!
@_date: 2019-03-19 20:26:29
I was looking for a more performant alternative to bitcoin core. Performant in regards to syncing and reindexing/rescanning, but I guess btc is slow per design..
@_date: 2019-03-19 20:25:42
well they share the same author: parity :)
@_date: 2019-04-06 18:26:49
Iâ€™m not. Please give me 2 more months to fill my bags. 
@_date: 2018-11-16 12:51:59
From my OP:


  
I'm not talking about a transaction having multiple inputs/outputs, but **a single output being correlated to multiple addresses**
But btw, the segwit thing you mentioned is interesting, it's the first time I'm hearing it's stored on a separate chain. Which separate chain?
@_date: 2018-11-16 09:53:54
not really  
in bitcoin, addresses are derived from the public key, using some kind of scripts (e.g. P2PKH, P2WPKH, P2SH, etc.)  
so per definition, each output has 1 script, hence 1 address
the scenario you are describing would imply, that there will be 10 outputs in the tx (1 output for each tx)
but I'm wondering, how it's possible, that multiple addresses are involved in the same output. since each output has 1 script, and the address represents the hashed script..
@_date: 2018-11-14 15:19:49
isn't Bech32 also a kind of segwit address? this is so confusing
@_date: 2018-11-15 08:48:17
very helpful comment, thanks ;)
@_date: 2018-11-14 15:42:28
As far as I understand, that's a implementation of a bitcoin client, which has to be set up.
But I'm looking for a existing API that I can connect to.
@_date: 2018-11-14 13:04:09


which one?
@_date: 2018-11-07 11:39:10
thanks a lot
for completeness, here is a copy of said wallet commands:
== Wallet ==
abandontransaction "txid"
addmultisigaddress nrequired \["key",...\] ( "label" "address\_type" )
backupwallet "destination"
bumpfee "txid" ( options )
createwallet "wallet\_name" ( disable\_private\_keys )
dumpprivkey "address"
dumpwallet "filename"
encryptwallet "passphrase"
getaddressesbylabel "label"
getaddressinfo "address"
getbalance ( "(dummy)" minconf include\_watchonly )
getnewaddress ( "label" "address\_type" )
getrawchangeaddress ( "address\_type" )
getreceivedbyaddress "address" ( minconf )
getreceivedbylabel "label" ( minconf )
gettransaction "txid" ( include\_watchonly )
importaddress "address" ( "label" rescan p2sh )
importmulti "requests" ( "options" )
importprivkey "privkey" ( "label" ) ( rescan )
importpubkey "pubkey" ( "label" rescan )
importwallet "filename"
keypoolrefill ( newsize )
listlabels ( "purpose" )
listreceivedbyaddress ( minconf include\_empty include\_watchonly address\_filter )
listreceivedbylabel ( minconf include\_empty include\_watchonly)
listsinceblock ( "blockhash" target\_confirmations include\_watchonly include\_removed )
listtransactions (dummy count skip include\_watchonly)
listunspent ( minconf maxconf \["addresses",...\] \[include\_unsafe\] \[query\_options\])
loadwallet "filename"
lockunspent unlock (\[{"txid":"txid","vout":n},...\])
removeprunedfunds "txid"
rescanblockchain ("start\_height") ("stop\_height")
sendmany "" {"address":amount,...} ( minconf "comment" \["address",...\] replaceable conf\_target "estimate\_mode")
sendtoaddress "address" amount ( "comment" "comment\_to" subtractfeefromamount replaceable conf\_target "estimate\_mode")
sethdseed ( "newkeypool" "seed" )
setlabel "address" "label"
settxfee amount
signmessage "address" "message"
signrawtransactionwithwallet "hexstring" ( \[{"txid":"id","vout":n,"scriptPubKey":"hex","redeemScript":"hex"},...\] sighashtype )
unloadwallet ( "wallet\_name" )
walletcreatefundedpsbt \[{"txid":"id","vout":n},...\] \[{"address":amount},{"data":"hex"},...\] ( locktime ) ( replaceable ) ( options bip32derivs )
walletpassphrase "passphrase" timeout
walletpassphrasechange "oldpassphrase" "newpassphrase"
walletprocesspsbt "psbt" ( sign "sighashtype" bip32derivs )
@_date: 2018-11-07 15:06:43
Also, what's the difference of connecting to a 3rd party btc node and eth node, for example? Everyone uses services like infura on ethereum, so how does this pair up with btc from a security perspective?
(I understand that this is the BTC subreddit, but it'd still be interested to know)
@_date: 2018-11-15 12:53:59
Ahhh great stuff, thanks!!
@_date: 2018-11-14 15:36:48
@_wlc_ yes, but still, the graphic is confusing
it should be
- legacy =&gt; legacy (p2pkh)
- segwit =&gt; segwit (p2wpkh)
- bech32 =&gt; segwit (bech32)
(correct me if I'm wrong)
@_date: 2018-11-07 11:36:50
Thanks a lot for that information.
So basically, in case of a wallet app there are two options:  
1. run a dedicated node for the wallet app
2. use SPV
But I shouldn't rely on any 3rd party bitcoin node, for security and privacy reasons.
@_date: 2019-01-22 08:21:19


Thank you! I'll have another debug session and check again then.  
@_date: 2018-11-15 08:47:17
\&gt; Take a look at Sentinal.  
Are you talking about [this project](
\&gt; Also maybe btcd.
I only tried \`bitcoind\` so far, but if I can't find an existing service that is reliable, I'll might setup my own \`btcd\` node instead. Thanks!
@_date: 2019-01-28 10:21:58






thanks bro
@_date: 2018-11-22 22:01:31
nice! cool stuff, thx
@_date: 2018-12-03 12:01:57
ps - here a detailed code example, how a p2pkh address is constructed
@_date: 2018-12-03 14:26:31
Interesting, thx!  


So that means, Alice will decode the base58-encoded address back to the "original" hashed public key (pubKeyHash). Basically, if I want to enable the HTLC to support p2pkh addresses, I have to do exactly that, right?  
Any good sources on how to do this? So far I've only found information on how to encode it (pubKeyHash =&gt; p2pkh addres), rather than the other way round.
@_date: 2018-12-03 15:23:37


Sure, it only works for p2pkh addresses. :)


Why are p2wpkh considered legacy? It's one of the segwit-supported addresses, so it should be considered a "new" one and rather the p2pkh a legacy, as far as I understand, no?  
I implemented it in js using the `bs58check` npm package:
`const p2pkhToPubKeyHash = (p2pkh) =&gt; {`  
 `const decoded = bs58check.decode(p2pkh);`  
 `const decodedWithoutVersion = decoded.slice(1);`  
 `return decodedWithoutVersion;`  
Works fine, thank you.
@_date: 2018-12-03 11:54:01
This is interesting. If p2pkh addresses are reused, it reveals the publickey? Do you know good resources to read up on this in more detail by any chance?
@_date: 2018-12-03 11:50:17
No, that's not the complete truth. A p2pkh address is a pubkey hash (`OP_HASH160`) **AND some additional information**, namely the **version byte** and a **checksum** being **base58 encoded**.So since people are familiar with their p2pkh addresses rather than the "naked" hashed pubkey, it would make more sense from a usability perpective to support p2pkh addresses in HTLC transactions.






&amp;