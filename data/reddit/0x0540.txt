@_author: 0x0540
@_date: 2013-04-28 00:46:11
The txin script of the winning transaction does not contain the block's hash, but the block header of the genesis block. (You can see this by comparing blk0001.dat with the script in a hex editor)
When validating the transaction, the txout script of the sending transaction is appended to the txin script of the winning transaction:
0100...dac2b7c OP_HASH256 6fe28... OP_EQUAL
This expression is evaluated like this:
* Push 0100...dac2b7c on the stack
* Pop 0100...dac2b7c from the stack and push SHA256(SHA256(0100...dac2b7c)) on the stack
* Pop the top element of the stack and check if it equals 6fe28....
Thus, in order to redeem the BTC, you had to find some bitstring b with SHA256(SHA256(b)) = 6fe28...
Since 6fe28... is the SHA256(SHA256()) hash of the genesis block's header, the winner just had to put the genesis block's header into the txin script.


Yes, if the redeeming transaction is not yet included into the blockchain, the attacker can simply submit a competing transaction that sends the BTC to another address. If a miner includes the malicious TX instead of the original one, the coins obviously go to the attacker :-)
If there are enough of those transactions, it becomes feasible for miners/pools to automatically forge those transactions.
However, if an attacker has enough hashing power to generate blocks faster than the network for a few blocks, he can steal the BTC even if the redeeming tx has been included into a block.
In order to do this, he would just fork the blockchain, modify the redeeming address and publish the modified blockchain, orphaning the block where the original redeeming tx occured.
This is very similar to a regular double spending attack, however, when using signed (normal) transactions, the attacker is limited to double-spending his *own* coins because he can't change the receiving addresses in signed transactions without breaking the signature.