@_author: nsa_at_home
@_date: 2014-06-05 06:16:13
I think the problem with a lot of Bitcoin advocates (at least the ones I've run into) is that they're too "in your face" about it, and go straight into the value increasing, technical jargon, decentralization, why fiat currencies are made by the devil, etc.
There's no way I can convince anyone of anything in 15 seconds. So if I want to get the idea of Bitcoin into people's heads, I just have a casual conversation with them and talk about my positive experiences with it. I don't try to convince them of anything.
*"So I sent $2500 to a friend in &lt;some other country&gt; last night."*
*"Oh yeah?"*
*"Yeah I transferred it using Bitcoin. If I had done it using my bank account it would have cost me about $25. And it was nearly instantaneous."*
*"But how did you get your Bitcoins? Do you have to buy them?"*
*"Oh I use &lt;Bitcoin exchange of choice&gt; to exchange money from my bank account into Bitcoins. It's not much different from converting dollars to any other currency."*
And just carry on the conversation from there..
@_date: 2014-06-12 21:57:59
This is false. It is 1 to 1, so it is a bijection.
The public key is the product of *k* and point *G* where *G* is a generator of a group of order *n*, and 1 &lt; *k* &lt; *n*. Therefore for each *k* there is a unique *Q* such that *Q* = *kG*.
@_date: 2014-07-12 03:21:23
I am going by what I know. I can't say for certain it would happen exactly like this since it is all theoretical at this point. But if you want to nit-pick at my choice of words instead of backing up your claims or refuting mine, that's fine.
@_date: 2014-04-16 02:51:05
Why doesn't your site or API use HTTPS?
@_date: 2014-06-07 23:36:38
US doesn't have an extradition treaty with Ukraine.
@_date: 2014-06-08 04:33:34
Hackers HATE him!
@_date: 2014-06-01 22:51:48
The price should be whatever the supply and demand says it should be. 
@_date: 2014-08-02 17:39:16


Doesn't matter what the purpose of the work is. The point is the minimum amount of energy it would require to flip through a number of bits. While theoretically possible (physics allows it), there are serious practical barriers to doing 2^128 work.


160 bits is actually higher than the security level of a Bitcoin address. The 256-bit elliptic curve Bitcoin uses has 128 bits of security.
@_date: 2014-04-10 13:20:59
That is the order (number of points) of the elliptic curve group used by Bitcoin.
When you perform the group operation that many times, you end up at the identity element where x = 0, y = 0.
@_date: 2014-06-03 18:43:18
Bah gawd, that man has a family!
@_date: 2014-05-29 04:54:19
[Data encrypts his wallet](
@_date: 2014-06-05 07:47:40
*Hey babe, wanna see that 9 bits looks like?*
@_date: 2014-06-05 13:17:26
Silver came before Gold. With Gold they just added a lousy ~~34~~ 32 protons and electrons.
EDIT: I can't math and science today
@_date: 2014-07-14 00:10:36
Yeah. I've just never seen it used in this context.
@_date: 2014-08-02 18:11:57
I'm guessing it surpasses any distributed computing project.
For instance, Folding currently does about 45 petaflops. Assuming it has been doing that since it's start in 2000 (which it hasn't), it would have completed  around 2^70 floating-point operations by now.
@_date: 2014-06-07 15:52:03
We would've gotten away with it too if it weren't for that meddling IPv4!
@_date: 2014-05-28 06:36:16


(Link to either bitcoin wiki or general wiki would be sufficient, thank you.)
[Elliptic Curve Digital Signature Algorithm](
*k* is a per-signature value required for DSA. It must be secret, and never re-used.
The wikipedia article shows the mathematics of it. If you have two signatures that use the same *k*, then you can solve for *k*. If you know *k*, you can solve for the private key.
@_date: 2014-06-08 15:47:39
Miners already become bricks every couple years.
@_date: 2014-06-07 23:08:07
This x 1000. Public keys must always be authenticated.
@_date: 2014-07-22 23:38:52
I think you're being overly pedantic here and missing the point.
Credit cards are used for credit, but more importantly, and the topic here, is they are used as a convenient way to make payments over the internet.
The issue with credit cards is that anyone with knowledge of the credit card number and security code can make fraudulent purchases. In a Bitcoin world this wouldn't be possible, because payments cannot be made with only knowledge of the Bitcoin address.
@_date: 2014-05-27 12:57:35
Hindsight is 20/20.
@_date: 2014-10-11 23:46:15
It's simpler than that. Just generate a verifiably random point on the secp256k1 curve. The only way to know the private key is to solve the discrete logarithm for that point.
@_date: 2014-07-06 22:29:29
What's wrong with the Python community in that regard?
@_date: 2014-06-04 13:38:39
Oops, you're right. I subtracted the order, *n*, from 2^256. The private key range is in range [1, *n*-1], so I should have subtracted *n*-1.
@_date: 2014-03-27 21:51:49
Bitcoin has nothing to do with code-breaking or WW2 though.
@_date: 2014-06-01 23:36:55
The major threat from quantum computers is to the elliptic curve cryptography used by Bitcoin, since quantum computers can solve it efficiently. We'll have to move to quantum-resistant public-key cryptography.
@_date: 2014-08-31 10:16:31
@_date: 2014-06-07 16:03:26
A shill is a person who publicizes or praises something or someone for reasons of self-interest, personal profit, or friendship or loyalty.
Shilling is a verb i.e. to work as a shill.
@_date: 2014-07-15 20:29:10
Vulnerable to man-in-the-middle attack.
@_date: 2014-05-28 06:44:13
The order of the elliptic curve group used by Bitcoin is *n* = 115792089237316195423570985008687907852837564279074904382605163141518161494337, so there are 115792089237316195423570985008687907852837564279074904382605163141518161494336 possible values, since *k* is in the interval [1, *n*-1].
@_date: 2014-06-07 18:33:10


Strong crypto locking people into the friendzone.
@_date: 2014-07-15 20:41:58
Because of [Pollard's rho attack]( the attacker only needs to generate around 2^128 points to find the private key. This is a consequence of the birthday paradox.
@_date: 2014-06-04 02:19:16
Instead of letting people do what they want with their coins?
@_date: 2014-06-07 17:06:40
I'm not too familiar with it, but according to the site, the server has a 1% advantage, which means they can make money over time.
@_date: 2014-06-04 22:07:23
I'm not sure I understand this.. There is an address at the end of each chain, or do they collect the bounty after completing all the chains?
Also, why did you choose hash chains over something like a timelock puzzle based on RSA, where there is no overhead for the party creating the timelock?
@_date: 2014-06-05 07:57:10
Only if you make them feel like you're trying to convince them to switch to Bitcoin.
@_date: 2014-06-13 03:30:24
Sorry, my bad. I was off by a factor of 10 when doing:
8x10^9 * 10^17. You're right, it's 8x10^26, not 80.
Let's re-do this:
8 billion people doing 100 petahashes per second, in 1 second that is 10^17 * 8 billion = 800000000000000000000000000 = ~2^89 hashes per second. (I had this part right)
2^89 is way above what we need for a 160-bit collision. The probability here of a collision is approximately 1 - e^-((2^178)/(2^161)). Much higher than the 10^-16 probability of an extinction event that very second.
10^17 hashes per second * 8 billion people * 1000 years = **8x10^26** hashes per second * 1000 years = **25228800000000000000000000000000000 = ~2^114**
2^114 is also much higher than what we need for a collision. The probability of a collision here is approximately 1 - e ^((2^228)/2^161)).
The probability of an extinction event occurring over the same period of time is 31536000000 / 10^16 = ~10^-6.
@_date: 2014-06-03 05:39:50
Assuming 1kW per terahash, that's 100832.79345 kW, or about 100mW. So enough to power a couple thousand homes. Which isn't a lot in the grand scheme of things.
Since most hashing is done using ASICs, it's pretty efficient for the amount of work being done.
@_date: 2014-06-15 07:09:15
Close. It's Thomas Jefferson.
@_date: 2014-04-10 13:10:19
You mean it cannot be larger than 0xFFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFE BAAE DCE6 AF48 A03B BFD2 5E8C D036 414**0**
@_date: 2014-08-15 23:19:13


And I'm saying even back then, a naive C implementation of SHA-256 would get you way more than 100,000 hashes per second.


Yes it is.
@_date: 2014-07-01 21:56:03
*Shit all over* as a euphemism for risk analysis? His testimony basically said Bitcoin is highly volatile and would be a risky investment, which was especially true back in January when he wrote it.
@_date: 2014-07-06 22:12:25


It won't tear the community apart. Using women to attract people to a booth at a male-dominated conference is pretty normal and most people just accept it.
@_date: 2014-06-04 12:40:15


The hash is applied to the public key, not the private key.
@_date: 2014-06-02 06:42:25
People invested in Bitcoin predicting the price will rise significantly? Shocker..
@_date: 2014-04-10 17:07:43
That is the group order. Multiplying by that equals the point at infinity (identity element).
Consider this:
On the secp256k1 curve that Bitcoin uses, when we multiply by 0xFFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFE BAAE DCE6 AF48 A03B BFD2 5E8C D036 414**0** (group order minus 1) we get:
 x = 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798
 y = 0xb7c52588d95c3b9aa25b0403f1eef75702e84bb7597aabe663b82f6f04ef2777
If we want to multiply by 
0xFFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFE BAAE DCE6 AF48 A03B BFD2 5E8C D036 414**1** all we need to do is add the basepoint to the value we just got.
The basepoint is:
x = 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798
y = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8
Notice the x values are the same. The line between these two points is parallel to the y axis. In the elliptic curve group, adding these two points gives us the point at infinity which is not defined on the curve.
@_date: 2014-06-12 21:09:50
Even better, you can break 256-bit ECDSA with 2^128 work (Pollard's Rho attack).
@_date: 2014-06-05 04:43:54
I was referring to something like  in this paper:
Squaring is not parallelizable.
The idea is to choose a decryption exponent in the form d = 2^(2^t)   (mod phi(n)).
To decrypt the message, the receiver needs to perform 2^t squarings.
You want the recipient to do 2^40 (~1 trillion) squarings before reading the message:
n = (p - q)(q - 1)
d = 2^(2^40) (mod phi(n))
e = d^-1 (mod phi(n))
C = M^e (mod n)
To decrypt, the receiver must compute:
C^d = C^2^2^40
That is, they must square C 2^40 times before recovering the message.
@_date: 2014-06-01 04:45:54
Why aren't there wallets in the web store?
@_date: 2014-06-07 16:16:54
Master Of The Universe
@_date: 2014-04-10 20:14:25
It doesn't give any security. It's just multiplying by 1. Anyone who sees the public key will immediately know the private key is 1.
@_date: 2014-06-03 17:43:19
needs it's 2 minutes of hate. Gotta hate something.
@_date: 2014-06-12 20:47:09
The name comes from the [Birthday Paradox]( that is, "how many people need to be in a room for there to be a 50% probability that any two people have the same birthday".
It turns out that the number of people is 23, far lower than what we would intuitively think, which explains the name.
The reasoning behind this is that with each person, the number of pairs of people grows quadratically, so the probability of finding two people with matching birthdays grows very quickly.
We can apply the same logic to random functions with uniform distribution and a finite range.
In the case of Bitcoin, we hash the public key to a 160-bit address.
Since there are more public keys than addresses, there must be different public keys which hash to the same address (this is actually called the [Pigeonhole Principle]( ).
So if we keep collecting public key and address pairs and store them in a big table, we'll eventually come across an address which is already in the table, but with a different public key.
For a good chance of this happening, we need to generate about 2^80 addresses. Which is almost feasible to do. But it doesn't really affect the security of Bitcoin.
EDIT: There's some sort of black magic preventing that link from formatting properly.
EDIT: nvm.. Had the thing and the other thing mixed up.
@_date: 2014-06-08 05:48:31
A neurahlnet prahzessah. A learning computah.
@_date: 2014-08-06 04:25:29
The standard allows that? Interesting.
@_date: 2014-07-11 18:28:47


What is the incentive to loan the money in the first place if you can hold the money and have it increase in value?
@_date: 2014-06-04 17:39:47
is correct.
There are ~2^256 points on the secp256k1 curve (it's a little less, but negligible difference).
Each point is a public key with a unique private key.
Since we are mapping all the public keys to 160-bit values by RIPEMD160, there are ~2^96 public/private key pairs per Bitcoin address.
@_date: 2014-04-19 17:11:24
Should stick with the SI prefix. SI is universal. Nobody will know what "bits" means here.
@_date: 2014-08-14 02:53:54
100 kilohashes/sec is way too low for 2008 hardware. Even an unoptimized implementation would run around 1 megahashes/sec per core.
@_date: 2014-06-04 16:06:41
Yes, exactly.
Since the public key is hashed, each address can have multiple keypairs associated with it.
@_date: 2014-07-04 14:20:29


Hashes per second to Hashes per second is a direct comparison. Obviously Scrypt is different from SHA256. That's the point. However, hashes per second is far easier to increase on SHA256, as evidenced by those ASICS. From Litecoin ASIC manufacturer Innosilicon's site:
It's a meaningless comparison. Scrypt is a more complex algorithm, so ofcourse the hashrate is going to be lower.


That 2X figure is for a single chip. Miners are made up of many ASIC chips. Even Bitcoin ASICs are in the neighbourhood of 20GH/s per chip.
@_date: 2014-04-21 06:26:40
ASIC-resistant for how long? A year? 2 years?
@_date: 2014-06-13 03:31:31
Yes exactly.
@_date: 2014-06-08 16:16:17
I think this is very short-sighted. Most of the research and development has already been done. We have fast ASIC implementations of scrypt already. It's just a matter of adding more memory.
People said the exact same thing about scrypt, but after 2 years we have ASIC miners. I don't think this would be any different.
As long as there is a market and people are willing to pay thousands of dollars for these devices like they already do, someone is going to make them.
@_date: 2014-06-29 22:43:30


Have you seen what it takes to cool those chips? They're not designed for the average consumer. It has nothing to do with X86 or RISC or CISC. 
@_date: 2014-08-02 18:34:10


Wouldn't it be N if it were a hashtable?
@_date: 2014-06-05 04:54:20
I think most people would agree it's pretty cool. It's a cool idea in the same way kinetic bombardment is cool: sucks when it is used on innocent people though.
@_date: 2014-10-17 20:49:33
This is possible. You could do it with 64 lookup tables of 15 points each (one table for every 4 bits in the private key).
The idea is to calculate G, 2G, 3G .. 15G for the first lookup table.
Double each of those points 4 times, that is compute 16G, 48G .. 240G for the 2nd table.
Keep doing that to generate the rest of the tables.
To compute the public key, look up every 4 bits of the private key in the corresponding table and add the point. In all you'd be doing at most 64 point additions.
Larger tables will use more memory, but will require less work during the computation.
@_date: 2014-06-12 22:38:51


I know this his probably hyperbole, but lets see.
8 billion people doing 100 petahashes per second, in 1 second that is 10^17 * 8 billion = 800000000000000000000000000 = ~2^89 hashes.
Now doing that for 1000 years, 
10^17 hashes per second * 8 billion people * 1000 years = 80^26 hashes per second * 1000 years = 
953117116184173641338349158400000000000000000000000000000000 = ~2^199 hashes
In both cases, the probability of finding collisions in those timeframes is very very very close to 1. Ridiculously close. Ludicrously ridiculously close.
@_date: 2014-07-01 00:30:55
I don't see what the difficultly is.
Should just be a smartcard with your private keys on it. Retailers who want to accept Bitcoin setup a Rasberry Pi + smartcard reader.
@_date: 2014-06-01 23:16:13


I can imagine people in the future with their quantum desktop computers digging through the blockchain for old addresses that didn't move their coins to quantum-resistant addresses.
@_date: 2014-04-10 19:43:22
It really depends on how its interpreted. Like you mentioned, it says any number "between" 1 and the order. Multiplying by 1 gives you the basepoint, and multiplying by the order gives you the point at infinity. For clarity they should write something like:
1 &lt; *k* &lt; *n* where *k* is the private key and *n* is the group order.
@_date: 2014-07-23 01:22:54
Could you link me to it?
@_date: 2014-06-03 22:06:33
Eventually he will own the house and not have to make mortgage payments.
He can get a good interest rate that will be lower than the rate of inflation, so the value of the money he is paying on his mortage will actually go down, while the dollar value stays the same. Rent increases with inflation and cost of living.
After he owns his house, he can even buy another house and rent out the first one to help pay for the 2nd one.
When you account for all the costs, owning is much cheaper in the long run.
@_date: 2014-07-15 22:31:32
Pollard's rho for discrete logarithms is a general method for solving discrete logarithms (he also has one for integer factorization based on the same principle).
The goal is to recover the private key when given the public key.
We are given *P* = *kG* where *P* is the public key, *k* is the private key and *G* is the generator of the group.
Instead of trying every single *k*, we can turn this into a collision problem by finding two colliding points in the form of:
*aG* + *bP* = *cG* + *dP*
After we do this, we can solve for *k*:
*aG* + *bkG* = *cG* + *dkG*
*aG* - *cG* = *dkG* - *bkG*
*(a-c)G* = *(d-b)kG*
*(a-c)(d-b)^-1* = *k*
Because we are trying to find any two pairs, we only need to generate around 2^128 points to break the 256-bit cryptosystem.
@_date: 2014-07-21 14:14:27
This is correct except there is no division involved. Must use the multiplicative inverse.
@_date: 2014-04-19 21:49:40
It's not natural at all. It gives no indication of the value. The SI units on the otherhand are universal and indicate relative value.
@_date: 2014-06-04 05:34:50


I'm nit-picking here, but the actual range for private keys on the secp256k1 curve is in the range of 1 and 
115 quattuorvigintillion 792 trevigintillion 89 duovigintillion 237 unvigintillion 316 vigintillion 195 novemdecillion 423 octodecillion 570 septendecillion 985 sexdecillion 8 quindecillion 687 quattuordecillion 907 tredecillion 852 duodecillion 837 undecillion 564 decillion 279 nonillion 74 octillion 904 septillion 382 sextillion 605 quintillion 163 quadrillion 141 trillion 518 billion 161 million 494 thousand 336.. just 432420386565659656852420866394968145599 shy of 2^256.
@_date: 2014-07-22 22:48:59


Realistically, how would someone buy a house (or buy any very expensive item) in a Bitcoin economy?
@_date: 2014-06-04 23:15:56
It's not the same without the ambient T-1000 music though.
EDIT: [
@_date: 2014-05-31 08:13:10
@_date: 2014-04-10 03:21:33
If she was, then OP would have already done it. 
@_date: 2014-07-11 20:16:06
But the lender can hold onto their money and it will increase in value, risk-free. Loaning money is inherently risky.
I also believe you're incorrect when you say the borrower is more likely to pay back the loan. I think they are less likely to be paid back because as the value of the currency increases, wages will decrease. So if the borrower's wage is 4000/month and their mortgage is 1000/month, and over the years the value of the currency increases by 50% (for instance), then they're going to be earning 2000/month with a mortgage of 1000/month.
@_date: 2014-07-01 20:31:50
I have to agree with this. Why is he singled out exactly? Because he made one incorrect prediction..?
@_date: 2014-03-27 18:39:48
How does that seem reasonable (serious question)?. Bletchley Park is to celebrate WW2 code-breakers...
@_date: 2014-08-02 17:56:38
It's one of Schneier's greatest quotes, IMO.
@_date: 2014-09-29 06:20:57
There is at typo:


Should be "eight 4-byte inputs"
Also, there is no mention of the message expansion step.
@_date: 2014-06-01 00:11:43
Yeah. I cringed when he had to copy and paste the public keys into notepad when he should have been able to select multiple and click a button to create a lockbox or something. But it says experimental feature, so hopefully they will fix this.
@_date: 2014-06-04 17:28:46
You may also be interested in knowing that your private key never had &gt; 160 bits of security to begin with. secp256k1 has a 128-bit security level.
@_date: 2014-07-23 01:06:18
Where, exactly? I skimmed through the FAQ but there doesn't seem to be anything about borrowing/loaning..
@_date: 2014-06-06 13:36:29
Reminds me of that George Carlin standup on prisons.
@_date: 2014-07-23 01:00:28
The problem with credit cards has nothing to do with credit and everything to do with lack of built-in security features, which is the point OP was trying to make.
@_date: 2014-06-08 04:13:07


Can't even see the tread marks.
@_date: 2014-07-12 19:40:47
Is this really a fair comparison?
If they're going to argue for the sustainability of Bitcoin, they should consider how much infrastructure is currently in place to handle all financial transactions, trades etc globally, and compare it with the Bitcoin alternative.
@_date: 2014-07-13 23:55:02
I'm confused. Where are you getting 1 yottahash from? The current hashrate is around 140 petahashes. So it's about to jump 7000000x in a few days?
EDIT: Nvm. You mean to construct the entire chain. Makes sense.
@_date: 2014-06-12 21:23:18
There's a 1 to 1 relationship between private keys and public keys.
You can have multiple keypairs map to one address though.
@_date: 2014-06-04 17:54:30
Less security per bit :)
secp521r1 will give you 256-bit security, as will 15360-bit RSA ;)
@_date: 2014-08-05 21:44:41
Close. Private keys and public keys are 1 to 1. There are a little under 2^256 unqiue private/public key pairs. Since the public key is hashed to a 160 bits address, that makes about 2^96 keypairs per address.
@_date: 2014-08-02 18:25:06
But it is on topic. The same principle applies whether we are talking about brute-forcing an encryption key, or hashing blocks for Bitcoin. Bitcoin takes a brute-force approach to find valid hashes anyway.
@_date: 2014-06-02 05:28:10
But they can account for the major ones. This isn't some corner case. This is trying to spend more funds than you have, which is one of the most obvious things to test.
@_date: 2014-06-04 06:15:08
I think I understand what you were referring to.
For a good chance of collision in a 160-bit hash function e.g RIPEMD160, you need about 2^80 messages.
The Bitcoin network is currently running at a rate of about 100 petahashes per second.
2^80 / 10^17 hashes per second = ~12089258 seconds (140 days) to create 2^80 messages.
So if we were generating addresses at a rate that the Bitcoin network does hashing (i.e. 100 peta-keys per second), then after 4.6 months we'd start seeing colliding addresses, and as time went on they would actually start appearing much more frequently.
This is completely theoretical though. The Bitcoin network isn't set up for doing this. The hashrate comes from hashing transactions, not generating addresses. This type of scenario also doesn't help find specific private keys, it will only find two arbitrary key pairs with the same address. Recovering a private key for a specific key pair would require 2^160 hashes, which is not feasible, and there are more efficient attacks for that anyway.
@_date: 2017-08-29 11:49:24
1 - (1 - 1/18 billion)^144 = ~8 x 10^(-9) every day
1 - (1 - 1/18 billion)^52560 =  ~3×10^(-6) every year.
Math checks out.
@_date: 2015-08-03 04:33:06
Not sure why you are being downvoted. If we're talking about a future where we have quantum computers that can solve discrete logarithms, then it's reasonable to think we could have quantum computers that can run Grover's algorithm on a domain size of 2^160.
@_date: 2017-11-11 00:16:01
More like the Terminator. Holy shit.
@_date: 2015-08-02 06:15:31
2^256 - 2^32 - 977 is the prime modulus.
The order of the curve, which determines the number of possible keys, is 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141.
@_date: 2015-08-03 05:50:32
Paycoin still exists but it isn't worth anything.
@_date: 2017-11-02 03:42:32
It's a good a time as any. Don't try to time the market.
@_date: 2018-02-28 16:08:14
This is going to be a fun thread.
@_date: 2013-08-11 01:44:17
ECC uses a different group. The group they're refering to is Zp (integers mod prime number p) e.g the group used for standard Diffie-Hellman. (Correct me if I'm wrong here) If there is a general method for computing discrete logarithms efficiently, then RSA is also broken since the private exponent can be solved for.
@_date: 2013-08-17 17:57:47
The crypto primitives will probably stay strong for the foreseeable future.
The real weakness is going to be in the implementations, as we've recently seen with Android's PRNG. There is *a lot* of badly implemented crypto out there. And with so many different implementions of Bitcoin, the attack surface is huge.
@_date: 2013-08-19 00:32:39
Collision attacks are already O(N^1/2 ) because of the birthday paradox.
Grover's algorithm will allow you to do a pre-image or 2nd-preimage attack in O(N^1/2 ), but will it speed up the case of finding *any* pair of messages which hash to the same value faster than O(N^1/2 )? 
According to [this page]( a collision search on a quantum computer has complexity of O(N^1/3 ). Neat.
@_date: 2013-10-26 06:49:53


Scalar value.. single number, opposed to an [x,y] point.




The probability of 256-bit values colliding is very low. But the RNG is outside the scope of the algorithm. 


In order to use ECC, both parties must be using the same curve, or else the math won't work. There are a lot of parameters that define a curve, and generating good ones can be tricky and time consuming. So instead, we have standard curves with pre-defined parameters. That way people only need to look at the name of the curve to use instead of negotiating new parameters all the time. [this document]( contains many of the standard curves and their parameters.
After a curve is agreed upon, both parties need to agree on a base point. This is the value that gets multiplied by the private key to generate the public key. To make things even easier, the base point is also included in the standard set of parameters.
The base point is the point *G*:
Alice has private key *a* and public key *A* = *aG*, Bob has private key *b* and public key *B* = *bG*
They exchange public keys and multiply with their private keys.
Alice computes *aB* = *abG*
Bob computes *bA* = *baG*
Thus, they end up at the same point which they use as a shared secret.


The base point can be almost any point on the curve. People often question the curve parameters. You'll get a different answer depending on who you ask about which standard :) Most people agree that the NIST curves are safe. Others (e.g. Daniel J. Berstein suggest using different curves). Some governments also use their own curves.
@_date: 2013-08-18 20:06:14




2^32 x 136 years = 584,115,552,256 years...
@_date: 2013-08-25 20:32:45
@_date: 2013-12-21 10:29:25


There isn't a single academic study to support this. The sentiment among most cryptographers is that the curve parameters are not mallicious. And historically, the NSA has made algorithms mathematically stronger (DES, SHA-1), not weaker.
But it it doesn't matter how they chose them, people would *still* be claiming there must be a backdoor *somewhere*.
@_date: 2013-12-21 06:41:11


Bitcoin doesn't specify which RNG to use for keypair generation. Even if it did, it wouldn't matter, and wouldn't stop anyone from using a different RNG.
@_date: 2013-08-18 20:18:16
But then signature verification will pass for some and fail for others depending on which public key they are using for verification. What happens in this case?
@_date: 2013-08-18 18:39:18
What's the point of brute-forcing a bitcoin address?
@_date: 2013-08-12 12:31:48
Or from any other broken implementation.
@_date: 2013-08-18 19:10:26
You sure about that?
@_date: 2013-08-11 16:15:14
It must be secret and unpredictable. Knowledge of k breaks the scheme.
@_date: 2013-12-19 17:13:20
USD/BTC = USD per bitcoin.
At the time, it was $572 per bitcoin.
@_date: 2013-08-11 04:26:47
I think you're referring to Eric Bach's paper [Discrete logarithms and factoring](


@_date: 2013-08-24 17:24:59


This is assuming the private key was generated securely, and the signature was generated securely. It's remarkable how insecure many secure PRNGs end up being.
@_date: 2013-11-02 19:16:12
Usually basepoint *G* doesn't change.
You could use a different basepoint *G*for every key pair you create, you just need to communicate that basepoint as part of your public key along with the curve parameters.
@_date: 2013-08-24 01:59:28
No need to counterfeit. All it takes is a bad crypto implementation and Bitcoin are vulnerable to theft.
@_date: 2013-08-16 13:43:07
Sounds interesting. Do you have a link to it?
@_date: 2013-08-18 21:12:44
Grover's algorithm will speed up pre-image attacks quadratically, but will those pre-images be meaningful? Hash functions are not bijective so only a subset of the pre-images will be valid.
What does Grover's algorithm mean for collision attacks? Are they also made easier?
@_date: 2013-08-18 20:34:56
AES-256 was a requirement by NIST to resist quantum attacks.
@_date: 2013-08-12 06:31:34
Depending on how broken SecureRandom is, it might be easy to recover *k*. No need to wait for two signatures that use the same *k*.
@_date: 2013-08-18 19:35:40
Sure, 2^256 is 2^128 times larger than 2^128, but 2^128 is still astronomically huge and an impossible number of calculations to perform.
@_date: 2013-12-22 00:37:14
Even if it had no backdoor you'd have to pay people to use it because its so slow. That's the other reason nobody uses it :)
A backdoor in Dual ECDRBG is totally plasable, and actually has some research to back it up.
Placing a backdoor in an PRNG makes a lot more sense than placing a backdoor in all of ECC.
@_date: 2013-08-18 19:51:07


This is actually false.
Bitcoin uses the SECP256k1 curve. The order of this curve (number of points on the curve) is *n* = FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141, which is pretty close to 2^256.
So if you have 2^160 public keys (2^160 points), the probability of one of those keys matching your victim's key is 2^160 / *n* where *n* is the order of the curve, which in thise case is ~2^-96.
@_date: 2013-08-18 20:27:13
Is that even possible? There's actually a [physical argument]( against this.
Ciphers today are designed with 128-bit security against brute force attacks because of this.
@_date: 2013-08-18 19:37:04
Ah, I see. Thanks.
@_date: 2013-08-24 15:49:48
When money is stolen from your bank account or fraudulent charges are made on your credit card, your money is refunded and your credit balance restored. The only time usually don't get it back is when cash is stolen from you. Bitcoin is more like the latter.
@_date: 2013-08-18 19:04:27
But the address is the hash of the public key, which is public?
@_date: 2013-12-19 10:22:32
Highschool math teachers would be furious.
@_date: 2013-10-25 06:05:05


You're correct. The private key is a scalar value. The size of the private key depends on the curve. In ECC, two points on a curve can be added to produce a third point (point addition), or a point can be added to itself (point doubling). If you can add points, then you can also multiply by using repeated addition.
When you generate a key pair in ECC, you first generate the private key, *k*, and then you generate the corresponding public key, *kG*, by adding the base point *G* to itself *k* times (multiplying G by *k*). There are efficient methods to do this.


It depends on the platform. Most UNIX-like platforms have a /dev/random. Windows has their own crypto services. In any case, the private key should be generated using a secure random number generator.
@_date: 2013-12-21 06:37:27


"c49d360886e704936a6678e1139d26b7819f7e90" is the *seed* used for the RNG to generate the 'b' coefficient for secp256r1.
If you read Section 2.1 of [ you'll see:


chosen from a seed using SHA-1 as specified in ANSI X9.62 [X9.62]. This process ensures that
the parameters cannot be predetermined. The parameters are therefore extremely unlikely to
be susceptible to future special-purpose attacks, and no trapdoors can have been placed in the
parameters during their generation. When elliptic curve domain parameters are chosen verifiably
at random, the seed S used to generate the parameters may optionally be stored along with the
parameters so that users can verify the parameters were chosen verifiably at random.
Here verifiably random parameters have been chosen either so that the associated elliptic curve
has prime order, or so that scalar multiplication of points on the associated elliptic curve can be
accelerated using Montgomery’s method [Mon87]. The recommended verifiably random parameters
were chosen by repeatedly selecting a random seed and counting the number of points on the
corresponding curve until appropriate parameters were found. Typically the parameters were
chosen so that a = p − 3 because such parameters admit efficient implementation. For a given p,
approximately half the isomorphism classes of elliptic curves over Fp contain a curve with a = p−3.
So they chose random seeds until the curve met the criteria. Nothing suspicious about it.
Please stop spreading FUD.
@_date: 2013-10-29 13:18:12


Given *G* and *aG*, it's difficult to find *a*. There is no efficient solution to it. That is the elliptic curve discrete logarithm problem. 


@_date: 2013-08-21 01:25:16
It's a *huge* issue. Waiting for 2 signatures with the same *k* value isn't the only way to exploit this. If the RNG is weak (as it is in this case) and the *k* value can be guessed, then the private key can be found and it's game over.
This is the nature of [EC]( *k* must be random and secret.
@_date: 2013-08-17 18:03:30


We don't have mathematical certainty. What we have are problems like the elliptic curve discrete logarithm problem that are conjectured to be hard to solve and have no efficient solution so far.
@_date: 2013-08-16 13:16:18
By design trying every possible key is infeasible because of the number of keys (2^256 keys).
The best attacks against ECC so far break it in sqrt(*n*) work where *n* is the key length. So the secp256k1 curve that Bitcoin uses has 128 bits of security.
Quantum computers can break ECC efficiently though.
@_date: 2013-08-16 19:11:11
SECP256k1 is broken in 2^128 work anyway. So you're still doing 2^32 times more work than you need to ;)
@_date: 2013-12-22 00:27:00


You're implying a backdoor *must* exist. It may be that it mathematically cannot exist.
Do you then believe that *all* NSA created and approved algorithms must have some backdoor in them?
@_date: 2013-08-18 19:00:07
It's less about AES and more about the magnitude of the number. The same thing can be applied to SHA-256: If you had one SHA256 hash, and wanted to find a message that hashed to the same value, it would take 2^256 guesses (2^255 on average).
Modern cryptography is designed to make brute-force attacks impossible. It's very easy to do since the keyspace grows exponentially with each bit.