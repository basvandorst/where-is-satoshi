@_author: nullstyle
@_date: 2014-02-02 19:42:04
Transactions won't actually protect you by default, you have to use them correctly... for example, if this truly is Coinbase I know for a fact portions of their code are written on top of rails, which by default will wrap any model save in a transaction, but however offer no protection out of the box for race conditions such as this.
As you say, locking in some form (either optimistic or pessimistic would work) is the simplest solution.  You could additionally got the full additive route (where every transaction that affects an account's balance is an additional row insert) and then configure a check constraint upon row inserts that would reject any insert that would put the account in question into a negative balance. Or, you could easily write your queries as delta operations instead of "set the balance to this number"-type queries.  There are lots of solutions to this problem, the point is that lazy programmers are susceptible to this problem.
@_date: 2014-02-02 17:58:56
Its actually not that hard if you use the right technique.  When you consider that most web applications wont process an HTTP request until the final byte is received, what you do is open up 20 or so requests against their servers, forgo sending the final byte for any request until they all have transmitted everything else, then send the final byte in parallel.  The application servers will then race as quickly as they can to fulfill the requests.
There was a time, for example, in some stupid farm simulator game that you could easily build many multiple buildings on the same plot by using this simple technique.  Its worth noting that with one of several simple fixes this technique is rendered useless.  this is just about the simplest race condition to fix in engineering.
edit: spelling
@_date: 2014-02-02 18:12:18
I would bet that the jitter in their application response time in greater than the jitter of sending 1 byte from the same source to the same location over an already established connection.  Networks really are quite fantastic these days, especially compared to the state of most custom software (in my experience, at least)
Im also betting the withdraw action is particularly bad performance-wise for an exchange... It probably interacts with more external systems than the sell order: a db, possibly a memcache, a bitcoin client to post the withdraw to a transaction, an auditing system or logging system.  Compared to the trading engine which is probably the fastest piece of the application, its easy to understand how this happens.
@_date: 2014-02-03 20:27:15
Choosing serializable isolation, IMO is tantamount to locking.  InnoDB for example, simply converts plain SELECT statements to a locking SELECT when in this mode.
You don't need to implement the locks yourself, but you do need to tell the DB you want them. That was my point.
