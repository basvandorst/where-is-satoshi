@_author: pavelak
@_date: 2015-02-18 00:27:25
I quickly skimmed the article, I'll try to answer with my minimal understanding.
**Clock Cycles**
As someone said earlier, you could increase clock cycles if the adder had a lower propagation time. This particular adder they outlined was not sequential logic, just combinational. So no clock is required to operate a adder
**Gates are saved**
If this was a material optimisation problem then you could say that lower gates is better. But whats important is the how many gates you need to go through to reach your answer. So think about it in terms of propagation time. (*hypothetical numbers incoming!*) Lets say you used twice the amount of material but it finished 4 times faster, then would that be a trade off worth taking? Probably. You just have to make the template (or program the FPGA) right.
Adding ridiculously big numbers can be an issue for ripple adders, hence the reason for carry look ahead. 
I would also wonder why they wouldn't be using [Carry-select adders]( which while requiring more hardware would parallelise the adding of of 256-bit number. Hence why video cards are much better with doing math with ridiculously large numbers and matrices while our CPUs do a different job.
**Energy Saved**
When a bit is lost there is a very small amount of energy lost which adds up over time. If you plan to reduce that you need to think about it in terms of how many times you force a bit to 0. A change of voltage from logic high to 0v will cause whatever is between there to act as a power dissipator (p = iv) and thats what will generate heat. And that will depend on the problem, just like any other processor will get hot under load, but run cool while idle. I don't have the knowledge to answer how much you would save but i remember my professor once mentioning how many joules per bit removal, so it would be possible to calculate it. However if you need to preform error calculation as it states, you may not be able to gain energy saving.
Uh... haha, I'm just going to guess here too. Buuuut...
[Googled an image of a standard 4-bit CLA](   
[This reduced CLA which is 4-bit plus carry (5th bit)](
There seems to be less gates, but that doesn't mean everything, so I looked up transistor level design of the logic and found that they don't use any more efficient gates than the other (If it used NAND, it would be a different story I guess, very minimal transistor level design)
So my only thought on the space reduction is saving a gate here and there over a 256bit adder (SHA-256 summing I assume) then it helps and does create that tiny bit of space saved. That would explain why it was only 2% rather than confidently larger. All its supposed to be is a *reduced* CLA, so I would assume taking out parts is the point. As well as less parts create less propagation delay.
End of my speculation. 