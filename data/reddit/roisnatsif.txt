@_author: roisnatsif
@_date: 2018-02-23 20:50:38
After doing some more reading:
"Private parent key → private child key
The function CKDpriv((kpar, cpar), i) → (ki, ci) computes a child extended private key from the parent extended private key:
Check whether i ≥ 231 (whether the child is a hardened key).
If so (hardened child): let I = HMAC-SHA512(Key = cpar, Data = 0x00 || ser256(kpar) || ser32(i)). (Note: The 0x00 pads the private key to make it 33 bytes long.)
If not (normal child): let I = HMAC-SHA512(Key = cpar, Data = serP(point(kpar)) || ser32(i)).
Split I into two 32-byte sequences, IL and IR.
The returned child key ki is parse256(IL) + kpar (mod n).
The returned chain code ci is IR.
In case parse256(IL) ≥ n or ki = 0, the resulting key is invalid, and one should proceed with the next value for i."
I take this to mean that once I pose any private key, the subsequently generated keys can be found?
What would this mean for other coin in the hot wallet with the same seed?
Thanks again
@_date: 2018-02-24 14:00:39
Right, that's actually specifically why I asked this question. 
After moving all my BTC (some to a hardware wallet and the rest consolidated to the newest address in the same deterministic hot wallet) I claimed shitcoins by inputting my old private keys in Bither then transferring to Bitpie. 
It worked great but I don't know if I can trust Bither or even the laptop I used and so I wonder if it's safe to leave BTC at the newest address in the deterministic wallet.
@_date: 2018-02-24 13:46:25
Great read. Thank you
@_date: 2018-02-23 20:59:56
After doing some more reading: 
"Private parent key → private child key The function CKDpriv((kpar, cpar), i) → (ki, ci) computes a child extended private key from the parent extended private key:
Check whether i ≥ 231 (whether the child is a hardened key). If so (hardened child): let I = HMAC-SHA512(Key = cpar, Data = 0x00 || ser256(kpar) || ser32(i)). (Note: The 0x00 pads the private key to make it 33 bytes long.) If not (normal child): let I = HMAC-SHA512(Key = cpar, Data = serP(point(kpar)) || ser32(i)). Split I into two 32-byte sequences, IL and IR. The returned child key ki is parse256(IL) + kpar (mod n). The returned chain code ci is IR. In case parse256(IL) ≥ n or ki = 0, the resulting key is invalid, and one should proceed with the next value for i."
I take this to mean that once I post any private key, the subsequently generated keys can be found?
What would this mean for other coins in the hot wallet with the same seed?
Thanks again