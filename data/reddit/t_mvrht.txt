@_author: t_mvrht
@_date: 2018-09-22 12:03:24










OK, this is getting weird. I checked the message he posted here, and the hash that leads to the originstamp.org timestamping service. It says the hash was submitted September 17, 2018 12:54:19 UTC, that's more than 2 hours before the September 17, 2018 14:57 UTC disclosure.
Are you saying he colluded with originstamp.org to display a fake submission time? I don't like bcash either, but this seems like a stretch to me, and I think the burden of proof is on you if you're accusing him of lying.
* awemany's post here: [
* originstamp.org submission [
* official submission timeline [
(to make sure the times on originstamp.org are indeed in UTC, I also checked that the timestamp on block  really matches September 18, 2018 06:13:36)
@_date: 2018-09-23 01:00:36


You misunderstood that part, I probably should have been clearer. The 3rd party I'm talking about there is originstamp.org, not Slack! The attestation is [right there on the very page Belcher was referring to]( just scroll down. I mentioned the Slack thing as a bonus, where you have multiple independent 3rd parties confirming the submission.
If Belcher didn't notice that, that's OK, it's easy to miss like you did. But intentionally ignoring it and focusing on the failed blockchain attestation is just disingenuous, and I won't go down that path.
@_date: 2018-09-22 01:53:12
I can confirm it checks out. If anyone has trouble verifying this, use UNIX line endings, and a trailing newline.
@_date: 2018-09-22 21:13:33


I still have to disagree. Let's think about what are we trying to prove here. There is a hash of a message made by someone who clearly knew about the vulnerability. The question is, did the author make it before it was reported to the Bitcoin Core team? That is, did this hash exist in any form at all before September 17, 2018 14:57 UTC?
You can't prove that purely by cryptography, you have to rely on some kind of authority attesting that this is the case. The blockchain can give you that authority (backed by the PoW), but you could also use a standard trusted timestamping authority like digistamp.com. You don't even need to use cryptography for this at all. You could spam the inbox of all people in this subreddit with the hash for a decentralized proof. You could post it on Twitter, GitHub, or Slack (which apparently he did, but I can't verify that) for a weaker proof by a centralized 3rd party.
Sure, the intent was to have a strong decentralized proof on the blockchain, and instead we have a centralized 3rd party attesting the time. But I definitely wouldn't call it bunk, it's still strong evidence to me. If more people confirm the hash existed also on the BU Slack channel, his argument becomes almost unassailable.
@_date: 2017-12-24 14:48:53
Is it that hard? 
@_date: 2018-05-21 07:23:32
I asked. Well, before that, I tried to brute force all 2\-character mistakes, and when that didn't work, I just asked the OP to check for errors.
I guess it could have occurred to someone to check 3 characters just for the case errors, but I didn't try that given there was already one letter error discovered.
In a funny way, this actually prevented people from cheating. You can easily brute force all the missing numbers \(just 9\^6 possibilities\). So OP, if you are reading this, if it's there are just 10\^9 or fewer possibilities, it's very easy to check them all in a few minutes. \(of course, you can check even more than that depending on how much processing power you have\)
@_date: 2018-05-21 18:50:08
The solution is already in the comments. But if you want to know how I specifically found out it was computation in base 60, I can tell you.
The key was the 7th row. I recognized powers of 11 which are 121, 1331, 14641 that fit the pattern so well.But I didn't get very far substituting 0\-9 for the characters.
I realized this computation works in other bases, e.g. 11 \* 11 = \(10\+1\)\*\(10\+1\) = 100\+10\+10\+1 = 1\*100\+2\*10\+1 no matter what 10 is, so I tried to count the number of different characters in case the were all a different number. I counted 58, which may or may not be correct, but from some of the relations it's clear the base must be divisible by 6, so I assumed it's base 60 and went from there.
@_date: 2018-03-23 23:10:52
replace r by c in the domain...
@_date: 2018-12-22 12:02:39
What problems? The javascript crypto API is secure, and supported by virtually all browsers. And if you don't trust the website, you can use a generator hosted directly from a public github repository.
@_date: 2018-12-22 12:18:48
I think I can deconstruct any of your objections here, but let's stick with the centralized validation.
How exactly is it "very hard" to use a full node with a paper wallet? What about "importaddress" in bitcoin-qt to add a watch address? A single command is all it takes to see your true balance without relying on block explorers.
@_date: 2018-12-22 13:18:58
Have you watched it yourself? See what he says a bit later: [
It's just a matter of opinion. Different languages have different trade-offs. I could make objections about C/C++ being bad due to buffer overflows and memory corruption.
And even if javascript is somehow the worst offender, it doesn't mean it's impossible to write secure code in it. You just need to pay extra attention, and make sure to avoid common pitfalls.