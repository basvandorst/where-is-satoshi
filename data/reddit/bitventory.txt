@_author: bitventory
@_date: 2011-11-02 15:13:03
I don't anticipate the volume needed to be sustainable as a full time project for me, at least not if/until Bitcoin takes off, and if people agree that my design is good. I just had this in my head and had to get it out into usable form, or it would have bothered me. I really want to see Bitcoin succeed, and I think services like this in some form or another need to solve the trust issue.
That said, I take a small cut of each payment sent from the site. The current transaction processor takes 0.01 and sends it to my address, but I should probably lower that when I release it for the production chain.
Also, that fee is displayed when you're asked to sign transactions, so I can't jack it up to something unreasonable without it being noticed.
@_date: 2011-11-03 13:54:27
Your summary is correct except for:


The shared secret is actually generated by a secure PRNG. This is actually a source of randomness akin to what the Bitcoin client uses for generating non-deterministic keys. However, instead of using a unique number from a CSPRNG for every key, I use that initial shared secret as the basis for deriving the latter tokens needed for key generation.
Let me know if I can clarify further. :)
@_date: 2011-11-02 17:43:29


Hi, thanks for leaving a comment instead of just dismissing it altogether. I do appreciate a chance to explain the tech.
I have the exact same concerns as you with regards to wallets which rely on client-side Javascript crypto, which is why Bitventory doesn't use it. I've developed a client-side Java applet which is completely free software, and you can audit, compile, and sign it yourself if you don't trust us. After that, you can upload it to your own hosting and update your account settings so that your applet is loaded instead of ours: [
Basically, I myself didn't trust purely deterministic wallets based on a passphrase (bccapi), nor ones which relied on client-side code that couldn't be audited or could be maliciously swapped out on the fly (StrongCoin). Bitventory is my attempt at a solution to trust with online wallets.
We don't store your coins. You don't store your coins. It's more nuanced than that. For a full technical description, check out our "About" page under "Technical Description". As an aside, you can generate your wallet 'offline' in the official Bitcoin client at absolutely anytime. If I shutdown tomorrow, your coins are still yours. The Bitventory site/webapp are more of a window into your wallet, than a wallet itself.
In my mind, if the applet can be trusted, and does what it says it does (and you are free to confirm this for yourself), then it may be more secure than the official Bitcoin client in some respects, as there is no remnant of your private keys while it's not open and unlocked.
That said, until more people look at this and see my code, I wouldn't expect anyone to put more than a small amount of coins into it for convenience across multiple computers. This is also why I'm only running an experimental testnet client right now.
If you have a moment, feel free to try it out yourself and let me know what you think.
@_date: 2011-11-02 15:15:54


Javascript can't be signed and audited. With a service such as StrongCoin, you have to hope that the operator (or an attacker) doesn't swap in malicious code. There's more on the site under the "About" tab, but I'd suggest reading this for a bit more info:


I agree with you that Java isn't ideal, but I haven't found a better solution. If you approach this from the perspective that I can't be trusted, then you immediately must assume that the Javascript can't be trusted either.
@_date: 2011-11-02 16:37:02


So, it turns out that a small change I made to the applet compiling the previous (signed) version caused a break, on all platforms, which I didn't notice in my rush to get it sandboxed. Apologies for my stupidity, but the applet *should* work now, on all platforms. I was able to fix it in the Javascript code running in the web app, so there's no need for the applet to update.
Could you let me know if you're still having problems? Thanks much for the feedback. It's been quite helpful. :)
@_date: 2011-11-02 16:21:30
Oh, funny, I didn't see that on the right side (isn't it usually the other way around?). Thanks for pointing that out.
Feel free to leave bug reports and feature requests here:
@_date: 2011-11-03 14:04:43
Yes, I actually use a small class from bccapi in the signing applet code. :)
Both bccapi and StrongCoin went public while I was in the process of working out Bitventory in my head and starting some of the initial code for it. Perhaps I should address my concerns with weaknesses with them here.
With bccapi, the wallet is purely deterministic, with a passphrase being entirely the user's, plus an optional salt (they recommend an email address). Because of this, dictionary attacks are possible. They might be computationally challenging, but certainly feasible. Bitventory uses tokens derived from a source of (pseudo-)randomness to come to a compromise between that, and entirely non-deterministic keys (used by the official Bitcoin client).
With StrongCoin, there are a few points:
* You need to perform regular backups of your wallet.
* You're hoping they don't change their Javascript to do something evil.
* You're hoping no one else changes their Javascript to do something evil.
Oh, and I haven't mentioned this yet, but Bitventory has an API that will be documented at some point in the future. The web application itself runs entirely off of it, so it's there and usable. Third parties could take my applet code and use it to derive mobile applications, desktop applications, etc, which talk to the site to do the heavy lifting. What you'd essentially end up with is something like bccapi with my changes to key generation.
But I think a web application is essential for something like this, for the convenience. It also means I can allow users to expose a set of public API calls to their account for obtaining addresses and such for donations or other purposes. But that's in the future.
@_date: 2011-11-02 17:03:34
This is a known limitation of the library I'm using (bitcoinj). I'm actually working on some code to start receiving announced but unconfirmed transactions, but it's something that's probably a week or two away. As soon as any block includes the transaction, it'll post to your transaction list within a minute of being received.
Your pending (unconfirmed) sends will, however, show up immediately.
EDIT: Also, testnet can be pretty random at times as far as generations. If it slows down today, I'll bring my rig online to start mining on it.
@_date: 2011-11-03 14:06:56
Thanks for the well wishes.
I actually just addressed StrongCoin briefly here, if you're interested:
@_date: 2011-11-02 19:30:23
The big take away from that paper for me is that the code isn't auditable. SSL + Javascript *might* be a safe bet if you trust me. But if I'm a thief, or someone compromises the site and swaps in their own wallet.js, then it all falls apart.
That's my fear with StrongCoin, for example. I had read somewhere that the Javascript doing crypto there is actually purposely obfuscated, too, which makes it worse in my opinion (is this still the case?)
With a Java applet, you can build and sign it yourself, then deploy your own copy. Or hopefully in the future, other Bitcoin developers can sign the default applet that I deploy. Then, even if someone tried to break into the web server and swap in a malicious replacement, users would find out.
After all, if someone can compromise the backend of something like StrongCoin, they may not have immediate access to private keys, but they could certainly set up some code to capture them through changes to the Javascript. Or, the operator themselves can just modify it to steal private keys.
I think if I were to replace the Java applet with anything, it would be a browser extension of some sort. But with my available resources (mostly time), the applet means I can get cross-platform and cross-browser very easily.
@_date: 2011-11-02 15:25:56


Oh, sorry about that. I can't believe the Java default is to allow access to files locally. I'm working to get that fixed asap and will update the self post when I do.


Yep, this is the big thing I talking about regarding quirks with it at the moment. I should have this improved in the near future.
Thanks for the feedback.
@_date: 2011-11-03 00:38:30


That's true. I must admit, I haven't put too much thought into the browser extension approach yet. Does that mean I should outright ignore IE users? (I might be convinced of that, actually..) :)


Yeah, I wish Java would let you disable system CAs entirely, but it seems to absorb them from the OS. If users could disable them, then they'd just need to add their own certificate as trusted.
I think one solution is to self-sign, but always check the certificate details (signature) when the applet starts up, to be sure it's yours.
The thing is that I'm using signing as a way to let a user verify that I'm not tampering with it, in the event that they're using their own compiled version of the jar. Or, to allow outside trusted parties (maybe one of the Bitcoin developers) to sign a jar and then post the signature somewhere.
There really doesn't seem to be a 'perfect' solution, unfortunately. I am entirely open to ideas, however.
@_date: 2011-11-02 16:14:49


I had a friend do a run through on Windows 7 without any issues, so I made the mistake of assuming Java was actually behaving similarly cross-platform (but my dev environment is Debian).
Could you tell me specifically which OS and browser you're using? I'll roll a VM and try it myself.


Hmm, that's strange. You're right, I hadn't even tried that. Java's UI stuff is rather quirky. I'll see if I can get that fixed.
@_date: 2011-11-02 16:30:28
Yeah, I haven't put a lot of thought into the fees yet. I mostly just put in support for it so it's something I can evaluate later.
I don't expect to make a living off of this or anything, even if it becomes popular. I'm more concerned with helping Bitcoin grow and to avoid having anymore nonsense like MyBitcoin happen again.
@_date: 2011-11-03 00:59:28






The key is derived from two chunks, the iteratively hashed email plus password (first half), and the token (second half). The applet asks the server for the tokens it needs. The server sends the tokens to the webapp, which gives them to the applet. Then, the keys are derived inside the applet.
So the initial shared secret is created by the server, then used server-side to generate tokens.
The only thing ever sent by the applet to the web server are (1) signed transactions and (2) public keys. Nothing else.


That's certainly possible, and something I've considered. The main reason for using the tokens is convenience, as the server handles that all. Thus, a user needs only to remember their passphrase. For actual usage of the site, the server holds one piece of the puzzle, while the users holds the other (although the user has all of the needed pieces in their control..but the token isn't supposed to be memorized).
I've considered adding different account options to allow a user to adjust for their level of paranoia, as each offers advantages and disadvantages.
For example:
1. Purely deterministic wallets. The keys are derived from an email+password (email is a salt to weaken dictionary attacks on the chain). This means that if the applet is trusted, I don't need to be trusted at all, as it is perfectly separated from my control (no tokens). But, targeted dictionary attacks on the chain are a reality, even with the CPU overhead of hashing.
2. The current method of email+pass+token. Destroys dictionary attacks, but the user needs to trust that the tokens I generate are derived from their secret. I can't steal their coins, but I could potentially be malicious. The user doesn't need to remember anything beyond a passphrase to access their coins.
3. Instead of server-side tokens, implement (2) with tokens derived from a secret stored on the machine or via a usb stick. The secret needs to be on any machine the user wants to use Bitventory from, or they're locked out. It sacrifices convenience for more control (possible extortion weakness is eliminated). Also, now the loss of the keyfile or passphrase renders the wallet lost forever.
If people would really like to see an option for offloading the tokens entirely to the client-side, it wouldn't be a terribly challenging thing to implement. It would, however, require local disk access, which people might not be comfortable with if it's code that hasn't yet been audited.
@_date: 2011-11-02 14:47:57
Since the self post was already long, I thought I'd expand here.
I don't expect normal users to be able to go through the motion of building and signing their own applet. Ideally, I'd like to find trusted members of the community to audit and sign the default jar, then post their certificates on their site. As part of account creation, I'd redirect them to that location for the certificate. Then, at least, casual users could have more confidence that the signing applet performs as expected. It would also keep the certificate and applet in different locations.
A few other points, before anyone asks: while I've taken the security of the site seriously, I'm a bit paranoid about the possibility of targeted attacks on the infrastructure as we've seen with other services. Beyond protecting the wallets, I also hash+salt passwords, with each user having a unique, randomly generated salt. About the only sensitive things that could leak during a compromise are email addresses and the shared secrets. In the case of the latter, my response would be to immediately regenerate a second secret for everyone and notify users that they need to migrate to the new wallet in order to avoid possible targeted dictionary attacks at users.
Seeing nearly all of the 'big' guys in the Bitcoin world face some sort of compromise has lead me to build this with the expectation that it may happen, and to plan accordingly. Although, hopefully it never should. :)
@_date: 2011-11-02 16:03:06
Good idea. I just looked at them briefly and apparently there's no free tier, which is a bit disappointing. My budget is a bit tight at the moment, so I may have to hold off for now. When I put the production client out, I may have to shell out for Get Satisfaction though (since it's great), or roll a bug tracker on the site.
For now, I can take bug reports here, via PM, and also at bugs AT bitventory.com though.
@_date: 2011-11-03 03:34:18
Here's a quick update after all of the great feedback I've received today:
Baksch's comment kind of flipped a switch in my head with regard to the previously described 'extortion' hole with the server-side token generation. While he suggested storing the secret in a key file on disk or on a USB stick and deriving tokens in-applet, why not do it one better.
I think I was being overly paranoid with keeping the secret server side and inaccessible (and generating tokens), when realistically, an attacker can query the API for any tokens they need, if they compromise the user's machine. I'm creating a big hole by trying to slap a band aid over that issue. Instead, what if I just send the shared secret directly to the applet?
The applet will receive the secret, then prompt the user for their wallet password. After unlocking, I will hash the secret+passphrase and present it to the user. If I swapped in a malicious secret, the hash will differ significantly. To ensure that someone can't attempt to create an approximate collision (something close enough to fool a user who isn't directly referencing it with what they have written down), the hash includes the passphrase, which is unknown to the service.
Doing this, no key file or outside source is needed, and Bitventory doesn't need to be trusted to generate valid tokens. There is literally no avenue of attack that I can think of, assuming the applet is secure.
I've also been notified of a patch to a library I use which can fix [this issue](
For other responses to issues, check the full [feedback forum](
Also, thanks to ripper2345 for the barrage of bug reports and suggestions. I should be plenty busy in the coming days.
Does anyone have any other feedback? I'm open to any suggestions that can improve key generation and general usability. Thanks!
@_date: 2011-11-02 20:26:37
Glad I could turn your request into reality. :)
I should mention that this isn't perfect. There is one flaw I explain in the tech description on the site, that I've been hoping someone would ask about.
I had to make a trade off between key strength and absolute trust. It's possible that I as the service operator could send down fake tokens for key generation. While it doesn't allow me to steal coins at all, it does mean that the user could lose control of the funds. If I send a token *not* derived from the shared secret, the user can't completely generate the wallet offline.
Why might I do this? Extortion. I could tell you that your money is gone unless you give me your keys, and then try to compel you to disclose your passphrase with the hope that I'll, say, give you half.
There are two possible solutions that I see:
1. I eliminate shared secrets and make keys be purely derived from an email+password. However, this seriously weakens resistance to dictionary attacks..in fact, it makes them entirely possible now.
2. I slap my name and identity all over this. While as a normal wallet that holds your money I might be able to do this and then pretend I was hacked..extortion is another game entirely. Since you have my name and address, I could face prison time for that, and there's really no way to play it off like it's someone else.
Bitventory is designed with option number two. So with this in mind, there's absolutely no way I can steal your money..but I could try to extort my users to very ill effect.
EDIT: I added a donation address to the op if you'd like to help fund development. I'm actually currently working as a freelance web developer while looking for a fulltime job, so Bitventory is currently a side project that I'm trying to allocate as much free time to as possible while still paying my bills.
Also, if anyone happens to be looking for a developer with emphasis on web dev, Bitcoin (particularly the BitcoinJ library), or medical informatics and machine learning, shoot me a PM. :)
@_date: 2011-11-02 15:39:42
Would you mind checking this again? You may need to open the Java control panel and clear your cache.
Apparently, since I had signed this (for myself during testing), the default security policy was changed. I've uploaded an unsigned version, which means it will now be sandboxed.
Unfortunately, the Java plugin for Linux doesn't seem to give me that information about permissions, so I wasn't aware of the change. :)
(As an aside, I'm working on a security policy so I can push out a signed version again.)