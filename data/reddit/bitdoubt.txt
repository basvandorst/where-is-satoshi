@_author: bitdoubt
@_date: 2015-04-25 14:27:43
In real world lotteries very often there is no winning ticket.
@_date: 2015-04-25 14:49:34
What will happen once every 1248? What model was used for one-way function?
@_date: 2015-04-25 14:55:31
cbeast or MagicalBux?
If there is no block for given set of transactions, more miners can't help. You will just come to this conclusion faster.
@_date: 2015-04-25 15:08:11
He can change time AFAIK. But it still has finite number of possible combinations.
@_date: 2015-04-25 13:45:31
Thanks. Where is this 100% certainty proved?
@_date: 2015-04-25 15:42:09
This is probably not relevant. The problem is probably equivalent to this situation:
Lottery sells ticket with numbers 1 to X. But all the winning tickets have the numbers that are larger than X. Not even one person can win the lottery in this case regardless of the number of tickets he bought and regardless of the number of winning tickets.
@_date: 2015-04-25 15:51:04
It is like flipping a coin under probabilistic model of hash functions.
@_date: 2015-04-25 16:02:07
Merkle root can have arbitrary large number of bits? Any reference for this? I think merkle roots are always 256 bits (32 bytes).
@_date: 2015-04-25 15:15:51
What vulnerability?
@_date: 2015-04-25 14:42:28
Can you please explain what you mean by "the relationship between actual difficulty and target might stop being linear anyway"?
For very high difficulties the problem becomes more and more equivalent to solving the pre-image problem of the one way function.
@_date: 2015-04-26 20:22:17


How do you know that in all possible cases there is at least one solution?
@_date: 2015-04-25 15:10:18
Did you assume probabilistic model of hash functions?
@_date: 2015-04-25 14:06:33
Probability of rolling a 1 is 100%. But the event "never rolled a 1" is non empty set.
@_date: 2015-04-25 15:27:20
Not if preimage attack on SHA256 becomes possible.
@_date: 2015-04-25 15:19:04
Yeah, but you probably assumed that hash function is injective, surjective or both (bijective) or some "probabilistic" equivalent. If you assume this, then you can come to graphs like this. I don't know how you can come to these graphs without such assumptions.
@_date: 2015-04-25 14:15:35
How will adding more miners help if such block doesn't (necessarily) exist?
@_date: 2015-04-25 16:17:25
I don't understand your argument.
Pick some x. Calculate y=SHA256(x). Then you know that SHA256(.) can take value y. Does this mean some sort of vulnerability? I don't think so.
@_date: 2015-04-25 14:18:56
But what if nobody wins the lottery?
@_date: 2015-04-25 15:08:36
Why it doesn't make sense?
@_date: 2015-04-25 14:37:25
More hashes can't help if there is no block that can be mined. See MagicalBux's answer, it seems reasonable.
@_date: 2015-04-25 14:46:07
Can you find a block when the difficulty has the largest possible value? You probably won't be able to find such block. That's my understanding.
@_date: 2015-04-25 14:07:33
But can it happen once in the future (even if it is not likely)? What happens then?
@_date: 2015-04-25 16:28:42
Will this happen automatically? Or will someone have to intervene manually? What if the next difficulty is still Y?
@_date: 2015-04-25 16:49:54
Hard forking a protocol is not a big deal? 
@_date: 2015-04-25 18:05:41
This is vulnerability if you can actually find such x. Proof of existence of such x is probably not enough for vulnerability. 
@_date: 2015-04-25 15:36:40
Can you please explain the "same sense" in the first answer?
But what if difficulty is so high that the block doesn't exist for any set of transactions? Then moving to another set of transactions doesn't help.
@_date: 2015-04-25 14:31:28
I remember one such graph but it was calculated using the probabilistic model of one way functions. 
@_date: 2015-04-25 15:07:11
It is not just matter of probabilities if you don't use probabilistic model for one way functions. 
If you have some one way f, can you prove that there exists such x that f(x) is in some predefined set? You can't prove this for SHA256 (and SHA256(SHA256(.))) in general.
@_date: 2015-04-25 14:23:47
Miners are trying to find a block for given set of transactions. "such block" = block which contains these transactions.
@_date: 2015-04-25 16:05:03
I meant this: miners can find block for difficulty X. But then the difficulty changes to Y, Y&gt;X. But for difficulty Y there is no block for any set of transactions.
@_date: 2015-04-25 16:41:37
But the number of possible merkle roots is actually much smaller. Merkle roots are calculated from the set of transactions which is several orders of magnitude smaller than 2^256.
@_date: 2015-04-25 15:54:38
Sorry. I meant "conclusions" instead of "graphs". You can draw pretty graphs (as mentioned by someone else) if you assume some kind of probability distributions.
@_date: 2015-04-25 14:56:19
But why should there be blocks for lower difficulties (not just for "ridiculously high nominal difficulty")?
@_date: 2015-04-25 14:34:40
Ok, thanks. But what happens if blocks cannot be mined? The network freezes permanently?
@_date: 2015-04-25 15:47:04
How are subpoenas relevant?
Subpoenas won't stop the network. But the unability to find the next block probably will. Bitstamp, Coinbase can also receive subpoenas.