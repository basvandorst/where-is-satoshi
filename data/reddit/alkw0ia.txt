@_author: alkw0ia
@_date: 2014-05-30 17:09:41
So they're literally implementing the plot of Cryptonomicon. Nice. 
@_date: 2012-08-30 18:59:56
If his friends (or PR reps; or lobbyists; or politicians) were giving him cash when they approved of an article he wrote for his magazine, yes, it'd be hugely inappropriate and unethical to accept it. 
@_date: 2012-09-07 01:01:14
It can also be hard to find ads to run alongside controversial content. 
@_date: 2012-12-03 02:51:06
I think the review is way too flippant in its minimization of the "[scathing review's]( criticisms. 
The crypto flaws the blogger highlights are major, major flaws that should not have been made by anyone who has even a passing, amateur knowledge of modern (post-2000) crypto (e.g. lack of AE), or even by anyone who's merely read Schneier's *Applied Cryptography*, from *1995* (e.g directly encrypting with RSA – really, what the fuck?). 
While the protocol can be upgraded, what's the evidence that the new product will be any better? Sure, in theory, v2 could be perfect, but if it's by the same guy/group, we're expecting someone who delivered a high-school level demo project to turn out a hardened, release-quality product on his second attempt. 
The first rule of crypto is to not design your own. That rule has been broken. The second rule is to not even *implement* your own crypto. Clearly, that rule has been broken. The criticism so far has been about the design; what's to say the coding is any better? 
Beyond that, there's not just "bad encryption" and "bad implementation" to worry about, this is a proposal for an entire cryptographic protocol, which takes even more expertise. 
Remember, crypto flaws aren't like other bugs, that can be easily tested for in dev, or patched once released. Anyone trusting this product's security could be irrevocably exposed by even subtle flaws in it, much less these glaring errors. 
With the proliferation of vetted high level crypto toolkits out there, none of this was necessary. The project's message encryption goals seemingly could have been achieved by a sigle call to [NaCl]( [`crypto_box` function]( (which would even have used ECC as the Bitcoin Magazine reviewer wanted, though his justifications for wanting it seem somewhat irrelevant for this particular use case). 
tl;dr I love the concept, and the high level goals and architecture sound like exactly what we should shoot for in a next-gen messaging system. However, the crypto flaws mentioned are not in the "needs tightening up" category, they're in the "needs to be done fresh by a different development group" category. 
@_date: 2013-02-12 19:51:06
Then your passphrase is not "a 32 character passphrase", it's an *x* word long passphrase. This can be fine, if you select the words properly. Security is about process, not the actual passphrase. 
Just as with the characters, if you did not pick those words randomly and uniformly from a well defined pool, there's no real way to evaluate their security – and it's probably very, very, very, very, very low. 
It sounds like you're talking about a natural language phrase of some sort, or some bastardization thereof. Natural languages have extremely low entropy – think like one bit per letter. That means that your passphrase is likely only equivalent to a 32 bit key, or, in other words, one out of about four billion. Generically, passwords this strong are generally crackable in significantly less than a second these days. 
The [Diceware]( page I linked before outlines one way to do word (or character) selection securely. Your passphrase will not (and should not) make any sense, but you'll be able to reason about its strength. 
If you care about the security of any password or passhprase, your process will look similar:
1. Pick a character set (e.g. "all lowercase alpha plus numbers") or a word list (e.g. "The Diceware wordlist")
2. Pick how many characters or words you will choose, based on how strong your pass phrase needs to be.
3. Randomly select an element from the set you chose. This is your first element. 
4. Repeat step three until you have the number of characters or words you wanted. You must use each character or word in the order you chose it, and cannot eliminate any that you don't like. 
How long should the passphrase be? The Diceware FAQ has suggestions. If you want to be hyper conservative, target 128 bits – 25 random lower alnums, or 10 diceware words (separated by spaces). 
How should you select characters/words randomly? Well, if you trust your computer, trust your software, and know that your hardware has a decent source of entropy (determining this is beyond the scope of this discussion), you could use a password generator or password manager. 
If you don't know, or don't trust your HW/SW, use dice, preferably casino dice, as the Diceware site suggests. There are lookup tables on the Diceware site to convert dice throws into characters or words. 
*You cannot know how strong an arbitrary phrase is.* You can only evaluate the strength of the *process* by which you chose it. If you chose it "yourself," with no particular methodology, or if it's based in a natural language in *any way* (i.e. it makes sense, even just to you, or it's based on something that makes sense), then it's almost certainly not secure. Period. 
@_date: 2013-07-03 22:59:18
Ah. There better not be, or that's a major iOS or Android and/or Authenticator app security problem. 
Maybe an iTunes backup of the phone might have something if your device doesn't have a passcode on it (and thus the secure areas of the Keychain aren't encrypted against your passcode), but if there is a passcode, I believe the backups themselves must be encrypted or they won't contain the secure data (and I hope and presume the Authenticator app uses the secure storage options). 
Android didn't get similar features until very late (4.0+ I think), and they're not as strong, but I presume they're now similar. Older Android is probably vulnerable to scooping up the data out of the app storage areas directly, i.e. if you store the app on your SD card, just mount the FS. 
I doubt this would be easy or robust, though, so it'd be more of an attack on the Authenticator app than a backup strategy you could rely on. Just back up at time of key creation. 
@_date: 2013-02-12 22:29:30
These heuristic tools can eliminate many bad passwords, but they cannot be used to validate good passwords. 
A good password is entirely about the way it was selected; if you use XKCD's "correct horse battery staple," you've chosen a horrible passphrase, regardless of how many tests it passes – you've picked badly by using a well known phrase. 
As an example of how tools cannot judge password strength, the tool you linked rates "1BiT 2CoI 3N." as sufficient or exceptional (i.e. all green or better) in every category. "1BiT 2CoI 3N." is a horrible wallet password because it has almost no complexity – it just matches every single heuristic that tool is looking for. 
Worse, a tool like this not only doesn't guarantee a strong password, it encourages really hard to remember and hard to type passwords. All those symbols and upper/lower switches are a huge PITA, and are unnecessary if you know the strength of your passphrase. 
I'll grant that if you ignore the categories the tool offers, and just look at the strength indicator, it does at least give significant credit to very long passwords it otherwise doesn't like. Many tools fail to do this. 
However, as a dumb tool, it cannot differentiate between a poorly chosen, weak long password, and a well chosen, extremely strong long password: It rates "the1quick2brown3fox4jumped" as about the same as (actually, better than) "ahch5ejeep3ohzae8aer4iesa." This is obviously not the case; one is trivial, because it was trivially selected from a common phrase, and the other is infeasible to crack using any known or imagined technologies, for billions of years. 
Password strength can only be judged by selection methodology, not by looking at the password itself. Put another way, "password entropy" is a measure of the uncertainty you introduce in picking the passphrase; once you've picked a passphrase, there's no longer any uncertainty and thus no entropy. 
@_date: 2013-02-12 22:29:42
This is the right answer; wallet security is about way more than just passphrase selection. 
@_date: 2013-10-27 05:26:42
"Congressman, can I interview you about the campaign finance scandal?"
"Sure. Before we start, let me 'tip' you $500. Ok, ask your questions."
See the problem now? Not exactly conducive to hard hitting journalism. 
@_date: 2013-02-06 16:45:13
They don't just rely on PayPal, they *own* PayPal. 
@_date: 2013-07-03 20:26:47
This is going to vary by service, since each site codes the setup process itself, but at least for Google, during sign up, you're shown a page with a QR code to scan, with an option to manually enter a key into your phone instead. 
You're supposed to scan the QR code on one phone, and it'll never be shown again. Access to that key or the data in the QR code is the entire basis of the security of the system, so if you lose it, you've lost all 2FA security. 
At this point, you could just scan the QR code using multiple phones. This is explicitly forbidden in the documentation, but it works. 
To truly back the 2FA data up, you can do one of:
- Store a copy of the QR code 
- Store a copy of the manual entry key
- Decode the QR code, which contains a special URL holding that same key, and store the URL
You'll then need to securely encrypt and back up this data, as in a password safe, or a PGP protected file. Consider your recovery plans, so you don't lock your backup with a key contained only in the backup, for instance. Encrypted backups are generally a terrifying thing for this reason. 
Finally, you could just rely on the intended, built in backups – print out and securely store the one time use HOTP backup codes. If you lose your phone, use one of these codes to get in to the account and reset the 2FA secret, authorizing your new phone with the new QR code. 
@_date: 2013-02-12 19:20:29
That question only makes sense given how you chose the password. If you just made it up, or used some mnemonic, or picked a quote, or used English words, it can be very hard to tell. Possibly not strong at all.  
However, if you picked each of those alphanumeric characters totally randomly (selecting from a uniform distribution, of course), and did nothing to pervert the random uniform in-order selection of characters (i.e. you accepted each generated character, in order, rejecting none), then we can calculate:
There are thirty six possible characters, and you're using thirty two character long passwords. This means there are 
36^(32) 
= 2^(32 x lg 36)
≈ 2^(32 x 5.17) 
≈ 2^(165) possible such passwords. 
Assuming you didn't cheat, and your random character generator is good ([think casino dice, not rand()]( that's quite strong – it's a random 165 bit symmetric key. 
@_date: 2013-02-13 07:51:11
I have to disagree on the strength of that password for two reasons: First, it's an extremely simple application of alternating case and numbers to a very obvious brute force word. Whether or not that pattern is in any particular engine at the moment, I don't know, but it's an obvious one to add given that it's built into a password strength meter. This password is, or should be, easily guessable, particularly in the Bitcoin domain. 
More broadly, though, saying that password is strong violates my core point; passwords aren't strong, their selection methods are. This password was chosen by taking the most obvious combination of numbers and the most obvious word and applying exactly the rules enforced by the strength meter. Its process is in no way strong. 
That it matches some arbitrary criteria of apparent strength is totally irrelevant, and is why it's impossible to evaluate the strength of passwords based on looking at passwords. While we have no option but to apply these heuristics when wagging our fingers at our users via "that password is not good enough" meters in our signup dialogs, the entire concept is deeply flawed. 
Abstracting yet another level, I could argue that the password I suggested is a priori weak *simply because I have posted it as an example password in a public forum*. That the evaluation tool continues to say that the password is strong several hours after I have so disclosed it reveals that the tool cannot correctly evaluate whether a password is strong. 
At best, you can flag obviously bad passwords, but you'll never be able to correctly assert that a password is strong with content based rules. It's a blacklist, not a whitelist. 
@_date: 2013-02-06 20:11:44
I think he's referring to the birthday attack on generating keys; it only takes 1.2 * 2^(n/2) work on average to produce two matching n bit public keys with different private keys, while it takes on average 2^(n-1) work to generate a private key that matches an arbitrarily chosen public key (e.g. a target key you're trying to forge). 
For 256 bit keys, that makes the birthday collision about 2^(127) easier than attacking a chosen public key, hence if you're just blindly looking for collisions, you're more likely to see one against one of the private keys you yourself have generated during the attack than to see anyone else's (though it'd be equally infeasible to store all those attempted private keys, but this is all fantasy anyway). 
Of course, with long keys, like bitcoin's, even 2^(n/2) is an infeasible amount of work. 
@_date: 2013-02-13 05:02:05
Green or better in every category:


That's little better than 123bitcoin in my books. 
I do agree that everyone should use a password manager. It's the only way to have strong unique keys for every service you use. But I don't agree about hard to type. 
I agree with the Diceware advice that bits per keystroke is an important metric (and thus uppercase and symbols are bad ideas), because some strong passwords will always be typed (e.g. your master keys to that password manager, e.g. your login passphrase which protects your keychain) and even stored password may occasionally need to be read over the phone or typed into a new device. 
Known strength trumps blind attempts to strengthen with "hard to type" junk; and length is a better strengthener than increased character set size (both because of bits per keystroke and because entropy increases as the log of the charset size, while additional length increases entropy linearly). 