@_author: evrythingisayisright
@_date: 2017-12-08 04:39:49
lol, imagine if he mails it to the wrong address
@_date: 2014-10-08 01:59:27
What happens?
@_date: 2014-02-26 03:38:00
If you can send a plaintext string you can send a hashed string.
Client side salt &amp; hashes it (1)
Sends to server using HTTPS
Server side salt and hashes it (2)
Server compares this double hash to the one in the database.
I mean, theres no reason not to. Hashing is pretty cheap. Besides if someone rooted your phone/browser with a hokey CA certificate then you could be SSL proxied and then someone could see your password. 
@_date: 2014-02-26 04:41:23
The hashing function has to remain constant or else the hashes will never match up. 
HTTPS protects against replay attacks, but if that is compromised then it's possible. At least your original password will be safe (original reason for client side hashing) 
@_date: 2014-02-26 23:28:37
These two parts here are conflicting




If the unique salt is being sent every time then it is vulnerable to MITM. If its generated then it can be reverse engineered. I don't see any benefit from having a unique client side salt hash.
As for this part,


That wouldn't work because once you introduce that randomsalt into the client side hash, the server will have no way of un-salting that. I see what you're saying, where you do:
Original way --
password -&gt; client side hash (password + user specific salt) -&gt; send to server -&gt; server side hash (hash1 + secret salt) -&gt; hash2 (hash2 is stored in DB)
    
Proposed way -- 
password -&gt; client side hash (password + user specific salt + random salt) -&gt; send to server -&gt; server side hash (hash1 + secret salt + same random salt as client) -&gt; hash2 
The only issue here is that the second you insert that random salt, the hash will be completely different. You can't just hash it again on the server and get the original hash back. It wouldn't match the hash2 in the database because both salts were changed.
EDIT: Here, you can try this out yourself  
suppose your password is "password", your user salt is "_salt" a random salt is "_random", and secret salt is "_secret"
Original way
password_salt -&gt; hash -&gt; 48858c776754f108b3dfb896d4204e9f0995613169318c0b6825a6334dbe56ce -&gt; send to server -&gt; 48858c776754f108b3dfb896d4204e9f0995613169318c0b6825a6334dbe56ce_secret (added salt) -&gt; hash -&gt; fd61e462506b77904fed7748e4f10fc40498e89f213a3fa1306427a243926abe
that fd61e462506b77904fed7748e4f10fc40498e89f213a3fa1306427a243926abe gets stored in the DB.
Proposed way
password_salt_random -&gt; hash -&gt; c78b5b8d9cfb395453eb78f8f7ed95eeaa5ad8f2c4f8041a49c8ecb4c25b27ad -&gt; send to server -&gt; c78b5b8d9cfb395453eb78f8f7ed95eeaa5ad8f2c4f8041a49c8ecb4c25b27ad_random_secret (added salt) -&gt; hash -&gt; 49b28cef0639ca4560cbc1febd4b8fc4cac956c53cd8cd427f61dbad26e8ddbc
The bottom line is that the exact same hashing steps must happen to the password on registration and on login. Hashes are always 1 way functions so you cannot undo a hash.
@_date: 2014-02-10 17:37:44
Why is your phone in nihongo?
@_date: 2014-02-26 19:54:55
The salt can never be random or else the hash will completely change. You have to use the same salts or else the hash will be completely different. You can specify specific salts for different users, but the only real thing you get out of it is you make the first hash harder to attack via rainbow tables. It doesn't really add any significant security so I wouldn't bother making unique salts for different users.
Come to think of it, the client side salts could all be intercepted too, so it wouldn't actually add any more protection at all.
The server side salt must be kept secret, though. Thats where the real security is. If someone got your server side salt and dumped your database, they could build a rainbow table to determine your hashed password (hashed once), then rainbow table against that (the first hash) and determine your original password. This will probably never happen though, as that server side salt &amp; double hashed password DB should be guarded like the ring of mordor.
EDIT: If you use a significant cryptographic hashing algorithm, like SHA-512 or something, you won't even have to worry about rainbow tables. Check out how big the rainbow tables are for SHA-256 with limited input length.  (its massive)
@_date: 2014-02-27 17:53:26
Ah ok, I see it now.
     Client -&gt; sends sha512(sha512(password + uniquesalt) + randomsalt)
     Server -&gt; compares to sha512(passwordhash+randomsalt)
That works, but then you're storing a password hash in the database instead of a password double hash with secret salt.  Where are you storing your unique salt per user? If the database was leaked, an attacker would get password hashes. He could then MITM and listen on the random salt and have all he needs to get in without any rainbow tables. He would use the password hash from DB -&gt; apply random salt and log in before user does -&gt; run script to do malicious things (like change password).
Its better to double hash with a secret salt because at that point you're forcing an attacker to do a rainbow table (assuming both the DB was leaked and the secret salt was leaked).
@_date: 2017-05-09 01:33:07
I just sold all my bitcoins, so prices are probably gonna soar to $2-3k each! Don't worry guys, I'm taking one for the team here.
@_date: 2013-04-10 22:08:36
This. I went to their site expecting a quick transfer, but all I got was nothing, not even an email confirmation.
I will not make that mistake again.
@_date: 2013-04-17 22:26:03
I sent them a few hundred a week ago. Its stuck in limbo.
Its a damn shame too, because they could have become a great company if they didn't fuck up.
@_date: 2013-10-13 18:26:07
Found this thread after some googling. I lost $300 today just like you did. I left it sitting on the account because I thought it was secure (having a unique password and all...) but I guess not. Fuck scammers.