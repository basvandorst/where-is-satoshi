@_author: 1nix3y41o
@_date: 2015-05-10 02:54:02
There could be an understanding between the client and the server that no extra information is to be included in the payment transaction. I don't know if this should be formalized.
I like the unique address idea because it's also good for privacy.
I don't care specifically about Ripple either, but I think the way it's designed seems to have appeal. For example, even Ethereum does [accounts rather than UTXOs]( In this architecture you typically won't generate a new address for each request as far as I know.
@_date: 2015-05-09 21:04:59
So I think the introduction is a bit misleading. It's not really "micropayments over HTTP," the payments happen over the normal Bitcoin network. It's the negotiation that happens over HTTP. I don't think it applies to your use case.
But let's say we adapt it to your use case. An upvote is something you have to buy, so the server first returns 402, then the client makes a payment (out of band, i.e. on the Bitcoin network), and then server "publishes" the upvote for the client to "consume." It could be done. You could easily adapt the code for this purpose.
@_date: 2015-05-09 02:11:24
Are you referring to [BIP-70](
@_date: 2015-05-09 23:22:27
Wow, I didn't think of these at all!
I guess all of this does fall under "micropayments," though not necessarily under "Simple Web Micropayments." My goal, at least when I started, was to address the most common case. This is all definitely very interesting and I'm going to spend some time thinking about it. The P2P file sharing case in particular is definitely one that could use a Bitcoin-based micropayments solution.
While we're on the subject: Micropayments for Tor.
Believe it or not, this last one had come up even before Bitcoin was a thing:
There's so much work to do!
@_date: 2015-05-09 22:26:19
There's no reason why the payments *must* be made in the browser. If you saw the demo video, you might remember the point where it asks the user if they want to pay 0.0001 BTC to the page. If you click Yes, it makes a payment out of its built-in wallet. Well, it could just be a BIP-21 link. You click on it, make a payment with your desktop client, and the rest of it is as usual. This scheme is agnostic to how the payment is actually made.
@_date: 2015-05-08 11:34:40
Yes, the problem is usability. I don't want people to have to enter a password every time they start up Google Chrome. Everyone does that, I want to come up with a better solution (I don't have one right now).
Let me explain the rationale for keeping the key in the clear:
 1.  No password required
 2.  Forces the user to allocate a small amount for donations
 3.  The donation address serves as a canary; if the money is stolen, you know you have malware (and therefore bigger problems!)
I would create a new address and allocate something like 0.01 BTC for donations to start with.
The important thing is not how the Chrome extension works, the important thing is if this is a good model for rewarding publishers. We'll know it only if we try it out as a community.
I'm not going to make it password-protected, because I think the user's time is worth more than the $10 in the wallet. You have far more valuable information on your computer, when you come to think of it. If you still want a password-protected version, the code is on GitHub.
@_date: 2015-05-09 20:46:49


There is already an Express plug-in:
Basically you have your normal Express app that serves both static and dynamic content. You plug in this module, point it to a directory containing "premium" content (e.g. high-quality video), specify your Bitcoin address, and let it start charging for the content. I've tried to make it as easy to set up as I could. I'm sure it could be improved a lot more. If you're into Node.js, please try it out.
I think it would be interesting to do an nginx plug-in at some point.


There is a sample client in the extras folder, but it does only Ripple (Bitcoin can be added easily!). It's all JavaScript of course. I think with a few extra lines of code it could be made into a client-side module.
This is the one:
I'll try to add Bitcoin support when I have time.
Note that there *is* already a Bitcoin payment script:
It's just a matter of combining the two.


I haven't thought about it, but it would help if you could point me to any use cases.
@_date: 2015-05-10 03:13:13
You could use the hash to look up meta information about the content in a public directory. If the content is popular, it might even be available on a P2P file sharing network for free, where again you can look it up using the hash. Even if it's not available entirely for free, you might be able to get a better deal on the network. All of this could happen in a matter of seconds.
If the server is trying to cheat you by giving you a random hash (which later it can't provide the content for), you still have proof that the server did this. If the server's Bitcoin address is linked with its identity as established by its SSL certificate, then you have proof that this host is a fraud. You can publish it. No one will do business with it.
And hopefully this is all automated.
@_date: 2015-05-10 03:45:02
Frankly I wasn't aware of BIP-70 until you brought it up. I see that it's very similar to what I've come up with here.
Here's how Simple Web Micropayments (SWM) differs from BIP-70:
 *  It's more lightweight
 *  It does not establish the server's identity using PKI, and has no alternative either (this is a big hole in the design right now)
 *  The payment is made entirely out of band
 *  No refunds
 *  Only one SWM message is exchanged between the client and the server, which is the 402 response
 *  Designed for micropayments
 *  Payment network agnostic (i.e. can work with Ripple, Ethereum, etc.)
Even if we use BIP-70 for web micropayments, it would have to be a stripped down version. It's too big. I'll see if I can make a working example that uses BIP-70 only.
On the other hand, SWM could learn a few things from BIP-70. I don't think there's any harm if the client simply delivered the transaction to the server. I don't know why it didn't occur to me. I've definitely got to play with this.
@_date: 2015-05-09 22:21:54
I just picked MD5 because it's used in most ETag implementations.
An implementation could choose to use a different algorithm like SHA-256. It would have to set the `digestAlgorithm` field to let the client know. Indeed, this is why I included it in the original design.
@_date: 2015-05-09 22:05:56
Great questions!


The ticket ID is two things:
 1.  Proof that the server made an offer
 2.  Once it's in the blockchain, proof that the client has made a payment against the offer
It's `sha256(object + signature)`.
You could *still* have a unique Bitcoin address per client. You could also skip the signature, in which case it's just `sha256(object)`. It's just that having an object gives us so much more flexibility, it lets us add things in the future.




The above two points are for a different use case I had in mind: blockchain-based login.
Here's how it works:
 1.  Client makes an HTTP request for /resource
 2.  Server responds with 402 and the usual X-SWM-* headers, plus a domain name and a login token
 3.  Client makes a payment
 4.  Server receives the payment and "activates" the login token
 5.  Client includes the login token in a cookie for its next and subsequent requests
This is a variation of the original scheme, but it's more suitable for accessing unlimited amounts of paid content on a given domain for a given period of time (i.e. the `validity` field in the ticket object). In other words, it's just a way to log users in using the blockchain. It's not really "paid content," because the payments are really tiny. It's more of a spam/DoS-prevention thing. You don't have to create an account on a website anymore; you're identified by your Bitcoin address, and your login token is something you actually bought (which means no need for CAPTCHAs!). This is overall a *much* better user experience.
What do you think?
@_date: 2015-05-08 14:52:41
A donation is made **only if you spend a minute or more** on the page. If you don't like the content, you're probably going to move on in less than a minute.
@_date: 2015-05-09 23:04:39


If the server's Bitcoin address is "well known," and the ticket object is indeed signed with the key, then you couldn't MitM it.
How would the server's Bitcoin address be well known? Well, I don't know. I suppose that's a different protocol. You're right, it must be HTTPS.


Can you give an example of how this could be abused, and how something like CORS would help?
Assuming HTTPS of course.


In my initial design the entire thing was in a JSON object in the HTTP response body, but then I moved all of it into the headers, and I'll explain why below.


What about clients that don't have the plug-in? And what about websites that want to have a custom experience? I modeled this on 404. The website can serve its own HTML page for 402 (a cat photo if you like!), even including an HTML form for making a payment. If the user has the plug-in, the plug-in can intercept the 402 page and replace it with its own UI for making a payment out of its own built-in wallet. If not, the user still gets to see *something* that's friendly. This is very important for initial adoption as well as for long-term flexibility.


Hmm ... this is a good point.


Yes, and this is kind of a tradeoff with the above.


Thanks, this is a very good point.




There's a "TTL" included in the 402 response. The client is supposed to wait *at least* as long as TTL before hitting the server again, and ideally try again in intervals of TTL. If the server hasn't seen the payment, the content won't be available, and this is going to be a 404.
I thought 10 seconds was an ideal TTL for my server, because I'm not running my own node (I'm using the helloblock.io API). If you're running your own node, you could reduce it to 5 seconds or less.
Thanks for the other links.
@_date: 2015-05-08 14:51:09
You're right, and I have to admit that leaving the key in the clear is not a complete solution.
Passwords are evil though. Most people will choose a very simple password, which gives a false sense of security. Worse, they'll choose the same password as the one they use for their Gmail account. You brute-force the encrypted key, as a bonus you also have access to their email account! Passwords are bad for security.
@_date: 2015-05-09 23:55:48
You're right, I can't think of a reason why the ticket ID *must* be included in the transaction if the server is indeed tracking it with a unique address.
But this may not be compatible with other payment networks, e.g. Ripple.


If you're comfortable paying for access to individual pages, surely you can't be uncomfortable paying for access to an entire site. Essentially that's what login is.