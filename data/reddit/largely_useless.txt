@_author: largely_useless
@_date: 2018-01-08 12:33:45
If Tommy's coins are all in channels that doesn't give him enough useful routes to where he wants to send his money, it makes total sense to close some of the less useful channels so he can open new channels that are more useful to him. This is the very mechanism that will balance out the network and ensure that most transactions will be routable without opening new channels.
The fees spent on closing and opening channels to create more useful routes will be offset by the transaction fees you collect from the transactions you'll then be able to route.
@_date: 2018-01-09 08:32:22


It's a free market, you can demand whatever fees you want, but you're competing with everybody else. If routing through you is too expensive, the network will just route around you.
Also, keep in mind that even if the fees on a single transaction is cheap, it adds up quickly when you're routing a lot of transactions. Since channels are bidirectional, if you route a hundred transactions, the funds on a channel can change sides a hundred times. If you collect 0.05% on each transaction, you've now earned 5%.
@_date: 2018-01-03 12:59:45
Bitflyer is using native segwit internally for their hot wallets. Last time I made a withdrawal from them, it came from bc1qwqdg6squsna38e46795at95yu9atm8azzmyvckulcc7kytlcckxswvvzej.
@_date: 2018-01-12 14:33:46
All funds on LN is held in open channels, all channels are backed by onchain UTXOs. If you buy BTC on an exchange and withdraw it over LN, the exchange will make an onchain transaction to open a channel to you if no other route already exists.
If you are talking about funds that just sits on an exchange, it doesn't make sense to distinguish between onchain/LN, they are neither. Funds sitting on an exchange are simply IOUs.
@_date: 2018-01-28 14:37:23


The key generation includes externally fed entropy. Once unsealed, you can verify that the private key incorporates the entropy you fed it, and thus that it can't be known by anybody else. Refer to their FAQ for details.


The simple reason is that nobody would be willing to pay you $10k for a broken piece of electronics, even though it held that value before it broke.
When you have a working USB stick containing a private key that can spend 1 BTC, it doesn't matter what anybody would pay you for the USB stick, you can pull out the BTC and sell it at market rate.
The value of something is connected to the ability to turn it into a different form of value. When you have something nobody else wants, it doesn't have any other value than what keeping it is worth to you.
@_date: 2018-01-27 14:26:38
If we define a “physical bitcoin” as a physical item containing a bitcoin key, then the value of that item is backed by the fact that you can redeem the value by using the key to send the associated bitcoin elsewhere. If the key is lost or the funds already spent, then the value is gone.
You might be interested in looking at Opendime, they are designed to be used for physical transactions. They generate the private key internally and doesn't allow anybody to copy it before they are unsealed. When you receive an Opendime, you can look up the associated balance and verify that it is still sealed, and thus that the value will still be redeemable if/when you choose to do so.
@_date: 2018-01-25 16:58:06
Because schnorr aggregates keys signing the same message. It can't aggregate unrelated signatures.
@_date: 2018-01-09 08:53:58


Due to the difficulty adjustment mechanism, mining costs will always adjust towards a break-even equilibrium.
If it's too profitable to mine, more miners will get on, raising the hashrate. When the hashrate rises, difficulty adjusts up, reducing the profits.
When profitability goes down, the least profitable miners will stop mining rather than mining at a loss, lowering the hashrate. When hashrate goes down, difficulty adjusts down, increasing the profits.
@_date: 2018-01-09 11:58:30
It's just probability. With the probabilities involved, the chance of a duplicate is not just microscopical, it's practically impossible.
A private key is a 256-bit number, which means that there's 2^256 different keys. Birthday problem theory states that you'll have to have generated 2^128 keys before you're likely to find a duplicate.
Imagine that you generate a billion keys per second. If you keep doing that for a billion years, you will have generated a bit shy of 2^85 keys. To get to 2^128 you'll have to repeat the effort you put in another nine trillion times.
@_date: 2018-01-31 22:51:47
In your scenario, it would make sense for the ATM to fund the channel with exactly the deposited amount, pushing everything to your end, leaving nothing on the ATM's end.
@_date: 2018-01-22 08:47:50
Going by the RFC, I believe each party proposes a value for the other side to use, which implies that proposing a low value just gives your side less time to recover your funds.
Either way, it's a negotiation, so either party is free to reject forming a channel with parameters they are not comfortable with.








@_date: 2018-01-03 16:55:36
It's not really news though. If you check the history for that address, it's had activity since September, so they've been using segwit for over three months now.
@_date: 2018-01-03 14:12:46


Segwit moves the input signatures from the scriptsig field to a new witness field in each transaction. The new witness field is counted as 1 WU per byte, while the rest of the transaction is counted as 4 WU per byte.
Non-segwit nodes does not know about the witness field, and as such does not count it when calculating blocksize, and since the maximum weight is 4000000 WU, blocks still can't contain more than 1 MB of non-witness data.
A block containing 400kB of witness data and 900kB of other transaction data would also have a weight of 4 MWU. Segwit nodes would see this as a 1.3 MB block, while non-segwit nodes would see this as a 0.9 MB block.
@_date: 2018-01-22 08:34:50
It's set by the `to_self_delay` parameter that's negotiated when opening a channel.
@_date: 2018-01-09 09:50:58
When mining is unprofitable, but you still want bitcoin, it's more cost effective to buy bitcoin than to mine at a loss.


Bitcoin difficulty adjusts every 2016 blocks towards a target of 10 minutes per block on average. 2016 blocks times 10 minutes each is two weeks, which means that if 2016 blocks takes less than two weeks, difficulty goes up, if it takes more than two weeks, difficulty goes down.
The problem with a sudden massive loss of hashrate is that mining 2016 blocks takes longer, so it takes longer to adjust. With the low initial hashrate BCH got, it would have taken them months to get to the next difficulty adjustment if it haven't been for the EDA mechanism, and it would probably have died off before then.
@_date: 2018-01-26 17:41:57
When they are signing the same set of concatenated messages, they aren't unrelated signatures anymore, they are now signing the same message.
OP has edited their post since I replied. The original proposal suggested sending signed transactions to a batching node, not signing after batching as it does now.
@_date: 2018-01-08 09:03:57
I think you're illustrating why the premise of hubs that doesn't do anything except route other people's transactions doesn't really make sense.
How it's actually designed to work is that when you're getting paid 0.1 BTC, the sender will see if they already can find a route to you, and if they can't find it, they will open a new channel to you, funding it with 0.1 BTC, with an initial state allocating all of it to your side of the channel.
@_date: 2018-01-07 19:02:31
If your xpub is coming from a hardware wallet, there's no risk of lost funds due to a xpub+privkey leak, and possession of the xpub alone is just a privacy problem in that you can see the entire account history.
If you also want to mitigate the privacy risk, you can change xpub regularly, e.g. monthly. That way, a leaked xpub will only give away information on a month's worth of transactions at most.
@_date: 2018-01-11 11:55:02
The current LN protocol spec limits channel capacity to 2^24 satoshis, which is around 0.167 BTC, so you can expect to still do onchain transactions for larger payments.
Note: This limit is designed to be removable if/when larger capacity channels becomes necessary.
@_date: 2018-01-12 09:53:42
You can't technically use LN without involving the blockchain, LN's security is still rooted in the blockchain. Every channel is funded by an onchain multisig UTXO, committing an amount of bitcoin to the channel, and any disputes will also be resolved by onchain enforcement of the contract rules. Closing a channel releases the committed bitcoin.
In other words, you put bitcoin in, you get bitcoin out, there's no alternative tokens involved.
@_date: 2018-01-15 08:46:00
Took me around 5.5 hours on my home server a few months ago (when 0.15 were still RC).
Server has a i5-4670 and 32GB RAM. Data is stored on a zfs array across 16 HDDs. Internet connection is 160 Mb/s.
@_date: 2018-01-22 08:16:55
Your point 4 doesn't make sense, a channel in itself doesn't have a timelock.
The timelock involved in LN is a relative timelock (CSV) on the local output of each channel state transaction. It only starts ticking once it's broadcast and mined.
In your scenario, once Bob broadcasts the transaction, the timelock starts counting. Bob will not be able to spend his output from this transaction until the timelock expires, but since the transaction reflects an old invalidated state, Alice has the key to spend it immediately with a punishment transaction. Bob would then not only lose the amount he tried to steal from Alice, but also the amount in the channel that he has a rightful claim to.
To prevent Alice from stopping him, Bob would have to deny Alice internet access for the full timelock period, no matter when he initiates his attack. While a DDOS might be effective against one connection, it doesn't stop Alice from using a backup connection (e.g. a tethered phone) to detect the fraud attempt and send the punishment transaction.
@_date: 2018-01-18 21:44:28
Indirectly, yes. Lightning gets its security properties by being backed by the bitcoin blockchain, so that's not going away.
@_date: 2017-12-23 20:05:44


Because that was the main purpose of segwit, it's a transaction malleability fix. The additional block capacity is a side benefit.
Quick explanation: The ID of a transaction is a hash of the contents. For legacy transactions, the input to this hash includes the signature.
The problem with hashing the signature is that a signature has multiple valid representations. Imagine that you were validating x^2 = 4. Now both 2 and -2 would be valid values for x.
When your transaction is malleable, it means that a third party could take a valid signed transaction, and replace one of the signatures with a different but equally valid representation, producing an equally valid transaction but with a different ID.
The new witness field added by segwit is not hashed as part of the transaction ID, so moving the signature there means that segwit transactions can't be malleated anymore, ensuring that they can only confirm with the same ID you expect.
@_date: 2017-12-06 21:01:43
To put it in perspective, it's $0.07 in fees on a $0.25 transaction.
Also keep in mind that the fee rates are negotiated between the participants in the network. I think it's too early to say where they'll end up in practice before they have been subject to market forces.
@_date: 2017-12-18 15:01:35
It's safe as long as it's stored, but when you enter the private key into another device for signing, it's only as safe as that device.
A hardware wallet is arguably safer. When it's disconnected, it's at least as impenetrable as a paper wallet. When it's connected, it's designed to be able to sign transactions without leaking your private key.
@_date: 2017-12-08 15:08:15
The trezor vulnerability was patched and doesn't exist in current firmware.
Both are good choices and in the end it comes down to subjective preference.
@_date: 2017-12-03 21:38:56
My siblings are getting an Opendime each this year. It's a bit more costly than a paper wallet, but I want to give them something more fancy than the printed giftcards I gave them last year.
@_date: 2017-12-26 10:36:03
Even if you formally count it as the coins being in your possession for the duration, you bought them (from coinbase) and sold them (to your friend) for the same price and therefore had no gain or loss on them.
@_date: 2017-12-23 19:39:38
I don't dispute that. I agree that going from a given set of inputs to a given set of outputs is always smallest as a single transaction. Adding any intermediate steps naturally can't do anything but adding size to the total, since it involves creation and spending of more outputs.
What I don't understand is what you mean by “reusing addresses”.
@_date: 2017-12-05 23:44:40
I think it's a fair point. If you run the numbers, I believe you'll find that the amount of power currently spent per transaction processed on average is many orders of magnitude higher than for traditional banking no matter how you count.
@_date: 2017-12-19 10:44:39
I'm not super impressed by the efficiency of the compiler. The LockWithMultisig example generates the following script:
    PUSH(pubKey3) PUSH(pubKey2) PUSH(pubKey1) 0 2ROT 2 6 ROLL 6 ROLL 6 ROLL 3 CHECKMULTISIG
This is how the script for a two out of three multisig transaction usually looks:
    2 PUSH(pubKey3) PUSH(pubKey2) PUSH(pubKey1) 3 CHECKMULTISIG
These are equivalent except the latter needs to be executed with a dummy element on the stack before the two signatures. The generated script adds the dummy element itself and spends extra operations reorganizing the stack to put it below the signatures, resulting in a larger and thus more expensive transaction.
@_date: 2017-12-06 22:53:48
I'm sorry for nitpicking, but you make it sound like you're including the private key in the message. I would like to clarify that the private key remains secret, but it's what allows you to generate the signature. The signature proves to the network that you possess the private key matching the public key.
@_date: 2017-12-18 15:31:10
Depending on who you ask, they'll probably say either Trezor or Ledger Nano S. My impression is that they are fairly comparable and the difference comes down to subjective taste.
They both support some altcoins. You'll have to look up the specifications for either to see if they support the particular altcoins you care about.
@_date: 2017-12-26 10:13:22
The bech32 encoding itself can encode any data you put into it, just like the base58 encoding. As an example, LN's BOLT 11 defines bech32-encoded invoices.
The addresses using bech32 as defined by BIP 173 however are specified to start with a witness version followed by a witness program. Currently the only defined witness programs are v0 P2WPKH and P2WSH.
There are no defined mapping between a bech32 address and P2PKH or P2SH scriptpubkeys, and if you believe BIP 173 addresses are a 1:1 mapping to a scriptpubkey, you're mistaken. A v1 witness program would start with the byte 0x01 in the address, but OP_1 (0x51) in the scriptpubkey. It's only coincidence that v0 witness programs happens to be the same, because OP_0 is encoded as 0x00.
@_date: 2017-12-09 14:36:00
Keep in mind that this only goes for unhardened derivation. BIP44/49 uses hardened derivation on the account level, so the risk is limited to only the funds in the compromised account.
@_date: 2017-12-23 19:08:31
You either misremember or misunderstood.
The currently used segwit addresses (3-addresses) are P2SH addresses wrapping a P2WPKH witness program. This means that the scriptpubkey of an output will contain the P2SH hash of the witness program, while witness program itself goes in the scriptsig of the spending input.
With bech32, we'll get native P2WPKH addresses, which puts the witness program directly in the scriptpubkey of the output. These are spent with an empty scriptsig field, the signature goes in the witness.
The whole reason we need a new address format is because native P2WPKH change the way outputs are created, and the sender needs to know what sort of outputs to create. With P2SH-P2WPKH, the output is indistinguishable from other P2SH addresses (e.g. multisig).
For a more detailed description you can look at the examples in BIP 141:
@_date: 2017-12-30 17:33:39


So if I get my friend to buy something for me, promising I'll pay him back later, I haven't borrowed from him because I haven't paid him back yet? Is that your logic? A loan is not a loan until it's paid back?
@_date: 2017-12-07 08:41:32
A bitcoin 1-address is the base58-representation of the hash of a public key. The public key is the result of EC point multiplication of the private key. This means that you have a chain of operations where you put in a private key in one end and get an address in the other end. The private key is just a 256-bit random value.
To make a vanity address like that, you brute force it. You pick a random value as a private key, puts it through the chain of operations, check if the resulting address matches the pattern you're looking for, then repeat until you've got a match.
Each letter in a base58 representation is one possibility out of 58, and that address has seven letters in the pattern. This means that on average one out of 58^7 addresses, i.e. one out of about 2.2 trillion, will start with that pattern.
As for your second question, blockchain.info maintains a list of well known addresses, substituting a name for each address on the list.
@_date: 2017-12-10 12:16:58
To put it simply, unhardened derivation does privkey(n) = k + h(xpub, n), while hardened derivation does privkey(n) = k + h(xpriv, n). h() is a hash function.
The thing here is that when you know xpub, you can calculate h(xpub, n) for any n. If you additionally know e.g. privkey(2), you can calculate k = privkey(2) - h(xpub, 2), and knowing k you can calculate privkey for any other n.
To do the same calculation for hardened derivation, you would need to know xpriv instead (and knowing xpriv you could just derive any child key directly anyway).
@_date: 2017-12-30 16:39:33
The situation for modern (HD) wallets is simple: Keep a backup of the seed words for all wallets you have that contains funds. As long as you have the seed words, you can recreate it perfectly and thus risk no loss of funds due to lost keys from it.
If you mess around with keys that didn't come from a seed, you've created a weird situation for yourself. Just don't do it unless you know what you're doing and has a good reason to.
@_date: 2017-12-07 14:10:09
The cost of mining will always rise towards an equilibrium with the mining reward, and since the majority of mining cost is electricity, this means that the total electricity demand will rise towards the amount of power you can buy for the total mining reward. This happens regardless of which PoW function is used.
Short of replacing PoW with PoS or other alternatives, the only way to reduce electricity consumption is to reduce mining rewards.
@_date: 2017-12-07 14:18:30
The only thing you need to look out for is malware that hijacks your clipboard or similar, replacing the intended address with a different but valid address that sends the funds to an attacker instead.
To eliminate this risk, you can get a hardware wallet. They have their own little screen that shows the address you are signing for, so you can confirm that it is still the same you meant to send to.
@_date: 2017-12-25 18:39:43
If you'd like to have a go at it, here's a little bit easier challenge with a 1 BTC bounty:
Check my comment on that post for an estimate of the complexity of bruteforcing it.
@_date: 2017-12-07 21:01:09


Segwit is primarily a fix that removes the possibility for malicious actors changing the IDs on transactions before they confirm. Read up on transaction malleability for details. Amending specifications to fix bugs is reasonable.
LN is not part of Bitcoin itself, but built on top of Bitcoin, and as such is out of scope of the original whitepaper. The whitepaper just defines the building blocks that LN is built on top of.


LN will be a decentralized mesh. Any two nodes can negotiate a channel between them, so there should be plenty of alternate paths if one node misbehaves or is shut down. If there are no good paths towards the node you want to pay, you set up a channel directly to them. That channel can later be used to route payments elsewhere through them.


It has a different difficulty adjustment algorithm to allow it to survive as a minority chain. This makes it much less secure against chain rewrite/51% attacks.
The way the former EDA could be exploited to mine blocks faster than schedule on average was arguably also bad, but it's removed now and the resulting inflation is fairly negligible.
@_date: 2017-12-30 16:21:42
Safe is not a binary property, there's degrees of safety. I'm willing to put some funds into my LN node, enough to transact and route transactions with, but not my entire savings.
In the future we might see hardware LN wallets. I.e. a separate secure device that interfaces with the LN node software and holds the keys. Having to push a button to confirm that a transaction is legit like on the current hardware wallets is not going to work for routed transactions since they will be processed autonomously, so the hardware wallet would probably instead need to perform some sort of verification between the incoming and outgoing transactions to check that they match.
@_date: 2017-12-08 15:12:42
Arbitrage can be profitable, but if you have to ask rather than run the numbers yourself and figure out whether it'll work in a given situation, it's probably not for you.
@_date: 2017-12-05 09:06:53
If you sent it to a deposit address at Bittrex you'd have to contact them and see if they are willing to help you.
@_date: 2017-12-18 22:57:37


You can collect fees on transactions routed through your node, which will offset the fees you pay for opening/closing channels.


Channels are bidirectional. The funds locked on a channel will move back and forth between you and the counterparty as transactions are routed over the channel.


Neither. You're missing the point that the network will have a mesh topology. There is no need for dedicated hubs or dedicated channels for particular transactions. The mesh is also self healing in that when you can't find a viable route for a transaction, you'll open a new channel creating that route, and other people's transactions will now also be able to take that route.


Indefinitely. There's no need to close a channel unless you need the funds for something else, e.g. a channel with more viable routes. If your paycheck also arrives over LN, it'll already be locked into a channel.


If there's no viable routes from the payer to you, which will be the case if you don't have any open channels with enough capacity to send you the transaction, the payer will as mentioned before create a route by opening a new channel to you with enough capacity.
@_date: 2017-12-07 13:55:35
You're wrong. Addresses contains a 32-bit checksum, which means that the chance of randomly typing in or modifying an address and coming up with different but valid one is a little bit less than one in four billion. Addresses without a valid checksum will be rejected by the sending wallet.
@_date: 2017-12-25 14:58:41
There's no info to go on here. You don't even have the public address to search for the private key for, so you'll have to check against the whole UTXO instead. Given how few bits are visible, the search space is not considerably narrowed and probably still contains many private keys with spendable balances, which means that you're no better off than just trying to brute force any private key with a spendable balance.
@_date: 2017-12-25 20:02:52
By supported, I mean by the sending wallet software. If it doesn't have bech32 support, it won't recognize the address format and doesn't know how to create a transaction to it.
As a receiver, you could publish both old style and bech32 addresses and let the sender choose depending on what they support.
As a sender, given both options, you would want to use the bech32 option if your wallet software supports it. It'll save both you and the receiver some fees by making the transactions smaller.
@_date: 2017-12-26 09:53:43
I think you missed my point. If you knew the private key, you could of course derive the public key. The thing here is that you don't know the private key.
To brute force a key, you come up with a potential private key within the defined search space, derive the public key for it, and check whether it matches. Repeat until you've found the private key that gives you the result you're looking for.
If you know the address (which is a hash of the public key) you're looking for a private key for, all you have to do is derive the same address and check that it matches.
My point is that since the address is also censored, we don't even have anything to check for a match against, and if all you're looking for is a private key with a spendable balance (i.e. that exists in the UTXO set) then you've not narrowed the search space enough that it'd be faster than just looking for any private key with a spendable balance.
@_date: 2017-12-05 23:27:51
Creating Bitcoin could be summarized as “writing software to maintain a ledger for a virtual currency”. I can't think of any laws this breaks. The closest I can think of are potential export restrictions on cryptographic algorithms that might be violated, but those were a larger concern 20 years ago.
What could be illegal (and is, in certain jurisdictions) is trading virtual currencies, assigning real value. In other words, while creation of software might be legal, usage of it might not.
As for bitcoin.org, it was registered by WhoisGuard, Inc out of Panama. To find out who they registered it on behalf of, somebody with authority to would have to get that information from them.
@_date: 2017-12-14 08:10:59
The idea is not to have dedicated channels for dedicated purposes.
As you say, you can send outgoing payments through the same channel as well, but keep in mind that you don't necessarily have to make payments yourself for that to happen. If you have other channels as well, you'll be acting as a routing node for other people's transactions too. Transactions coming in through one of your other channels and going out through your employer channel will also move funds from your employer channel over to your other channels without you having to do anything.
@_date: 2017-12-30 06:43:43


I don't see how that can be the case. A lightning node needs to be able to sign transactions autonomously, for which it needs the keys, which means those can be stolen from a compromised node. The whole point of cold storage is that there's no running code to compromise.
I'm a LN proponent, but I think the security aspect might be one of the largest practical challenges. If you look at it from a risk/reward perspective, the reward of participating in the LN and earning fees needs to be valued higher than the risk of having funds in a hot wallet.
On the other hand, I don't think 0.001% is necessarily low, considering it's per transaction. Since routes with lower total fees will be preferred, channels with lower fees should see a higher number of transactions. This is a classic profit maximisation problem. Too cheap and you're throwing away potential profits, too expensive and you're throwing away customers. The equilibrium should end up around what the average user would pay for a transaction divided by the average number of hops.
@_date: 2017-12-04 08:32:08
Valid. That's why it's a soft fork.
If an older node considered a newer transaction invalid, then the block containing such a transaction would also be considered invalid, and the older node would stop following the chain, causing a hard fork.
@_date: 2017-12-23 19:21:08


Less than what? Address reuse doesn't affect transaction size and hence never costs more or less than not doing it, neither on BTC nor BCH.
Spending a number of UTXOs in one transaction takes the same amount of bytes regardless of whether they are associated with different keys or all use the same key.
@_date: 2017-12-06 20:46:42
Both you and the receiver will have to use a LN compatible wallet to make LN transactions. At the moment three independent implementations exists so you're not locked to a specific piece of software.
@_date: 2017-12-04 11:43:53
If you have bitcoin on address A, i.e. on a given UTXO, you could create and sign (but not publish) a set of transactions that spends this UTXO and each sends it to an address of your choosing. After you have done this, you destroy the private key for A, which means no transactions sending it anywhere else can be signed. You can then later choose where to send it by publishing one of the transactions you previously created.
@_date: 2017-12-29 18:56:05
The solution is simple. If there's no viable route between Dave and Amy, Dave will open a new channel directly to Amy with the required capacity for the transaction he wants to send.
Remember that LN is designed as a mesh topology, not hub and spoke. Each node is expected to have multiple channels open, which means there will be multiple routes between two nodes that wants to transact. Of these routes, only some will have capacity available in the right direction and thus be viable for the given transaction. If no routes are viable, a new channel will be opened to create one, which gives even more potential routes for future transactions.
You as a node does not need to have more funds locked up into your channels than what you need to transact with yourself. Transactions that are too big to route through you will simply find/form a different route around you.
@_date: 2017-12-03 11:13:32
Transactions can be broadcasted at any time, but they won't be confirmed until they are included in a mined block.
@_date: 2017-12-04 08:37:03
Even if you hire nine women, they can't bear you a child in one month.
@_date: 2017-12-18 15:27:56
Only if you by "segwit address" mean P2SH-P2WPKH address. The redeem script in this case is a P2WPKH witness program.
The witness program could also be put directly in the scriptpubkey rather than the redeemscript. This would create native segwit outputs which will be encoded as bech32 addresses.
There's also a P2WSH witness program, and the spec includes possibilities for adding more in the future too.
Refer to BIP 141 for more details: 
@_date: 2017-12-05 23:51:53
Then I'm not sure what you're arguing. I figure the USD/USDT trading pair at Kraken works like any other trading pair. The fact that it trades around 1:1 is due to arbitrage.
@_date: 2017-12-05 23:08:24
Regarding point 3, Kraken does as far as I understand just treat USDT like any other cryptocurrency with its USD/USDT market. In the event of an USDT collapse, if you have USDT tokens on Kraken, you'll just find that nobody wants to pay you much for them. USD liquidity will be entirely unaffected. Technically, USDT liquidity should also remain unaffected, in that you would probably still be able to withdraw USDT tokens, even though they are worthless.
@_date: 2017-12-01 09:57:04
Yes, the block limit is now 4 MWU (weight units). For old-style transactions, each byte is counted as four weight units, so the effective limit for those remains unchanged at 1MB.
Segwit transactions adds a new witness field to each transaction, and each byte of this field is only counted as one weight unit. This gives a new upper bound of 4MB assuming transactions only contained the witness field.
Of course, a transaction can't be witness only. The witness field just contains the input signature/script, i.e. what authorizes the spend. You still need the input information (what coins you are spending) and output information (where you are spending them), so a segwit transaction contains a mix of bytes that are counted as 1 WU and bytes that are counted as 4 WU. People are estimating that for typical transactions, the max block size would be around 1.7 MB if all transactions used segwit.
@_date: 2017-12-05 23:29:30
Are you sure you're talking about Kraken now? It sounds to me like you're talking about Bitfinex.
@_date: 2017-12-08 18:33:09


I call bullshit.
22 confirmations means that your transaction has been included in a block, and then 21 more blocks have been mined after that.
Bitcoin on average mines a bit over six blocks per hour. 22 blocks in 45 minutes would be almost five times normal speed. This is really unlikely and I can't see any evidence that that happened yesterday.
Feel free to prove me wrong. Anybody can verify your claim if you just provide the number of the block your transaction were included in.
@_date: 2017-12-25 22:53:09
Any wallet *can* be able to send to bech32 addresses, but they need to implement support for it.
The thing is that addresses doesn't exist as far as the bitcoin network itself is concerned. Addresses are just representations for the scriptpubkey field in each transaction output. Wallets translate addresses into a scriptpubkey script when creating a transaction, so the bitcoin network itself only cares about the script.
Different address types translate into different script templates. A 1-address contains a pubkey-hash and translates into what's called a P2PKH script:
    OP_DUP OP_HASH160 &lt;PubkeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG
Segwit defines new script templates called witness programs. A P2WPKH witness program looks like this:
    OP_0 &lt;PubkeyHash&gt;
Since the wallet chooses template by address type, new types are required for new templates and wallets then needs to be updated to recognize the new types and use the new templates for them.
Originally, there were a proposal to just use a new type of base58-addresses (like the 1-addresses for P2PKH and 3-addresses for P2SH), but since new support has to be added either way, it was concluded that it was a good opportunity to also replace base58 with a better encoding.
@_date: 2017-12-20 23:41:23
Go try Eclair Wallet on testnet if you want to get a feel for how it'll work.
See 
Both the user and the merchant needs to have open channels to the network. There doesn't need to be a channel directly between the user and the merchant as long as a route through the network exists.
There will also certainly be providers of both custodial wallets and payment gateways for LN, just like coinbase and bitpay today.
@_date: 2017-12-13 20:04:36
In theory, you could rebalance yourself by sending a payment from one of your channels, through the network, to another of your channels. Realistically I don't think it will be necessary.
Remember that the total balance of your channels remains the same (plus collected fees) when you're routing transactions. When you want to send a payment yourself, it doesn't matter to you which channel your funds are in, as long as it has a viable route to the recipient.
@_date: 2017-12-29 19:43:47
The reason is simple, they don't send each withdrawal as a separate transaction, they bundle up withdrawals and combine them into one transaction with many outputs. If every user could select their own fee, the total fee rate of the transaction would be unpredictable and some users would end up contributing more than others towards the total fee.
Additionally, even if they sent one transaction per withdrawal, transactions remaining unconfirmed would still be problematic, since that also implies that their change output remains unconfirmed. This means that they either couldn't spend the change until your transaction confirms, or would have to do a CPFP, spending extra fees to get your transaction to confirm faster.
@_date: 2017-12-04 09:08:53
So, like last wednesday?
@_date: 2017-12-23 10:21:02
It's not the currency that's taxed, it's the capital gains resulting from trading across exchange rate swings.
If you make profit from forex, it's taxed the same way (at least in my jurisdiction), so cryptocurrencies are not being treated differently from other currencies in this regard.
@_date: 2017-12-25 19:27:15
A bech32 address encodes a P2WPKH (native segwit) or P2WSH (native segwit scripthash) output which takes less space in transactions than outputs from old-style 1-addresses (P2PKH) and 3-addresses (P2SH).
The reason they are still uncommon is because they are not very well supported. Most current segwit usage uses P2WPKH wrapped in P2SH, which still results in less transaction weight than plain P2PKH.
It's specified in BIP 173: 
@_date: 2017-12-18 14:56:44
I'll have a go at your first question. I'm not sure a five year old would understand this, but I've simplified it as much as I could.
First of all, it's important to know that a wallet doesn't store bitcoin, it stores keys. The bitcoin itself is stored in the blockchain, which simply put is a global record of which keys are in control of which balances.
Each key is actually a pair of two keys; a private one that you keep secret, and a public one that you can give to anybody. When you create a transaction to spend your bitcoin, you sign the transaction with your private key, and anybody with a copy of your public key can prove that it was signed by your key.
The problem with keys is that they are easy to steal, they are just numbers. If anybody looks inside your wallet and sees your private key, they can also use that number to sign transactions spending your bitcoin.
To protect yourself against computer viruses finding your private key, you could use what is called a paper wallet. It is essentially just a piece of paper which your private key is written on. The problem is that you still have to load it into a computer when you want to use it to sign a transaction, and a virus could sit on your computer waiting for you to load a key and steal it before you have time to use it.
Hardware wallets solve this by moving the entire signing operation away from your computer. The hardware wallet is a separate device which stores your private key and never gives it away.
To spend bitcoin with a hardware wallet, you generate a transaction like usual, but instead of signing it on your computer, you send it to the hardware wallet. The hardware wallet will usually show you a summary of it on its own screen (if it's a model that has one) and ask you if you approve. If you do, it will sign the transaction and send it back. Now you have a signed transaction, just as if it were your computer that signed it, but the private key has never been on your computer.
@_date: 2017-12-06 21:11:11
No, the transaction funding the channel spent 4218 satoshi on fees as shown in the block explorer. The 546 satoshi fee was for the middle node to forward the payment between the sender and the recipient.
@_date: 2017-12-06 23:26:36
Transactions are identified by a hash of the contents. The inputs to one transaction refers to the hashes of the previous transactions they are spending outputs from.
Transaction malleability is caused by the fact that a valid signature can have multiple representations (sort of like how x^2 = 4 means x can be both 2 and -2). A valid signed unconfirmed transaction could therefore have its signature modified to another valid representation, and when hashed as part of the transaction, results in a different hash for the same transaction. This means that a malicious actor could malleate a transaction, causing it to confirm with a different ID than what the other actors expect. Segwit fixes this by moving the signatures to the new witness field that is not hashed when making the transaction ID.
This is important for LN because LN relies on unpublished transactions being passed between the actors off-chain, which means they could easily be malleated if they were malleable.
@_date: 2017-12-18 23:25:26
Unless there's no useful routes through the channel counterparty, which is why I suggested reinvesting the funds in a more useful channel.
@_date: 2017-12-05 22:54:40
I've come across a fourth type as well; those who understand the technology but doesn't think the power consumption and the resulting environmental impact is justified.
@_date: 2017-12-08 14:56:35
The value is backed by scarcity and demand. No more than 21 million BTC will ever be made and the price is set by how much people are willing to pay to get a piece of that.
@_date: 2017-12-13 15:06:53
a: The larger capacity channels it has, the larger transactions it can route. A node with only small capacity channels can route small payments just fine.
b: Channels don't get depleted, the funds just move to the other side. Transactions going in the opposite direction will move them back.
@_date: 2017-12-23 20:15:51
Remember that there's no such thing as addresses and balances as far as the blockchain is concerned. Only transactions with outputs.
If you send three transfers to the same address, you end up with three outputs spendable by the same key. To spend them all in one transaction, you still need to list all three outputs (by the id of the transaction each were created in) and sign for each.
If you instead sent those three transfers to three different addresses, the only difference is that you would sign the spending transaction with three different keys instead of the same key three times.
This is why there's no size difference between reusing one address vs always using new addresses. It doesn't change the number of outputs.
@_date: 2018-05-07 09:10:33
No, you wouldn't. Spending ten UTXOs on ten different addresses costs exactly the same amount of transaction space as spending ten UTXOs on the same addresses.
@_date: 2018-05-07 20:20:07
Not at all, you can spend them all in a single transaction.
If you make ten transactions to a single address, you make ten UTXOs.
If you make ten transactions to different addresses, you also make ten UTXOs.
When you want to spend these funds, you can in either case make a transaction with ten inputs, and you need to sign for them all. In the former case, you make ten signatures with the same private key, while in the latter case, you make the ten signatures with ten different keys.
The size of the signatures is the same regardless of whether they were made with the same key or different keys. When the size of the transaction is the same, the fees will also be the same.
@_date: 2018-05-24 20:51:00
My impression was that the block timestamp isn't very accurate. In theory the spec allows it to fall in a pretty big window, so it doesn't even have to be in order for two subsequent blocks.
I guess in practice it might actually be accurate enough to be usable as a disambiguating factor, I don't have any data on that.
Just remember that a block with timestamp 1:59 might arrive at your node a bit after 2:00, so if you do the drawing at 2:00 sharp, you can still get it wrong.
@_date: 2018-05-22 10:40:57
Your lottery is not provably fair. While we can verify that the payouts matches the number of tickets bought, we can't verify that the selection of winning tickets is fair. You could buy tickets yourself, and favor the tickets you bought.
@_date: 2018-05-22 21:59:36
If I were implementing a provably fair lottery system, I'd derive the entropy from the blockchain to make it provable that it weren't known ahead of time.
Instead of scheduling the drawing to happen at a particular time, I would say that next drawing occurs at block height X. At block height X, all confirmed UTXOs on the lottery address are awarded tickets which are put into a deterministically sorted list. You then use the block hash of block X, modulo the total number of tickets, to pick the winning ticket.
Since the winning ticket number is derived from the block hash which isn't known until the block is mined and all tickets must be bought before the block is mined, it is impossible to cheat the system*. Anybody can verify that a drawing was fair just by looking at the blockchain.
*: Unless you're a miner throwing away a block you mined because you're unhappy with the lottery outcome. Since the miner would lose the block reward by doing this, it's not a real concern unless the lottery pot grow larger than the block reward.
@_date: 2018-05-24 20:19:20
As long as you pick the winners in a deterministic fashion, the exact mechanism doesn't matter, so seeding a PRNG sounds just as good as doing a modulo operation.
The only problem I see with not deciding on a block height in advance is the possibility for ambiguity of which block is the latest at the end of the round. If a block just got mined a few seconds ago, have your node seen it yet? In theory you could calculate drawings for both blocks, decide which of the outcomes you prefer and then either announce winners based on the new block or the old block, claiming you haven't seen the newer yet.
On the other hand, even when you do decide on a block height in advance, there is a risk of orphans, leading to a similar ambiguity.
@_date: 2017-08-30 17:54:41
Bitcoin exists in the form of unspent transaction outputs (UTXO). In other words, the output of a former transaction that haven't been spent yet.
When you create a new transaction, each input to the new transaction is a reference to an UTXO. The more UTXO your bitcoin is divided between, the larger your transactions will be because each has to be referenced and signed for.
Consolidating simply means that you create a transaction to yourself, moving the values from a bunch of smaller UTXOs to a single new UTXO.
Since fees are calculated by transaction size, consolidating now when it's cheap means you pay a small fee now to avoid a larger fee in the future.
@_date: 2017-08-25 06:47:14
Yes. Check BIP 49.
@_date: 2017-08-16 18:53:42
Judging by a quick glance through recent changes to the code, it seems that the old firmware left sensitive data in RAM. An attacker with physical access to the chip could attach a JTAG/SWD debugger and read out the RAM contents, since the chip readout protection only disables access to the flash memory when a debugger is attached. Newer firmware is more careful about clearing sensitive data from RAM as soon as it's done using it.
I'm not 100% sure I'm correct, and I didn't look closely at what data this involves and under which conditions they'll be left exploitable.
@_date: 2017-08-17 07:32:32
Edit: I'm wrong.
~~There's no way of permanently disabling JTAG/SWD on a STM32. The pins can be remapped to other functions, but asserting the chip reset will restore them to their default function.~~
An exploit would look like this:
* Get the device in an exploitable condition (sensitive data stored in RAM).
* Assert the reset pin. This will stop the CPU and reset all the IO blocks to their default settings, but leave RAM untouched.
* Attach the debugger. This will make the protection circuitry disable the flash memory so it can't be read.
* Read out contents from RAM.
@_date: 2017-08-30 19:48:32
Strictly speaking, you only have the bitcoin you possess the private key for. Bitcoin in an exchange is held and managed by the exchange, and all you have is a promise that they'll send it to you if you ask for it. You don't own any specific bitcoins. When you withdraw they just send you whichever are conveniently available for them.
A wallet manages keys, each key has an associated address and every transaction to an address creates an UTXO. This means that every transaction to any address in a wallet creates a new UTXO managed by that wallet, regardless of whether you reuse old addresses or use fresh ones.
When you send money to somebody from your wallet, the wallet will construct a transaction that consumes enough UXTOs to reach the desired value, creates a new UXTO for the target address, and if there's any left, it'll create another UXTO for yourself with the change.
A wallet that has received ten transactions but not sent any will have its value distributed across ten UXTOs. Sending the whole contents of that wallet to a new address consolidates it on one UXTO.
@_date: 2017-08-17 13:56:45
User manual is right and I stand corrected.
STM32F2 can indeed disable debugger access permanently. STM32F1 can't, and I weren't aware that this had been improved in newer families.
@_date: 2018-06-02 12:08:03
Yes and no. Mostly no.
It is possible to derive a 1-address, a 3-address and a bc1-address from the same keypair, and if you as the owner of that keypair tell people they can use either, everything is good.
The problem is that each of those addresses would result in transaction outputs with different scriptpubkeys, and somebody that gave you one type of address wouldn't necessarily have their wallet software looking for transactions to the other kinds of scriptpubkeys derived from the same keys, which means that they won't see that they've received anything.
If you get an address from anybody that your wallet software doesn't support, you should explicitly ask them for a different address you can use.
@_date: 2018-06-15 10:00:13
I don't think it makes sense to think in terms of a time limit. The money I'm holding in bitcoin is money I don't need for anything else, and as such I don't have a given time I need to withdraw it by.
If bitcoin drops a lot in price, to the point where I'm significantly down from my original investment, I would probably liquidate it all to realize the loss and write it off on my taxes, then immediately buy back in.
If bitcoin increases a lot in price, I would probably realize part of the gain to pay off debt, freeing up the income that were maintaining the debt, then using that income to gradually buy back in again.
@_date: 2018-06-08 07:55:03
At 12:00, there's a 50% chance for the next block to be produced by 12:10. Part of that chance is for the block to be produced between 12:00 and 12:05 and the remaining part is for it to be produced between 12:05 and 12:10.
At 12:05, with no new block yet, your perspective have changed. You now know that there's zero percent chance of the block being produced between 12:00 and 12:05. Because part of the previous 50% chance went to zero, it's not 50% anymore. However, if you now add together the chance of it being produced between 12:05-12:10 and 12:10-12:15, you're back at 50%.
Statistics change when you add more knowledge. If the block arrives at 12:08, the probability of it being made before 12:10 goes up to 100%, but you couldn't have known that in advance. At any point in time you know that the next block haven't been made yet, the expected time would be in 10 minutes.
@_date: 2018-06-01 13:23:07
I find it useful for doing fast and cheap international transfers with currency exchange.
Local exchanges/brokers can usually do quick and more or less free deposits/withdrawals through domestic bank transfers, exchanging to/from bitcoin is cheap and the bitcoin transfer between the two exchanges is fast and cheap. This way I can do same-day international bank to bank transfers for less than what just the currency exchange would cost if the bank did it.
@_date: 2017-08-26 08:46:58
You can't find a block and then fill it with transactions. Once a block is found it can't be modified.
@_date: 2018-06-11 08:38:42
The only ownership the blockchain knows/cares about are which keys are authorized to spend which coins (UTXOs).
When you steal a private key, as far as the blockchain is concerned, you're now just as authorized to spend those coins as the original owner of the key.
@_date: 2017-11-18 12:33:55
It's using properties of elliptic curves to achieve this.
If you have a private key k, the associated public key K is calculated as K = f(k).
The function f(k) is elliptic curve point multiplication, meaning that you can think of it as simply doing k * P, where P is a fixed constant. It differs from normal multiplication by not having an inverse function (i.e. division), so it can be used as a one way function, but other properties of multiplication still applies. Consider how a * x + b * x equals (a + b) * x. For the same reason, f(a) + f(b) also equals f(a + b).
Let's say you have a wallet with a private master key k and a public master key K. A watch only wallet knowing K but not k can then generate receive addresses for it by doing K + f(1), K + f(2), K + f(3) and so on. To spend from those addresses you need to know k, because the corresponding private keys for each address would then be respectively k + 1, k + 2, k + 3 and so on.
The actual implementation is a little bit more complex, but it's all built on this fundamental property.
@_date: 2017-11-05 11:18:31
Forks don't increase the supply, they make more denominations within the same limited supply.
If you own 21 coins pre-fork then you own a millionth of the total supply. After a fork, you still own a millionth of the total supply of either chain.
@_date: 2017-11-18 09:05:18
I think you missed my point. I don't see why the chargeback risk would be any higher for bitcoin withdrawals than for cash withdrawals. The bank can't do anything more to get their cash back than to get their bitcoin back.
@_date: 2017-11-05 13:47:29
UTXO is just an acronym for unspent transaction output. Identical transactions on both chains will create identical UTXOs on both chains.
Imagine you have a fork, resulting in forked coins A and B, and you want to send A to somebody. You create a transaction authorizing the spend and publish it to the A network, where it'll be mined into the A chain. If the inputs to that transaction are also valid UTXOs on the B chain, the same transaction you published to the A network can also be published by anybody to the B network, giving the same recepient the same amount of B coins.
When you are attempting to split your coins, you yourself are the recipient, so regardless of whether you manage to only send yourself your A coins or it gets replayed so B coins also get sent, you still have control of all the coins in the end.
@_date: 2017-11-10 08:15:16
Keep in mind that trying to prevent someone from accessing the internet is different from trying to prevent the internet from accessing someone.
Even if you can reliably DDoS the IP you're connecting to B at to the point where no other traffic gets through, there's ways around that.
* B could be hidden behind a DDoS protection layer like cloudflare.
* B could have redundant connections. You only know the IP of one.
* B could have a backup node in a different location that knows the refund transaction and will publish it to the blockchain if necessary.
@_date: 2017-11-05 10:17:58
There isn't really a big risk of loss (apart from the risk inherent in moving coins at all).
If you don't manage a successful split, the end result is identical UTXOs on both chains, which means that apart from some spent fees, you're back where you started and can try again.
@_date: 2017-11-20 08:37:22
Depends. Here's where my math differs from the actual implementation.
In my simple example, knowing one private key (say k + 2) makes it easy to just keep adding numbers ((k + 2) + 1, (k + 2) + 2 and so on) to derive the other keys.
In the actual implementation, the added key is not just a plain number, but a hash derived from the parent public key, which means that just knowing one doesn't let you calculate the next.
If you however know both the public master key for an account and one of the private keys for any address in that account, you can use the public master key to find the added key for that private key and subtract it, leaving you with the private master key.
This is warned against in the specification: 


@_date: 2017-11-05 09:23:20
The lack of replay protection only makes it harder to reliably split your coins, not impossible.
Say you have a pre-fork UTXO. To split it, all you have to do is make a transaction spending it with RBF. Once it confirms on one chain, you use RBF to sign a new transaction before it confirms on the other chain. If you're successful, you'll end up with a new UTXO on each chain which doesn't exist on the other.
Once you have independent post-fork UTXOs, you can use them to split the rest of your coins. A transaction that includes an input which only exists on one chain is invalid on the other chain.
You don't even have to do the initial split yourself, you can just get a transaction from somebody else who has managed to split their coins.
@_date: 2017-11-17 08:28:51
Why would accepting payments from debit cards for bitcoin be any more risky than accepting payments from debit cards for cash?
@_date: 2018-06-19 09:06:42


It doesn't matter what block you build upon*, the probability of finding a new block is the same. If they discarded the 6.25 block, the probability of getting a 12.5 block is the same as if they kept it and then mined a 12.5 block. The difference is that in the former case they would earn 12.5 in total, in the latter case they earn 18.75.
*: Unless this happens on difficulty adjustment thresholds, but you'd have to have a difficulty doubling to even statistically break even, and that's before you consider competition. In practice it'll almost never make sense to throw away a block you mined as long as you gain any award at all from it.
@_date: 2018-03-08 09:24:41
The transactions can have more than one input, but the graph is only showing the inputs that originated from the transaction you started at.
@_date: 2018-02-25 13:13:02
So in other words, you've got a deal where you can both have the cake and eat it too.
Mind telling me more about that? I've been looking at solar myself, and all the deals I've seen just pays based on the amount I export to the grid.
@_date: 2018-03-04 00:05:28
Yes. From a collection of valid transactions, the miners can choose exactly which they want to include and not.
However, excluding transactions means missing out on the fees those transactions would have paid. Rational miners would prefer transactions based on fee rate, not type.
@_date: 2017-09-09 08:25:46
Yes. Read BIP49, it describes how to derive segwit addresses.
@_date: 2017-09-25 19:53:10
But in that case you cash out $5k. That's not what you said.


$1k worth at a rate of $5k would be 0.2 BTC. 0.2 BTC bought at a rate of $4k would have cost you $800.
You didn't specify how much was bought, only that $1k worth was cashed out, which translates into a realized gain of $200. Even if you bought for more than $800, it doesn't matter because you haven't realized a gain on the remaining BTC yet.
@_date: 2017-09-13 22:22:20
How long does it usually take to sync from scratch nowadays?
I set up a 0.15.0rc3 node last week, and it spent about 5.5 hours syncing from scratch. I don't know how this compares since the last time I ran a full node was in 2013 or so, but I expected it to take longer.
@_date: 2017-09-25 16:22:25
Your math doesn't make sense to me.


If you buy at $4k and cash out $1k at $5k, the amount you cash out had a purchase value of $800 and thus you've realized a gain of $200, which if taxed at 25% results in $50 due in taxes.
The only thing that makes a real difference is whether you realize gains as short term or long term, because the tax rate is different.
Disclaimer: I'm in a different jurisdiction from you, so my understanding might be wrong.
My jurisdiction additionally doesn't distinguish between short term and long term gains, which makes it completely irrelevant when and how the gains are realized.
@_date: 2018-02-10 22:32:52
P2PKH, P2SH, P2WPKH and P2WSH all refers to scriptpubkey templates.
The P2PKH template looks like `OP_DUP OP_HASH160 &lt;hash&gt; OP_EQUALVERIFY OP_CHECKSIG` which is a script that validates a single signature against the provided pubkey-hash. A 1-address is translated into this template.
The P2SH template looks like `OP_HASH160 &lt;hash&gt; OP_EQUAL` which is a script that validates a serialized script against the provided hash. If it matches, the serialized script is evaluated. A 3-address is translated into this template.
The point of P2SH is that you can create a standardized address from any sort of script. Multisig schemes makes use of this to create a custom script that checks more than one signature.
A theoretical P2SH-P2PKH address would be if you made a P2PKH script, then serialized that and made a P2SH script out of it. It is entirely possible to do that, but it is completely pointless as it adds nothing over just using the P2PKH script directly. Any software that supports 3-addresses should also support 1-addresses.
Segwit adds two new templates; P2WPKH and P2WSH. They both have the template `OP_0 &lt;hash&gt;` and are distinguished by the type/length of the hash. They basically work the same way as P2PKH and P2SH respectively, but are evaluated with data from the witness field instead of the scriptsig field. The new bech32 (bc1-) addresses will be translated into this template.
The problem with introducing new templates is that wallets needs to be updated to support translating the new addresses into the corresponding templates. To work around that, we can wrap it in P2SH, creating P2SH-P2WPKH and P2SH-P2WSH, which is supported by any wallet that supports P2SH. When spending it, we just have to provide the P2WPKH or P2WSH script in the scriptsig field and the rest of the data in the witness field.


Yes. It's key reuse that's the problem. Address reuse just implies key reuse.


The witness field counts as 1 WU/B, the scriptsig field counts as 4 WU/B. Note that with P2SH-P2WSH, you have to provide the P2WSH script in the scriptsig field, so if the custom script is small, it might be overall cheaper to create a plain P2SH output rather than P2SH-P2WSH. Any multisig script is however probably large enough to benefit from the witness discount.


I don't think how to use it for multisig specifically is described in any BIPs, but using P2WSH or P2SH-P2WSH compared to P2SH is just different ways of turning the same custom script into an address, which is described by BIP 141.
@_date: 2018-02-01 10:32:19
Okay. Your scenario, as far as I understand it, is that you have an empty LN wallet with no channels. You go to a bitcoin ATM, deposit an amount of cash, and ask to have it sent to you over LN. Your desired end result is spendable bitcoin on LN. Do we agree so far?
Now, since you don't have any channels, the ATM won't be able to find an existing route to you over LN. To solve this, it will create the route it needs by opening a new channel to you.
The LN spec includes a push-feature where the funding node can state that some (or all) of the initial balance it puts in belongs to the remote end.
Let's say you deposited $500 and got 50 mBTC for it. The ATM can now open a channel to you with 50 mBTC capacity, using the push-mechanism to assign all 50 mBTC to your side of the channel. Once that's done, you now have 50 mBTC spendable on LN by routing back out through the ATM's node.
@_date: 2017-10-20 20:31:37


Witness data is just discounted, not free. There's also a fair rationale for why:
Since the witness data only satisfies spending conditions for the inputs, it doesn't relate to the outputs and thus doesn't grow the UTXO set. In other words, the witness discount makes creating outputs more expensive relative to consuming inputs than what was the case for legacy transactions.
While a bitcoin node stores the full blockchain history, once validated, it's only really useful for sharing with other nodes and to backtrack during chain reorgs. Validation of new transactions happens against the UTXO set which is stored in a separate database which thus contains every currently existing bitcoin balance.
Because of the different sizes and access patterns, it could make sense to store the blockchain history (big, low activity) on a HDD and the UTXO set (smaller, high activity) on a SSD. For this reason it also makes sense to penalize growing the UTXO set more than just growing the blockchain history, and this is what the segwit discount achieves.
@_date: 2017-09-04 19:21:21
In my application, I'm monkeypatching bip32utils to add BIP49 support:
    def SegWitP2SHAddress(self):
        addressversion = b'\x05' if not self.testnet else b'\xc4'
        scripthash = hashlib.new('ripemd160', hashlib.sha256(b'\x00\x14' + self.Identifier()).digest()).digest()
        return bip32utils.Base58.check_encode(addressversion + scripthash)
    bip32utils.BIP32Key.SegWitP2SHAddress = SegWitP2SHAddress
I ought to have submitted a patch against bip32utils, but I'm lazy and wanted an immediate solution without maintaining my own fork of bip32utils, so I resorted to monkeypatching for now.
@_date: 2017-09-06 11:44:57
Some napkin math:
There's 12 characters of the key visible (5JoVk..s2kHW..8Q), but the first two characters are always 5H, 5J or 5K giving only one bit of information in total and the last two are just part of the checksum which we could validate against but otherwise tells us nothing.
The visible data-area of the QR code looks to be approximately 5x16 modules which at 8 modules per character should give us another ten.
If we assume no overlap between the QR code and what we already know, we have one bit and 18 characters worth of information. Each character gives log_2(58) bits of information. 1 + 18 * log_2(58) ≈ 106. Since the private key is 256 bits, we can at best narrow down the search space to 2^150.
@_date: 2018-02-15 13:00:01
No. If nobody is paying you, nobody has any reason to open a channel to you. Even if somebody did, they wouldn't be able to route any transfers through your node if your node has zero local balance.
@_date: 2017-10-10 08:27:54
Xapo is saying that a fork will happen if some miners keep mining an 1x branch (while the rest is mining the 2x branch), which is technically correct.
Strictly speaking, a fork is where you have multiple chains branching off from one point. If only one chain exists after the 2x activation event, a fork has not occurred, regardless of whether the consensus rules have been changed or not.
That said, I agree that it's deceptive to present 2x as the defacto and a surviving 1x chain as a potential issue.
@_date: 2018-02-10 12:38:33
No, that doesn't exist. The multisig rules are defined by a custom script, which implies it'll either be traditional P2SH, native P2WSH or P2WSH wrapped in P2SH.
@_date: 2017-10-06 13:51:15
The futures scheme is symmetric and thus as fair as it could be.
Since BT1 and BT2 tokens represent post-fork coins, one pre-fork BTC is worth exactly one BT1 plus one BT2. This gives the equation BTC = BT1 + BT2.
If the 1x chain dies after the fork, BT2 will be the new BTC, and substituting in the equation gives BTC = BT1 + BTC. Subtract BTC on both sides and you're left with BT1 = 0. The result is that the BT1 tokens are worthless since there's nothing to redeem them as.
The situation is the same if the 2x chain doesn't survive. BT1 = BTC, BT2 = 0. It does not matter whether the 2x chain doesn't fork at all or dies after a few blocks mined. In either case there would be nothing to redeem BT2 as.
The article you linked have two proposals:


This makes no sense at all. A pair of BT1 + BT2 tokens is worth exactly one pre-fork BTC. Where would the worth go? To the exchange?


Since a pair of BT1 and BT2 tokens is originally created from a pre-fork BTC, the reverse transaction would require a pair of BT1 + BT2 tokens as input. In other words, you would have to refund equal amounts of both. Holding equal amounts of both defeats the whole purpose of splitting pre-fork coins into futures.
@_date: 2018-07-09 14:08:47


Why not? Presumably there will be plenty of routes between all your favorite stores, so you'll only need to connect to one of them either way. A commerce node is also likely to have better reliability and capacity than some random other node.
@_date: 2018-07-21 20:10:38
The basis of public-key cryptography is that you have a related pair of keys; a private key only you know, and a public key you can give to anybody. When you sign a message with the private key, anybody with a copy of your public key can verify that it was signed by your private key.
A normal bitcoin address contains the hash of a public key. When somebody are sending bitcoin to one of your addresses, they are creating an UTXO with the condition “to spend these bitcoin, you need to provide a public key matching this hash and a signature proving you possess the matching private key”.
In short: To spend bitcoin sent to an address, you need to sign the spending transaction with the private key matching the address.
When you want to spend bitcoin, the UTXO with the spend condition (pubkey hash) is already in the blockchain. The UI/app you're using with the hardware wallet will create a transaction referring to this UTXO and give it to the hardware wallet for signing. The hardware wallet will make you confirm on its own screen that the contents of the transaction matches what you want to do before it signs the transaction and passes it back to the UI/app. When the miners receive the signed transaction, they will verify that the signature is valid and thus satisfies the spend condition before allowing your transaction into a block.
There's nothing secret in the transactions themselves, so they can be passed through unsafe devices. The only thing that's secret are the private keys, and the purpose of a hardware wallet is to make sure they are only used to sign transactions you actually want to sign.
@_date: 2018-07-09 14:01:14


Agreed, I haven't claimed otherwise. You'll only have to open new channels when there's no viable route through existing channels for your payment. This includes being a new user without any existing channels.
I'm arguing that when you do need to open a new channel to create a new route for your payment, the obvious solution to ensure it'll give you a viable route is to create a direct channel to the recipient with sufficient capacity.
@_date: 2018-07-21 21:52:27
I'm sorry about the jargon, it's hard to explain technical stuff without using technical terms. I'm not sure you're truly interested in understanding, but I can give it another try in simpler terms.
A bitcoin transaction is just a piece of information that says which bitcoin you are spending, why you are allowed to spend them and where you are spending them. When you make a transaction, you are saying “I am spending these bitcoin sent to address A, here's a signature matching address A, I'm sending them to address B”.
The signature is a number that is calculated from both the contents of the transaction and the private key. The way it is calculated requires knowing the private key to make it, but once it is made, anybody can prove it was made from the private key related to a specific address, without knowing the private key itself.
Since the signature is also calculated from the transaction contents, the signature is only valid for those specific contents. In other words, if anybody tries to change your signed transaction to say “I'm sending them to address C” instead, the signature will not be valid anymore.
Because of these properties, all a hardware wallet has to do is sign your transaction, and anybody that gets the signed transaction will be able to prove it is a genuine transaction without the private key ever leaving your hardware wallet. All you have to do after getting the signed transaction from the hardware wallet is broadcasting it to the Bitcoin network, sending it to anybody who are listening.
The miners are among those listening, and when they receive your transaction, they will verify both that the signature is valid and that the bitcoins you are claiming to send actually exists. If the transaction is valid, they will include it into a mined block, adding it to the blockchain and thus confirming it.
@_date: 2017-10-14 08:03:21


No, it isn't. Changes that widens the consensus rules to make previously invalid blocks valid is a hardfork, because older clients would not accept them and thus cause a fork in the blockchain.
Changes that tightens the consensus rules is a softfork, because they would still be accepted by older clients. This is why segwit and other features that have been added looks like anyone can spend transactions to older clients.
Hardcoding a given block hash in newer clients does not make older clients not accept it, and is thus not a hardfork.
@_date: 2018-07-20 21:30:59


The whole point of a hardware wallet is that the private keys never leave the device itself (apart from the mnemonic backup you make when you initialize it). If there were a way for the vendor to get them out, that would be a hole anybody else could exploit too, and you can bet people are looking for those holes.
@_date: 2018-07-23 19:20:16
On Trezor, the firmware is open source, so you can review the code and build it yourself to confirm it matches the running firmware.
If you still don't trust this, you can instead choose to provide an externally generated seed, e.g. one you make with dice: 
@_date: 2018-07-08 20:30:30
When people want to start transacting over LN, why would they want to open their first channel to you rather than directly to the place they want to transact with? Once they have other open channels, why would they want to open another channel to you?
I believe the nodes that will grow into active hubs are nodes that users have a reason to connect to in the first place, i.e. businesses that does something more than just routing transactions. You can't just set up a node and expect people to connect to it without any particular reason.
@_date: 2018-04-16 14:26:20
I've used bitcoin to move money between international bank accounts before.
I have bank accounts in several countries with different currencies, so I signed up for a local exchange in each country. When I want to move money between my accounts, I do a bank transfer to one of the exchanges, buy bitcoin, send the bitcoin to the other exchange, sell it and withdraw it to the other bank account.
Both transferring to and from the exchanges are standard same-day domestic transfers, so it only takes a few hours from the money leaves one bank account until it's available in the other.
The alternative would be doing a standard international transfer (SWIFT), which would both be slower and more expensive. An international transfer takes at least a day or two, and the currency conversion fee is higher than what it costs to exchange to bitcoin and back combined.
I did have to comply with KYC/AML for both exchanges, but as there's nothing illegal with what I'm doing, I'm not concerned about them knowing who I am.
@_date: 2018-07-21 23:14:09
What is it you want to know then? The actual math behind how signatures are made and validated? Feel free to read the Wikipedia article on [ECDSA](
If you think this is simple math that you learned the basis for as a kid, that's good on you. I'd argue that even most adults don't have the basis for understanding this.
@_date: 2018-04-09 07:11:49
Correct, transactions spending non-segwit UTXOs are still malleable.
Regarding LN, the channel opening transaction should only spend segwit UTXOs, anything happening before that is not relevant. As long as the LN wallet is only generating segwit receiving addresses, moving money to the LN wallet creates segwit UTXOs regardless of what the previous ones were.
@_date: 2018-04-11 11:50:07
Keep in mind that the channel point is a multisig output from the funding transaction. Before publishing the funding transaction, you require a signed HTLC ensuring you can always do a unilateral close to get your funds back in case your counterparty stops cooperating.
If you use non-segwit inputs to the funding transaction, it can get malleated after you publish it, before it confirms. This renders the HTLC invalid and you are not able to do a unilateral close anymore, breaking trustlessness. In this situation, the only way to recover your funds is for you and your counterparty to cooperate on signing a new transaction that spends the malleated output.
@_date: 2017-10-06 19:40:40
If you're buying BT2, you're betting on the future value being in the 2x chain. If the 2x chain never comes into existence, it's fair to say you've lost the bet.
Consider this: Let's say the fork happens, but the 2x chain ends up trading for such a low value that the chain is not profitable to mine, so after a short time, all miners desert it. Now the chain is dead and the people betting on BT2 loses their money. How do you argue this is more fair than if no 2x blocks were mined at all?