@_author: kanzenryu
@_date: 2011-05-30 03:40:19
Thanks! 1QFxCb7oZLEwmkEJaEgUt5t9hv1k5RdgjW
@_date: 2011-05-30 03:14:13
The hash is the result of calling the sha256 hash function on the block+nonce we are trying to create. The block is made up of transactions we have collected from the network. These transactions may also be offering a transaction fee to be paid to the creator of the block (i.e. own of our addresses), so that's another incentive (we get to choose which transactions we want to make a block from). By assembling all of the transactions into a block structure and setting the nonce value we have the raw data that we can then try feeding into the sha256 hash function. The block also contains the [hash of the previous block, called the mrkl_tree]( so that a blockchain is formed.
@_date: 2011-05-31 21:14:37
If insufficient attention is paid to the network into which transactions are sent (as opposed to the mining nodes) then it may be weak to DDOS attacks. In addition the blockchain is the central construct. If a way of poison it can be found (e.g. long sequences of transactions that take time to validate) then Bitcoin is in trouble.
@_date: 2011-05-31 21:11:58
The idea would be to undermine confidence in Bitcoin. Confidence that you can turn your Bitcoins into goods/services/dollars in the future is everything for this system. 
@_date: 2011-05-30 02:25:39
[Here's an example of a raw block representation:] (
The hash was 00000000000023b6e025188e169338e8aa83c15a9a89473962166d1d0a048a25 which is less that the [current target]( of 0000000000002694210000000000000000000000000000000000000000000000
Note the value "nonce":1193811103, so presumably all the nonce values tried before that created hashes &gt; target.
How's this sounding so far?
@_date: 2011-05-30 02:54:51
The current target is 0000000000002694210000000000000000000000000000000000000000000000. That's a loooooong was from all zeros. It will never get anywhere near all zeros. It just has to reach a value such that all the computing power in the network averages 10 minutes to generate a valid block. At the moment the computing power in the network is rising, so the target decreases.
@_date: 2011-05-31 21:19:46
I don't want to attack Bitcoin. I want us to think hard about if there is any way to defend/prepare/mitigate such attacks.
@_date: 2011-05-30 21:26:11
Both blocks are sent into the network. One of them arrives sooner at some nodes, or has more total work in it. The network churns away, some nodes processing one, some the other. Soon somebody completes the next block and broadcasts it and very rapidly everybody agrees that this is now the longest blockchain. Forks can legitimately exist for a short period of time, but this situation is inherently unstable and soon a new blockchain emerges that everybody agrees on. Then the older blockchain is abandoned, although any transactions in it that are not already in the longest blockchain are re-added to the next block so they don't get lost.
This happens all the time. That's why you want to wait for several blocks before you consider a transaction to be confirmed.
@_date: 2011-05-30 03:51:51
You might benefit a little more from perusing this alternate implementation, in javascript 
@_date: 2011-05-30 03:48:30
I'm 1QFxCb7oZLEwmkEJaEgUt5t9hv1k5RdgjW
@_date: 2011-05-31 21:09:31
A lot of the responses I have seen look rather weak, like "transactions fees will cost the attacker too much". I'm unconvinced this will deter a billion dollar attack.
@_date: 2011-06-10 03:49:17
Wow, a reply from the (alleged) legend himself.
@_date: 2011-05-31 21:16:14
I think this approach would be one prong of a billion dollar attack. Can we find a way to counter it or should we give up now?
@_date: 2011-05-30 02:47:05
Yes, we calculate our own hash using the loop you just described until the hash(block + nonce) &lt; target
As I understand it ExtraNonce is an overflow field (given the limited size of the nonce field).
@_date: 2011-05-30 01:56:11
So we have a block. hash(candidate_block) == something, but this doesn't prove we did a significant amount of work. But if everybody agrees on some value called target, then we can try to see if hash(candidate_block + nonce) &lt; target, starting with nonce = 0 and increasing until the hash is &lt; target. When we finally find a value for the nonce that satisfies this we broadcast the candidate_block, which contains the nonce. Everybody else can easily verify that hash &lt; target. Obviously as the target value decreases it takes more and more work on average to find a nonce that satisfies this. Note that everybody's candidate blocks are different because they try to pay 50 coins to their own address. So the nonce might be 123456789 for you and 987654321 for me. As long as everybody agrees on the rules that choose the target value and the structure of the block on so forth then the integrity of the system is preserved.
@_date: 2011-05-31 21:12:48
True. Apologies for the original brain-dump style.
@_date: 2013-03-12 01:19:56
Just don't say "emergency blockchain fork in progress"