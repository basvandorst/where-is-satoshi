@_author: flyingapples123
@_date: 2017-09-18 10:27:23
Hi! I solved  :)
The solution was to take the given string, apply ROT-47 then ROT-5 to it, giving a hex string.
After that xor the bytes represented by the hex string with the ASCII values of the hex of SHA256("CoinGate"), giving a string with 12 null bytes and 52 bytes, which can be converted to text by ASCII.
Then take the 1st letter, skip the next 32, take the 34th letter, skip the next 32 (cycling around), taking the 15th letter, and so on in that order, giving the 52-byte private key. :D
@_date: 2017-09-18 15:44:12
The reason why I XOR-ed that way was because I noticed that the first bit of each byte in the string after ROT operations was always 0, but somehow were not ASCII.. so I figured there must be a XOR operation with an ASCII-represented string to make it valid ASCII (since the first bit of each ASCII byte is always 0)... and the SHA256 hash was just conveniently there, with a matching length.
@_date: 2017-10-01 13:49:55
Hi I solved  :)
An observation is that if we consider all the [letter, number (&gt;= 2)] pairs, those with the vowels can only be "surrounded" by 0s, and those with the consonants can only be "surrounded" by 1s. This suggests some kind of alternating encoding.
We can consider each [character, number] pair or 0/1 as a single "token", and we can split the tokens up into two groups: Group A being all the [vowel, number] pairs and 1s, and Group B being all the [consonant, number] pairs and 0s. Group A and Group B tokens will alternate in the string.
If we consider the occurrences of each of these new "tokens", we can see that the most common token in each group occurs about twice as much as the second most, and the second occurs about twice as much as the third most, and so on... so this suggests some form of Run-Length Encoding (along with the irregular ciphertext length and alternating patterns).
So if we take Group A as chains of 1s, and Group B as chains of 0s, and the length of these chains being 1 if the token is 0/1 or the number in the token otherwise, we can create a bit string of length 416.
If we reverse that string and convert it into ASCII, we can get our private key (length 52) :D
@_date: 2017-09-18 11:15:56
Yeah I realised the websites seemed to give different results... so I just used wrote a small script to do it locally instead. Here's the [code]( if you're interested.
@_date: 2017-09-18 11:21:53
After ROT-47 and ROT-5, the string I got was "35306666663835346366336572370774590d6b6509152f5c477b047b2d2e0c506e4257705236415c50533550521c05466931106a55571a07735f01655033625b".
Then I took the ASCII representation of the hex of SHA256(CoinGate), and xorred it with that ^^ which gives "0000000000000000000000004b54634d386b535768774b38774b3443484d3467577161433154736b31315762317936735a527158623278624b66335334555138", which converts to "KTcM8kSWhwK8wK4CHM4gWqaC1Tsk11Wb1y6sZRqXb2xbKf3S4UQ8" when decoded with ASCII, then rearrange the letters using the skip-33 method to get the final private key.
@_date: 2017-10-01 09:02:14
But there also seems to be '2' letters which are low frequency... and u3 and c3 also has relatively high frequency.
a2: 2,
a3: 2,
a4: 3,
c3: 14,
e2: 38,
g2: 1,
h2: 5,
h3: 1,
p6: 1,
r4: 3,
t5: 2,
u2: 1,
u3: 10,
w2: 22,
x2: 4
I was considering if the letter sets were 1-to-1 substitution of hex characters, and the spikes in frequency would be due to the location of printable characters in ASCII... but it doesn't seem to be the case.