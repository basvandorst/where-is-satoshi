@_author: forestier_seb
@_date: 2019-06-21 07:41:29
Hi u/anon516,
Our architecture is actually fairly simple when compared to other approaches to scaling (e.g. L2, side chains, other L1 like Spectre, or other sharding schemes). It is a straightforward parallelization of the classical blockchain and of the Nakamoto consensus rule. As explained in the blog post in order to scale the number of transactions per second it is necessary to use a different architecture than classical blockchains. That is why so many cryptocurrencies interested in scaling are looking at sharding and/or DAG. To the best of our knowledge, architectures that manage to reach very high throughput using simpler architecture are either centralized or unsafe.
Increasing the number of shards increases the size of block headers. At some point the increase in transaction throughput is compensated for by the increase of block header size. In our architecture, this limit is roughly around 100 shards. Also choosing the number of threads impacts the security of the architecture. When the number of threads is high it is necessary to increase the finality parameter in order to protect against fork attacks. For a more thorough discussion on the influence of the number of shards/threads see the section 3.3 (security analysis) and 5 (Discussion) of our technical paper.
Nodes have to perform the following computational tasks: verify the block, the transactions inside the block and compute the blockclique. The first two tasks are similar as what would be done in any blockchain. Only the third task is specific to our architecture. For the set of parameters that we consider it would take on average (roughly) 10ms per block.
These considerations are backed up by the simulations that we have performed. In our open-source simulations, up to 4096 nodes create and send blocks across a simulated network. In the simulations, all nodes compute the consensus rule, however we do not cryptographically verify blocks and transactions, so that the simulation can be performed on a single 4 Ghz, 8 cores computer in real time.
You can have a look at the appendix B.2 of our technical paper for a bit more details on the computations that must be performed by each node.
Our technical paper: [
@_date: 2018-03-29 14:19:47
Here is the open-source code that you can try: [
And you can see a video of a simulation here: [