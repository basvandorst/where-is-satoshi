@_author: jawaiah
@_date: 2018-01-18 17:39:01
응 ㅋㅋㅋ (gomap sumnida a little more formal but same same)
@_date: 2018-01-19 17:19:43
@_date: 2017-12-16 03:02:25
@_date: 2017-12-16 06:07:58
Memes kill
@_date: 2014-05-01 10:19:36
I thought of 3, the first one and a half were things you can do with money anyway.
1. Hire a militia to steal from innocents.
2. Pay your labor force in bitcoins, but exploit the labor surplus to underpay them. To soothe their discontent, make the observation that if they save their coins til prices go up they will effectively be making high wages. 
3. Create a large mining network and through law or sheer wealth enforce block chain supremacy. Make people pay you an extra tax for their transactions to be added to the chain.
@_date: 2014-11-15 23:08:28
What about economics do you see as pseudo-science?
@_date: 2014-11-06 09:09:28
Oh that's [Lord Helmet from Stargaze]( right?
@_date: 2014-11-16 00:20:29
Failing to accurately come to consensus on a prediction does not make a field "pseudo-science." Empirical science is about using models to hypothesize, then testing the hypotheses, and refining the models to accommodate the test data.
You might as well say, "mainstream physics didn't predict the rate of expansion of the universe, therefore physics is pseudoscience!"
Just like physicists, there are some things that economists have modeled very well and other things that they haven't.
@_date: 2014-11-16 02:12:08
Predicting something in science is not about past-present-future, it's about reality ending up reflecting the models or not after observational tests.
@_date: 2014-05-01 10:20:58
Better than buttbreathers
@_date: 2014-05-01 09:36:36
That's not really relevant to my comment. I'm aware of the transaction fee and also that there's no block limit. I was suggesting introduction of parallel interrelated chains with harder proofs of work and longer hash lengths.
Is there some reason why mining new or harder chains is superfluous? In that case why even have coin rewards now?
I'd love it if the people downvoting would take the time to explain their contrary view. This isn't guys, we're here to bring about the era of cryptocurrency. Communication is essential.
@_date: 2014-05-01 03:00:31
I've not read up on this problem but my intuition is that you could just start a new transaction block chain, probably one with longer bit lengths and harder proofs of work.
In fact I don't see any problem with having multiple parallel or overlapping chains right now. Speaking intuitively again, this could actually contribute to robustness of the block chains if we came up with good methods for their interaction.
@_date: 2014-08-05 20:23:26
[linky winky](
@_date: 2017-03-29 08:37:39
My S3 buckets went down in 3 regions for like 5 hours the other day...
@_date: 2017-03-13 02:40:05
Idiot question, aren't you saying that we should rely on the exchanges to provide capacity for this change?
@_date: 2017-03-29 08:36:41
Ah the 90s were my favorite decade....
@_date: 2017-08-02 17:11:22
Interestingly the stroke order for Chinese descent languages means you still draw each character top to bottom, left to right.
@_date: 2017-09-27 00:13:51
@_date: 2018-02-09 03:26:30
Or HEDL?
@_date: 2017-09-01 05:37:32
Brutal, savage, rekt
@_date: 2018-02-15 05:48:36
What is your basis for the figure of 1M?
@_date: 2015-10-01 15:45:59
That's a terrible analogy. Never do that.
@_date: 2013-08-10 13:49:26


just because they read every line doesn't mean they understand everything it does or its role in the bigger picture


I think you're making two mistakes here.
First you're assuming because we're discussing "Linux vs. Windows" that we're talking about the kernel. While technically Linux is the kernel, when discussing security we need to talk about the system as a whole. In this context Linux means the collection of software distributions and hardware setups which use the Linux operating system kernel.
The second part is assuming that "obfuscated code" is something that looks blatantly obfuscated, as if they ran it through a commercial ECMAscript obfuscator, were submitting it to the obfuscated C competition, or were playing code golf.
Obfuscation comes in many shapes and sizes. Functionality is not necessarily contained within a single file, program, or indeed even on a single machine. Even at the hardware level, it's relatively easy for the low-level engineers to design trigger-based backdoors: the most experienced chip manufacturers like Intel can't totally vet their chip designs or firmware; the problem only becomes compounded when you have potentially gigabytes of interacting open-source code on your machine.


Proprietary code is definitely worse, I agree with you here. But the *insider threat* applies as much to the open and free source software community as it does to the corporate software world.


Having a low learning curve and a transparent user interface makes it more secure, not less secure.


Two points you gloss over:
1. Windows security bug fixes have a much lower turn-around time, on average after the initial report, than do Linux security fixes. Yeah I know this goes against everything you were taught in hacker daycare, it's sad but true. Often times the open-source community will take weeks or even months to patch vulnerabilities.
2. Security by obscurity really has its benefits. As a professional security researcher let me say I am not endorsing it as a viable tehchnique... however even cryptosystems depend on segregation of information in order to remain secure. The trick is that information-hiding introduces a delay in the attacker's efforts. 
[I'm not saying Windows is better, I'm saying nothing is secure](
@_date: 2013-10-31 15:11:46
They should really just start offering t-shirts for large donations. I'd donate 50 bucks instead of my usual 20.
@_date: 2013-08-10 11:28:24
Lol you're fooling yourself if you think backdoors don't exist just because it's open source. You think every line of code is vetted by the community just because it's out there? Think again.
And even if every single line of code was reviewed, program obfuscation is damn easy to do and the result is you can slip a backdoor in where automated static or even dynamic analysis tools have very close to **zero** probability of finding it.
@_date: 2013-08-11 21:50:27
I was agreeing with your point, dude...
How are you calling me naive? I pulled that estimate out of my ass, and it looks like I came pretty close to the "normal rig" you described! A factor of 3.5?
And by my second machine the 64-bit case would only take about 5 minutes, not 3 hours.
@_date: 2013-08-10 16:15:41
Isn't there a reduction for that?
@_date: 2013-08-10 23:58:57
Not completely, but my point is that being "proprietary" is one thing and has its pros/cons.
The way Linux is developed (less money, more openness, etc) also has its pros and cons, and it's important to make the distinction of what benefits we actually gain instead of just saying "oh FOSS is da best cause transparency no one can put secrets in da kernal".
His characterization of the advantages of Linux and other OSS was inaccurate, and I was pointing that out. I can hunt down some literature on it if you want, but suffice it to say that the insider threat applies just as much to open-source projects as it does to proprietary projects.
@_date: 2013-08-10 23:22:32
Obfuscated does not mean "not readable" in and of itself, except purely by definition. The way I'm using it here means to obfuscate the true intention of the code, so anyone looking at it thinks it's doing something benign. The benign operations look totally normal and non-obfuscated, and could indeed be serving some great purpose; but taken in the context of other code, sparse operations might be doing something that is not apparent from the perspective of someone reading the code like one would read a novel, that is, imperatively and taking the story of the code at face-value.
@_date: 2013-08-31 07:48:36
And after taxes it's probably closer to 25k
@_date: 2013-08-11 22:32:14
I was expressing lower and upper limits, which seems to have eluded you. Come off it brah.
@_date: 2013-08-11 21:00:38
Let's say you can check a 100 billion values per second.
That leaves you with on the order of 100 million seconds, or 1157 days (only 3 years) to brute force a 64-bit space.
The theoretical peak performance of the world's fastest supercomputer is 50 quadrillion floating point operations (thousand TFlops) per second. 
Assuming (conservatively) each of these operations checks one value, you're looking at about the same amount of time for this supercomputer to brute force an 80-bit space as the "normal rig" would take to brute force 64-bits.
@_date: 2013-08-11 00:56:17
that's simply not true. users of proprietary software benefit from increased funding for secure in development, there is a greater economic incentive to maintain security in proprietary code, and there are also some (if limited) advantages to security through obscurity.