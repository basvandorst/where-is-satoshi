@_author: kallerosenbaum
@_date: 2016-08-30 17:43:40
I'm seeking technical feedback on this blog post. I'd appreciate any corrections or suggestions, just let me know. Thanks.
@_date: 2016-08-31 11:22:15
Thank you for your input!


You definately need to prove possession of the locked funds, otherwise anyone can create the receiving transaction. Or am I wrong here? In the post I suggested using [BIP120]( (Proof of Payment) for this purpose. That would require a bigger nonce than the specified 6 bytes. The nonce could be taken from the tx hash (excl signatures) of the receiving tx. 
Another way would be to generate a public-private keypair and publish the public key in the sending transaction. Then you can prove possession in the receiving transaction by signing the transaction hash with the private key.


I'm not sure I understand your suggestion here.
@_date: 2016-08-31 13:29:00


I get it, thanks. But this would require something like covenants as well.


@_date: 2015-12-22 13:20:25
@_date: 2015-12-18 15:50:49
I hope my blog series on IBLT can help. Part 1 is featuring a nice infographic. Implementation is not integrated into bitcoin core, but there is an experimental c++ implementation by Rusty Russell ( and my own java implementation ( 
@_date: 2015-12-22 13:17:50
Thanks. Clarified it in blog.
@_date: 2014-10-21 09:50:34
Thanks. I'll drink it tonight at the Bitcoin meetup! 
@_date: 2014-10-21 09:19:40
Thanks! And thank you for the tip! 
@_date: 2014-11-24 18:26:51
I have done some statistical tests on encoding/decoding blocks in IBLT. Apart from my previous tests that tries to find reasonable values for valueSize and hashFunctionCount, I have also done tests that plots cellCount vs failure probability and diffCount vs failure probability. Please have a look at 
1. 64 bytes looks like a good valueSize
2. Space savings seems to increase as diffCount increases. This is of course based on the assumptions explained in the wiki.
3. k=3 seems to be the best hashFunctionCount no matter how you look at it.
@_date: 2014-10-20 19:47:27
@_date: 2015-05-05 16:59:47
Thank you. Yes that's a PoP enabled version of Mycelium. The QR is the PoP request and mycelium creates a PoP from the original transaction and signs it just as if it was an ordinary transaction.
Nice name suggestions. I was thinking something similar: POO, Proof of Ownership, but that would be considered inappropriate by some, I guess. 
@_date: 2015-05-07 19:10:15
I agree that there are similarities, but there is a fundamental difference:
Proof of Payment is a proof that you have all the credentials needed for a certain transaction. It is centered around a transaction. 
BitID is a bit different, it let's you sign a server generated challenge with a key, corresponging to a certain address, and send it to the server for validation. It is centered around a bitcoin address.
These two serves different purposes. BitID is useful for creating accounts and using the address as the "username". It is an authentication system. Proof of Payment is more like a "hey, I paid for this service, now give it to me!" system. It can be used as authentication just as in BitID, but it cannot be used without prior payments so it's not very useful for free sites, unless the "free" site takes a tiny payment just to use PoP.
@_date: 2015-05-05 14:43:48
As I understand BIP70, the Payment ACK is not signed. The only message that is signed by the merchant is the PaymentDetails of the PaymentRequest. That PaymentRequest together with the transactions from the blockchain makes a kind of proof of payment. Accepting this as a proof of payment on a paysite login would impose a security risk, because if the PaymentRequest is stolen, the attacker can use it as many times he/she wants to. Since the PaymentRequest is created by the merchant and sent over a network, I have no control over the security of that PaymentRequest. The PaymentRequest is useful for dispute resolution and bookkeeping.
Instead I propose a system where the proofs are created by the wallet, on demand. The proofs are usable only once, because of the nonce in the PoP.
@_date: 2015-05-05 18:15:33
Because that's a different thing. The paysite scenario I mentioned is "pay once and login with proofs after that". The proof itself is not a payment, it's just a transaction-like datastructure sent from the wallet to the paysite. It never (should) touch the bitcoin network. Please read the specification linked to in my first reply.
@_date: 2015-05-08 20:26:12
Congratulations! You are the lucky winner of the 50 mBTC! I like your suggestion "Popo" best. But I think I'll stick to "Proof of Payment" for now. Thank you for your suggestions. @_date: 2015-05-05 04:17:10
Regarding multisig, any N of M signatures are ok. It does not have to be the same set of signatures that originally made the payment. I don't know about coinjoin, I barely know how that works. I'll look into it.
Check [my wiki]( for the specification, if you haven't already.
You're right that one should not define who does what if it's not needed. I'll think about that.
@_date: 2015-05-05 04:00:42
Have a look at the draft specification at [my wiki]( In the use cases section I talk about the payment protocol, bip70. The problem is that bip70 payment requests are reusable, imposing a security risk.
@_date: 2016-01-19 19:05:02
Yes, that would probably help, but doing it for strong blocks would make the system as a whole worse because the unlucky users would have to wait for the next block for confirmation. The end result may be that miners chose to only include transactions that they think are well propagated, for example by excluding the last 30 sec. 
@_date: 2015-05-07 17:57:53
Yes, I recommend you read it to avoid confusion. The main properties of proof of payment is:
* One time proofs. Every PoP uses a server generated nonce. This protects from someone stealing a PoP and using it over and over.
* It reuses the transaction datastructure to simplify signing/verification.
* All the credentials of the original payment are needed to sign a PoP.
* Supports multisig and any other P2SH inputs. This is thanks to the reuse of the transaction datastructure.
@_date: 2016-01-19 20:30:47
Thanks a lot for writing these summaries! Have a donut @_date: 2016-01-19 18:33:16
Regarding iblt, right now little to nothing is being done, unfortunately. Hopefully that'll change.
@_date: 2016-01-19 20:48:39
My last reply was just a complicated way of saying "yes", and reiterating what you just said. Sorry for the confusion. I don't think there's a difference at all. Or did you mean something else?
@_date: 2017-03-06 19:44:59
Thanks for the informative answer!


Ok, so that's why electrum will produce the same signature every time I use the same message, but
    echo hello | openssl dgst -sha256 -binary | openssl dgst -sha256 -sign privkey.pem -hex
will produce different signatures every time. Thanks! It's amazing how little you know when you start to scratch the surface.


You're kind of implying that 2 and 3 can only be caused by implementation errors (bugs) and not by specification errors? Do I understand you correctly? Are 2 and 3 mathematically proven to be secure?
@_date: 2016-01-19 18:29:49
I'm not saying they won't use it, I'm just saying they may not have incentives to propagate their own weak blocks. If they find a strong block and there's a weak block they can use, it's of course a no-brainer.
@_date: 2019-11-17 19:07:57
Welcome to the rabbit hole my friend!
@_date: 2019-11-16 08:06:38
You're welcome!
@_date: 2019-11-16 08:04:18
By reading Grokking Bitcoin! I learn best by drawing pictures. That's shows throughout the whole book.
@_date: 2017-08-25 18:19:14
A refinement of the method above is (N is the required number of confirmations):
1. Sender prepares a transaction paying herself
2. Sender mines secretly on the honest best chain tip until she gets a lucky streak of N+1-k (not revealed) blocks in a row, while the honest miners get none. Her double spend tx is in any of those blocks.
3. Sender places order, gets an address from receiver, and broadcast a transaction paying to the receiver's address.
4. The honest transaction gets N confirmations on the honest chain, during which time the sender produces k more blocks secretly.
5. Receiver accepts the payment and deliver the goods.
6. Sender broadcasts her lucky streak containing the double spend tx which has more work than the honest chain.
So if sender has 25% hashpower and N=6, she needs to premine 5 blocks before sending the transaction and be pretty sure to succeed. This is because the sender will *probably* be able to produce 2 blocks during the time it takes the honest miners to produce 6 blocks. N+1-k=6+1-2=5.
@_date: 2017-08-24 21:17:00
Ok, Thanks man. I'm gonna parse this when I'm less drunk. 
@_date: 2017-01-22 17:28:53
Hmm, it might be a good idea to NOT touch the stash in the cold wallet. It's not stolen yet so they're probably not stealable, but they might be if his computer is compromised and he starts sending his funds. 
I'd suggest that he first understands what happened, before doing anything with the funds.
@_date: 2017-08-25 08:21:48


I don't see this. Bob still only has one try, right? I don't see how the invoice validity has anything to do with the probability of success.


So let's talk about feasibility then. Peter Todd has made some calculations on selfish mining ( If you already have incentives for selfish mining, why not make some double spends at the same time using the method I described? You get to double spend "for free". Or maybe double spending is incentive enough to do selfish mining. Maybe can chime in here?
@_date: 2019-04-20 07:13:26
Thank you! I hope you'll like it.
@_date: 2019-04-20 08:34:00
Thank you!
@_date: 2016-09-29 07:28:22
Your point is fair. One should rather say "as long as Ken and Barbie protects their interests, it's atomic."
@_date: 2016-09-15 12:54:35
Please let me know if you find any errors/misunderstandings in the blog post. 
@_date: 2016-09-30 09:23:32
No. If only Barbie would sign her refund transaction, then her contract output would have to require ((ONLY barbie's signature) OR (Ken's signature + a)). If that's the case, she could create a refund transaction and publish it at ANY time, ie she doesn't have to wait 48 hours.
@_date: 2016-09-29 08:50:48
Thanks for your comments. I've added a note about this in the blog post. I also added sections on transaction malleability, which also "breaks atomicity",
@_date: 2016-09-15 21:09:57
Thanks, I saw that. Got pinged on twitter. Haven't read it thoroughly yet though. But it seems to rely on interactivity at times which is not appropriate for sidechains. But I need to understand the paper better before I ditch it or update my blog.
@_date: 2016-09-29 12:38:49
Yes, there is. Fixed now. Thank you for pointing it out!
@_date: 2016-09-30 10:20:58
Then there's also OP_CHECKLOCKTIMEVERIFY, which would simplify this process. No refund transactions would have to be created, except if/when it's actually needed. The contract output would use OP_CHECKLOCKTIMEVERIFY to verify that the refund transaction has a lock time of 48 hours. Thus, the refund transaction would not need a signature from the other party. Much simpler. I'll write a post about it next week. It also fixes the malleability problems described in the blog post.
Note: I didn't come up with this idea. It's old. This specific use case is described in s 
@_date: 2016-09-29 04:58:35
If Ken doesn't take his tokens within 48 hours he might lose them, because Barbie can now take it if she wants. She will just sign her refund transaction and publish it. Remember that Ken signed her 48 h locked refund transaction in step 3.
@_date: 2016-09-30 10:00:29
Thanks for finding the typo. That's the second error in my pictures of that post. I need to get rid of my lousy proofreader.... Oh wait! That's me!
@_date: 2016-09-29 05:14:32
Or, maybe I misunderstood your misunderstanding. What you say seems correct.
@_date: 2016-09-29 08:03:22
Yes. That's because Ken didn't protect his interests and got killed. But as you pointed out, it's not strictly "atomic".
@_date: 2015-11-18 15:32:04
Yes, I don't have a way around that. It is a privacy concern that I'd like to see addressed. Have you any thoughts on this?
@_date: 2016-10-13 14:26:32
Thanks! I thought the inputs looked unusually large.... That's why then.
@_date: 2016-10-24 13:15:43


Yup. Agree, but the factor is there.
@_date: 2016-10-24 11:54:47


Yes they certainly would notice. Hence the section:
"When it becomes apparent that money has been stolen, the money that were still on the sidechain would quickly be withdrawn back to the main chain by everyone, and the unfortunate last people doing it would fail because there are no SPV-locked outputs left on the main chain to claim. They would probably not be socially powerful enough to enforce a hardfork to get their coins back. The end result is that the main chain is technically unaffected, and nobody will trust the sidechain, which will die, leaving the unfortunate ones ruined."
@_date: 2016-10-13 13:17:50
I'm curious about the blockchain published version in tx b4bf94f5c457d080924aa163106d423670373cfe3b10f8ec00742c2234b01b72:
    "vout": [
    {
      "value": 0.00000000,
      "n": 0,
      "scriptPubKey": {
        "asm": "OP_RETURN",
        "hex": "6a",
        "type": "nulldata"
      }
    }
    ]
There's nothing there, just the opcode. What's wrong?
@_date: 2015-10-12 12:38:57
Rusty Russell has measured the differences between mempools: 
The stats covers about a week of blocks. I did a simulation of all the blocks coming into the Australian node. The result is that an IBLT of size about 22kB would be enough to decode 95% of the blocks. I will get back to this in a later blog post.
This did not answer your exact question, but it might give you an idea of what the size might be in today's network.
@_date: 2015-11-17 07:33:23
Sure, you can forward the pop request to someone else. The other person does not have to send the pop back to you. She can just send it to the pop destination directly. The destination is part of the pop request.
@_date: 2017-05-26 20:13:49
@_date: 2015-11-09 16:09:09
Ok, I'll try an ELI5:
IBLT is a data structure used to encode bitcoin blocks. Its main feature is that it's fixed size. You put all the transactions in a block into the IBLT (which remains the same size, eg 21600 bytes), The transactions are overlayed on top of each other in the IBLT. Then the IBLT is transferred to another peer P. P will then guess what transactions are in the block and remove all the guesses from the IBLT. What's left in the IBLT are the guesses that were wrong (identified by a minus sign) and the transactions that P didn't guess (identified by a plus sign). This will only work if the IBLT is big enough to hold all the bad guesses. If we use an IBLT of size 21600 bytes we can transfer about 95% of all blocks in today's network. For details on how the IBLT works check out my infographic on the subject: 
@_date: 2015-10-12 15:09:19
In the context of IBLTs, the block creator will have to use a bigger IBLT in order to transmit the added differences. The more differences between the sender and receiver, the bigger the IBLT.
"What happens if (theoretically) a mining pool did not relay transactions coming from a competing mining pool?": All other of the ~6000 nodes will probably relay the transaction.