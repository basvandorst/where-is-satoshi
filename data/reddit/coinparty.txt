@_author: coinparty
@_date: 2015-10-14 09:28:57
I’m the author of the discussed paper and would like to clarify the raised points and questions.
**I’ll start with CoinParty’s transaction pattern.**
* If we have *n* users in the mixing, they will each in an individual transaction, referred to as commitment, transfer the required mixing amount *v* to an individual escrow address, denoted *T_i* in the paper.
Note that these commitments can have any number of inputs and outputs, as long as at least *v* Bitcoin are transferred to the escrow address (which is only known to the user and the mix peers).
* After all commitments are received, the escrowed funds are transferred to the users’ shuffled output addresses, again in one individual transaction per user.
To sum this up in a crude diagram, what we end up with is the following transaction pattern:
    TX_1: I_1 —&gt; T_1 —&gt; O_pi(1)
    TX_2: I_2 —&gt; T_2 —&gt; O_pi(2)
                    ...
    TX_n: I_n —&gt; T_n —&gt; O_pi(n)
Here, *I_i* are the users’ input adresses, *T_i* the individual escrow addresses and *O_pi(i)* the shuffled output addresses, where *pi* is a permutation that is not known to anyone, not even the mix peers.
**Moving on to CoinParty’s security model &amp; guarantees**
The commitments are just standard Bitcoin transactions, there’s nothing to discuss here.
The private key corresponding to the escrow addresses, however, is shared among the mix peers using a Secret Sharing Scheme.
This essentially means that mix peers have to collaborate to do anything with these private keys.
And indeed, the transactions of the second phase (T_i —&gt; O_pi(i)) are signed using a threshold signature scheme that is collaboratively carried out by the mix peers.
Now, regarding these threshold transactions there are two important questions
* *Security*: How many malicious mix peers need to collaborate to produce a valid signature in order to steal funds from the escrow addresses?
* *Robustness*: How many malicious mix peers need to collaborate to stop the honest peers from successfully completing the protocol and thereby get funds stuck in the escrow addresses?
Diving deeper in to the underlying theoretic basis of secure multiparty computation (for the interested, I recommend [0]), one realizes quickly that the two properties, *security* and *robustness*, are caught in a tradeoff. I won’t go further into this here, but will only give you the hard numbers.
CoinParty strikes a balance that tolerates 1/3 of the *m* mix peers to be malicious, in particular this means
* **&gt;= m/3 malicious mix peers can steal** funds but they all need to collaborate to do so.
* **&gt;= m/3 malicious mix peers can stop** the protocol without coordinated collaboration after the commitments were received, such that funds get stuck.
* Note that the first point implies that we can tolerate &lt; 2/3 of the mix peers to fail randomly, i.e., without actively interfering with the protocol afterwards.
Increasing the threshold in one direction, e.g., providing security against more malicious peers, will always decrease the threshold in the other direction, e.g., it will take less malicious peers to cause the protocol to stop and funds get stuck.
Since, we weigh both consequences, funds getting stolen and funds getting stuck, equally, the 1/3-threshold is the best we can do in our approach.
This is confirmed by well-established feasibility results in the domain of secure multiparty computation (cf. [0] §2.1)
On a side note, the threshold becomes more favorable, i.e. m/2, if you assume a semi-honest attacker, i.e., an attacker how adheres to the protocol and does not actively try to sabotage it. However, we really think that the semi-honest adversary model is too weak in the context of Bitcoin, where attackers have monetary incentives to cheat the protocol in every way they can.
**Source code**
We have implemented a prototype of CoinParty as proposed in [1] based on the VIFF framework [2]. As we realized later, VIFF is not really secure against malicious adversaries on an implementation level. Note that this is independent of the concept and protocols we propose in [1].
However, we scrapped the VIFF-based and set out to reimplement CoinParty more rigorously. Along the way, we also made some protocol-level improvements that will be published soon. We're planning to release the source code when this is finished. 
At this point, a short disclaimer is probably appropriate: Being a research institute, we are not aiming for production-grade code, nor do we have the skills or resources to do so.
[0] Lindell, Yehuda, and Benny Pinkas. "Secure multiparty computation for privacy-preserving data mining." Journal of Privacy and Confidentiality 1.1 (2009): 5.
[1] Ziegeldorf, Jan Henrik, et al. "CoinParty: Secure Multi-Party Mixing of Bitcoins." Proceedings of the 5th ACM Conference on Data and Application Security and Privacy. ACM, 2015.
[2] VIFF, the Virtual Ideal Functionality Framework. URL: 