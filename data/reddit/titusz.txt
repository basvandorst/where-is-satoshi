@_author: titusz
@_date: 2018-09-13 17:58:08
If you iterate  through each block using getblock with verbosity 2 than those responses should already include transaction details in the same format as you would get them with the getrawtransaction RPC. If you index/cache those transactions efficiently at block parsing time you can avoid the overhead for any further getrawtransaction RPC calls.
@_date: 2018-08-09 17:36:05
The number of confirmations equals to the number of blocks built on top of the block that includes your transaction.
With bitcoin it is possible to construct two conflicting transactions. For example one transaction spends a specific unspent amount to one address and a second transaction spends the same unspent amount to another address. The famous double spend.
Nothing stops you from sending out both conflicting transactions to the bitcoin network. Some nodes may see transaction A first and deem it valid, others may see transaction B first and deem that valid. Nodes may even first see A and dismiss it after receiving B (maybe it offers more fees).
As long as these transactions are not mined into a block, both of them are valid but only one of them can make it into a block.
There is no global mempool state (pending transactions) on the network. Each node builds its own mempool depending on the individual transactions as they come in. Different miners mine on different blocks build from their own individual mempool states. One miner might include your TX A in his block that he is working on, the other might include your TX B.
It is even possible that 2 miners find a solution to the next block at roughly the same time. Both blocks are valid but still conflicting. One includes your TX A the other your TX B. There is now a fork or split situation. One part of the network mines based on BLOCK A, the other part of the network on BLOCK B. Whichever branch produces the next block first wins the race. Actually the branch with the most proof of work wins.
So even if your transaction has 1 confirmation it could still be reverted if suddenly an alternative fork with more work shows up on the network. The deeper your transaction is buried in the blockchain the less likely is it that it can be reverted by an alternate fork.
@_date: 2017-03-09 17:48:20
The fees are implicit in the transaction. Every transaction removes one or more unspent outputs (no partial removal possible) and creates one or more new unspent outputs of a total amount up the the sum of outputs it removes. The remaining amount that is not spent to any new output is the implicit transaction-fee.
@_date: 2018-07-14 21:04:59
This looks more fresh:
