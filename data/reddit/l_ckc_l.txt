@_author: l_ckc_l
@_date: 2017-12-01 15:42:35
No, that is not accurate. It was not treated as a brainwallet. The user was scanning a QR code containing "bitcoinMyAddress" with the colon missing. Then, the wallet was assuming that was a base58 private key and importing the corresponding address to that key. It had nothing to do with brain wallets.
Actually, there is no way to import brain-wallets at bci and as far as I know that feature never has been there. The only execution path that could lead to using a sha256 while importing is when you import a mini-key but while scanning an address you cannot reach that branch for several reasons. First, because if you satisfy the address check you will not go to the minikey branch and in case you fall in the minikey branch you should satisfy that sha256(address + '?')[0] == 0x00. And the address with that problem does not satisfy that condition.
On the other side, if you go to bitaddress (as the user reported to have been using) and you click brain-wallet and paste your address there and you scan that QR code.. bam, you have your address imported. Also, the fact that this seems to be the only case... suggests me that is probably a human mistake.
@_date: 2017-12-03 01:00:14
@_date: 2017-03-21 01:03:21
Well, I don't think this partial error correction makes any sense. If you start correcting a word and you find that there are 2 errors and you only decide to correct 1 the rest of the detection does not make any sense. Because maybe you had 6 errors (you did not know that) and with your guess (you find only 2), you have just introduced lots of errors and now you want to start detection?
I see your point but I don't think correction is ever used that way. 
@_date: 2017-03-21 00:02:55
This statement is a little bit inaccurate:
"One of the properties of these BCH codes is that they can be used for error correction. An unfortunate side effect of error correction is that it erodes error detection: correction changes invalid inputs into valid inputs, but if more than a few errors were made then the valid input may not be the correct input. Use of an incorrect but valid input can cause funds to be lost irrecoverably. Because of this, implementations SHOULD NOT implement correction beyond potentially suggesting to the user where in the string an error might be found, without suggesting the correction to make."
Error correction does not erode error detection. The first thing you do when you receive a codeword is compute its syndrome and if it is not 0 you know there is at least one error. That's it. Of course, if you apply the correction algorithm, you will end up with a codeword (i.e a valid address) and you will not be able to detect errors after that. But you already knew there were errors at first. And of course, you only have chosen the closest address to the received word and there is no guarantee that this is the intended address.
But, the same could be applied to only error detection. If you introduce enough errors you might end up with another correct codeword and losing funds in the same way.
I would say that for this use case it is really important that the typed address is the intended one more than correcting errors on the fly. This is not video streaming. So it's is better to just detect and force the user to type again than just trying to guess what the user is typing.
In any case, thanks for you job
@_date: 2017-03-21 02:24:09
did you know that database of codes?
@_date: 2017-03-21 00:23:20
Vexy exsy, it ix axl aboxt redxndaxcy.
Actually, designing a good correcting code is about packing spheres. Imagine that your valid words are the centres of these spheres and all the other points are the invalid words. So, when you receive a word if it is not a centre of a sphere you know there are errors and if you want to correct it, the most likely sent word would be the closed sphere centre.
Since perfectly packing a space with spheres it is not always possible, sometimes you cannot chose the closest centre. By the way, codes that fill all the space, are called perfect codes  and there are not so many of them. 
@_date: 2017-03-21 01:49:33
very interesting point
@_date: 2017-03-21 01:39:34
ok, by the way, why did you choose a BCH code?
@_date: 2017-03-21 01:22:31
I think I expressed it really bad. The example you proposed. There were 3 errors. And you told me to assume that I correct one, even the syndrome showed a 2 error correction word. (resulting with a new wrong codeword). Where I can still detect 2 errors (I think this 2-detection here is non-sense, actually, now there is only 1 error, because of your initial guess-correction you are moving towards the wrong codeword). So, what do you do now?, you keep your wrong word or you force a guess most likely introducing more errors? This is what I meant by partial correction.
At the moment you start correcting (changing) your received word, you started you guessing lottery and detection does not make any sense from now on.
Anyway, nice talk. Thanks
@_date: 2017-03-21 01:59:47
I completely agree that we should not use error correction for the catastrophic reasons you already exposed. Even I understand why you say it halves the number of errors that can happen before the catastrophe.. I don't think this "halving" is accurate.
I would not compare detection performance against correction performance. They are two different things. Actually, if you do that comparison, using correction it is worst than halving.
Because if you only use detection you will be able to detect 1,2,3,4 errors, but also some 6,7,8... errors. Anytime, you don't have a valid address you will detect it, even if there have more than 4 errors. And if you use correction you will only be safe when 1 or 2 errors are made. Any other scenario will lead you to a wrong address. Guessing is riskier that just realizing that something is going wrong :)
@_date: 2017-03-21 02:10:04
Amazing, very nice research, and this is only for address encoding :) I don't think most people on the community can appreciate the work you are doing guys.
@_date: 2017-03-21 00:39:12
I suspect you are mixing correcting erasures with error detection.
A code of minimum distance d can detect d-1 errors. Full stop. This has nothing to do with correction. Actually, you don't correct x error and detect y errors. With block codes, you apply correction or not, and after applying correction you have a codeword.
The equation you pasted (s + 2*t  &lt; d ) describes how many errors and erasures a code can handle. An error is a problem that you don't know its position and an erasure is an error that you know its position. So, in your code with minimum distance 5, you can:
* detect 4 errors
* correct 2 errors and 0 erasures
* correct 1 error and 2 erasures
* correct 0 errors and 4 erasures
The problem with using error correction is that no matter what the user type, he will always end up with a valid address. If you only detect errors you cannot introduce errors during correction (bad guessing) and it is less likely the user end up with a wrong valid address (only if he does 5 errors or more).
@_date: 2017-03-21 08:57:43
I would not say technical debt here. It would be like saying that using computers to run programs about Bitcoin is technical debt because there are lots of things that not everybody may understand behind the scenes of running a program.
Technical debt would be if these guys designed a shitty homemade error-correcting code just to solve his problem without doing this deep research.
And, as it is pointed here, the implementation is specially simple. You don't need to understand all the algebraic structure behind the scenes of the code to run/copy a implementation of 5 lines.
So, I don't buy this argument of not using more powerful ideas to avoid intimidating some programmers.
@_date: 2017-01-27 14:13:26
Yes, from this list of 17 people there were maybe 4 guys writing code and recently arrived.
@_date: 2017-01-31 16:01:02
Lottery is seen as a hard mathematical problem these days.
@_date: 2017-08-05 00:37:37
This is correct and I already found how to find the private key where he sent the money. I sent a private message to him in order to help him. But I would not say this is a bug... Actually, when you understand what is going on, it is because of another "feature" :D
@_date: 2017-01-27 11:36:32
When blockchain.info had these problems, it was a single man company (if not almost). Nowadays it is pretty different.
@_date: 2017-08-05 01:05:10
It would be enough if these 3 addresses where the ones he used. But thankfully are not. I already checked it. 
@_date: 2017-08-05 00:58:33
The invalid address is generated from a private key. This private key is generated from the wrong input. So they are not gone. If we know the original wrong input we can reproduce the process, generate the same bad private key which leads to the address where he sent the money. I already reproduced that process for myself
@_date: 2017-08-05 00:42:58
The user should have the information to recover the funds himself
@_date: 2017-08-04 22:08:58
There is definitely a sequence of bad things here. Probably coinbase generating a wrong code and probably blockchain.info not warning you after a failure of scan. But the lesson you can take for yourself is always double-check where are you sending your money before clicking send.
@_date: 2017-08-04 21:43:31
You are an artist till the point that you record vertically with your phone.
@_date: 2017-08-05 01:24:29
When you scan a QR code it can be a QR code containing a private key then you pay to the corresponding address to that private key and the wrongly generated QR code by coinbase is a valid base58 string which can be understood as a valid private key
@_date: 2017-08-04 22:37:47
you are right
@_date: 2017-08-05 00:50:38
No need to investigate more, in blockchain.info you can scan a private key to send the money there and the malformed QR code it is unfortunately a valid base58 string which might be understood also as a private key. The question is if they should have this "feature" or not. But, if you want that feature there is no way to solve that with validation.
@_date: 2017-08-04 22:00:57
@_date: 2017-08-04 21:57:42
was the form pre filled?
@_date: 2017-08-05 00:46:22
He is not answering (maybe he is sleeping). All he need to recover his funds is the address he was intending to send the money. Maybe he does not know it.
@_date: 2017-08-04 21:51:54
Actually, I scanned myself the QR code that you present on your video and the information that it contains is wrong. The message contained is "bitcoin1...." There is a colon missing between the address and the bitcoin word. So, the first bug is whoever who generated that QR code, they did it wrong. Now the question is where is it coming from the address that blockchain.info wallet showed you on case of scan failure. Luckily it will be from your wallet
@_date: 2017-11-30 22:12:18
This is not a generated address. This is an IMPORTED address. I guess you don't want randomized imported addresses ;). Actually, bci wallet is mostly an HD wallet. There is no way in the interface to randomly generate a new address/key. The only reason this single addresses feature still exists is because people used them in the past. But you cannot create new ones, only import.
About the bots, there is people running all class of sweeps for brainwallets or things like that. I am sure that after this, there will be even more people running more for this special case.
@_date: 2017-05-03 17:18:40
protonmail, such drama queens
@_date: 2017-06-21 08:26:26
I think people that does not understand that will not know what a "fraction" means.