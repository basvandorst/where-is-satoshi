@_author: mastercactapus
@_date: 2016-08-21 16:01:35
You're right, few things are as complex as they seem at first, but as a maintainer if you support a platform, you need to fill the gap for the end-user. And to many end users, it might as well *be* rocket science. (i.e. they have no more idea of the underlying tech as they have of that field)
Clicking an Install button in the web store, has a lower barrier of entry than:
- installing gtk, qt, or wx widgets
- installing/configuring python (and does /usr/bin/python point to 2 or 3 -- thanks npm)
- managing multiple packages, getting them in distro repos, etc
If someone doesn't NEED to know something, some people prefer not to (or get overwhelmed and give up). Unfortunately that's one of those "that's just reality" things that needs to be accepted by those that create and maintain apps.
The python/libusb solution solves a lot, but still has a dependency on library versions &amp; packages and won't work on Chromebooks (meaning 2 sets of code, unless you use something to compile into javascript). Though thats why things like AppImage, snap-packages, and flatpak were created, because distribution is a very real issue.
You also have to consider, if you're going to support windows and OSX, you need to do the research into the libraries/syscalls/etc of that platform (e.g. libusb equiv.) and support compiling against/shimming those different libs. As well as guiding end-users in how to install them. Many devs (open source especially) don't have that kind of time (or interest), so they usually just support whatever platform they happen to be on.
That said, I do have to agree with you on your main point: building it isn't *that* hard; then again I have a lot of domain knowledge. But the end-user isn't always a builder. And other contributors may not have a mac, or linux, or windows. And for end-users, when you have to define the words like "dependency", "toolkit", "library", there's a lot they need to learn to know what's happening, stuff we take for granted.
All that said, the reality is: assuming they don't reverse the decision, we just have a problem to solve. 
The easy solution is to make something cross-platform, but drop chromebooks (why I wondered if that was the intention). The alternative may be to abstract the chrome APIs so you can build FOR a chromebook without changing your code, but then you need something that can compile into javascript.
Anyway, the latter is my approach for my current project, given these developments: build it in Go so I can compile for all the platforms (and gopherjs for chromebooks/javascript) and have a library that adapts the chrome APIs (when built with gopherjs) to minimize the amount of platform-specific code. At least then distribution is a single binary, or a button in the web store. Luckily, most (if not all) of the prospective user base are *builders* anyway.
@_date: 2016-08-20 14:09:41
Think of it this way: you get Linux, Mac, Windows, and chromeOS with one set of code, no shims for different platforms, even launcher icons for each. 
More importantly in this case (and my own), Chrome takes care of the usb and serial device code and permissions for the different platforms too. Listing devices, connecting to them, etc.. has one API that just works.
Couple that with solving distribution (web store) and it actually made a lot of sense, especially for things that need usb or raw socket connectivity (things that will probably not have a standard web-API in the near future)
Outside of a platform like that, you need to research and test making syscalls on windows, mac, linux, and if you want chromeOS using that API anyway. Bug fixes, buying hardware (even testing aside, you can't really cross-compile for mac without one) Then you need to solve packaging/installing for windows, mac, multiple linux distros (at least .deb and .rpm) AND the chrome web store. That includes actually bundling it, adding an installer, how to create a launcher on the separate platforms. Don't forget how the users get updates is different per-platform too.
Up until now, if you published to the chrome web store, you got all of that for the cost of developing a chrome app. The majority of them are just standard web-apps, and that's fine. But stuff like bitcoin apps, or CNC stuff, etc.. use APIs for things like USB that the browser probably isn't going to give access to on the open web.
A small percentage of people/apps are affected (i.e. can't just make it a normal web-app), but there's really no good alternative currently for those that can't. No matter how you look at it, at the very least, you need to support 2 platforms minimum if you still want to support chromebooks. Who knows, maybe that's the intention.