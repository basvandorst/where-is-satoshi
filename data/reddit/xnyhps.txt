@_author: xnyhps
@_date: 2014-09-12 09:05:07
Bl3p appears to still be in closed-beta.
@_date: 2016-01-07 12:29:27
Heh, thanks for the 1.337 mBTC! I'll back off and follow the rules now. :)
@_date: 2016-01-13 18:43:38
Gah, I got to the list of symbols and I suspected it might have been an existing alphabet, but didn't know what to google for (image search for "alternative alphabet" didn't work).
@_date: 2016-01-07 15:14:24
I found "STATS" which was wrong, so I was missing one S too.
@_date: 2016-01-07 14:53:20
Decoding the [transaction that just happened from the first p2sh address]( gives "christiaan huygens".
@_date: 2016-01-07 20:38:51
I was a bit ~~bored~~ impatient 2 hours before it started. First, I was wondering if I could brute-force the answer from the p2sh address, but I didn't really understand how those work (which is also why I missed that Bitonic still holds a private key needed to spend those outputs). Then I noticed the JavaScript file to submit answers was already included, so I found the URL where attempts are submitted. I tried to submit and found that the server was already answering. I made about 5 guesses that were wrong and gave up, I figured they'd quickly notice if I tried to brute-force that. Couple of minutes later I received a transaction for 1.337 mBTC on the address I had used, probably as a "we see what you did there" note. :)
@_date: 2013-12-17 14:20:14
Some more comments:
* The choice to encode every character as a separate polynomial looks odd to me. If I were to implement it I would generate one polynomial for the entire private key. (I don't think this impacts security, unless you want to hide the secret's length.)
* Somewhat related, now you are doing:
     Secret key -&gt; Checksum -&gt; Base58 -&gt; Split
 This means you can't checksum the shares individually. Messing with a single share will still make the checksum fail, but you might want to add checksums for the shares themselves too. The base58 step before the split is also not necessary, so I would do:
     Secret key -&gt; Checksum -&gt; Split -&gt; Checksum -&gt; Base58
* Your password hashing is weak. [BIP 0038]( only allowed me 2 passwords per second per core. Now, on the same hardware, a not very well optimized implementation is trying 30k passwords per second per core. A good GPU implementation can probably do this an order of magnitude faster.
* Your splitting looks correct to me, meaning it is impossible to try to gain any information from the "2 out of 2" share.
@_date: 2013-02-22 19:00:37
Nice article, thank you for it. :)
Trusting other people is not essential for it, even if you keep all the shares yourself I think it's a much safer solution.
Suppose you generate 5 shares, of which any 4 can unlock your private key, and save one share on your PC at home, one on your phone, one somewhere online, one on a USB stick in a lockbox in a bank and one on a piece of paper at your office. Then any hacker would also need to physically break in to steal your coins. Any burglar would also only get 1 or 2 shares. On the other hand, if one of those buildings burns down, you can still access it yourself!
I think the algorithm even makes it possible to generate new shares (given enough of them to meet the threshold of course) without replacing all of them, but I don't see a way to do that with ssss.
@_date: 2013-02-23 00:19:21
I think this would fall under fountain codes, yeah. But with extra cryptographic guarantees that fountain codes do not require (I think from looking at their definition).
@_date: 2013-12-17 18:01:11


My scenario is this: suppose you store all your shares on CD-Rs/USB sticks/floppies and hide those in various places. You might want to occasionally test your shares to make sure they are not corrupted (any digital medium I've used has to deal with some corruption over time). It would be nice if you can test a single share for corruption without having to gather all the shares and try to reconstruct the private key (because the point is to avoid having the private key in once piece unless it's strictly necessary), but with your scheme that is not the case.
Of course, this depends on your actual usage. If you're going to etch them into metal plates which you store in fire-proof safes you'll probably not worry about this as much. :)
@_date: 2013-11-08 23:06:22
' ' to '~' (almost all of the printable ASCII characters) would have taken me ~19 hours with a pretty simple Python implementation. 2 unicode characters has a way larger keyspace than that, so I'm giving up.
@_date: 2013-05-12 13:02:11
Generating a private key by hand is pretty easy. A private key is just [any 256-bit number between 0x1 and 0xFFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFE BAAE DCE6 AF48 A03B BFD2 5E8C D036 4141]( So if you roll an 8-sided dice 86 times (a 16-sided dice would be even easier, but I've never seen any of those) and convert that from octal to hexadecimal ([this is pretty easy to do on paper]( you get a private key. (There is an upper bound, yes, but the chances of going over that are something like (1/8)^43 = 1/680564733841876926926749214863536422912.)
On the other hand, finding the public key that belongs to this private key is **not** doable by hand. I don't even think many graphing calculators will be able to multiply 256-bit numbers without losing precision. If you want to send coins to your address, you're going to have to trust a computer to calculate the public key for you. However, if you use an offline machine for that, you don't need worry about a paper-wallet generator generating predictable addresses.
@_date: 2013-12-17 10:14:20


We have the public key to compare it to, which means it only takes one EC operation and some hashing to compare.
Additionally, something that makes me a little uncomfortable: your keys are not uniformly distributed over 59^64. Some values occur with probability 5/256, others with 4/256.
@_date: 2013-03-03 23:21:29
See also  if you don't want to rely on a website to split and combine your secrets.
I think it's a great idea. I'm not (yet) deeply worried about physical theft of a single paper wallet compared to accidentally losing it, however, the more copies you make the easier you make it to get your bitcoins stolen. Splitting the secret key allows you to add redundancy while still being hard to steal.
@_date: 2013-11-11 11:23:58
Well, it's not code I'm very proud of. I focused on having an implementation quickly, instead of pretty code or even trying to optimize the code (my expectation was that the scrypt calls would slow it down so much that optimizing the rest would be a waste of time).
But here you go: 
@_date: 2013-05-13 15:15:39
Ah, yes. You're right. That has a 92% chance of requiring less than 86 rolls.
@_date: 2013-05-13 18:57:37
Maths student, can't help it. :P
@_date: 2013-12-17 17:01:21


Correctly implemented, it is information-theoretically impossible to find the polynomial given too few points. (You likely know this, but to explain this for everyone: you can't brute-force the shares you don't have. If you have too few of the shares, then the private key could still be *every* private key with equal probability. In other words, brute-forcing the private key given no shares is just as hard as brute-forcing given any number of shares less than the threshold.)
The only scenario where someone could break one of the polynomials is if your RNG is flawed in some way. But in that scenario I'd expect all your polynomials to be vulnerable.


Have a look at 


But I'm assuming the password is to keep thieves out, no? :)
And if you do that, then why not make it as hard as possible for them? With a hashing scheme like scrypt which has configurable difficulty, you can try to set it up such that brute-forcing the password would cost more $ in electricity costs then they could gain by breaking your password.
@_date: 2013-11-11 11:25:06
We have verified that if people on reddit are trying 3 ASCII characters, nobody will break a password of 3 Unicode characters.
Yeah, quite a waste of time.