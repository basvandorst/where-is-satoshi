@_author: ixan303
@_date: 2018-05-24 10:04:41
No, but even if a lot of clues are already validated for me, some are not and I think it's related to password.
@_date: 2018-05-24 06:21:12
No it's an extra step after that. You could do a lot more after seed+password to hide the wallet.
@_date: 2018-08-28 21:53:35
The principle : node exchange inventory (only list of transaction hash) with differential mecanism to limit transmission. When your node see an unknown transaction, your node ask the transaction data, only once. Look at net_processing.cpp in bitcoin core source code.
@_date: 2018-05-24 11:23:07
First I don't know a lot about bitcoin under the hood and this Puzzle is a way to discover and learn a lot about it.
Event if I already know about derivation path, never before I checked what every number means and how it could be altered and there's a lot of work If you need to bruteforce. That's why I say a lot more ("work" to go further).
Other subject I need to learn about : multi signature and bitcoin script. Maybe this subject are irrelevant, but they may be the next step after the password.
I hope to find a password on which I would have no doubt, but It will be more diffucult than with the seed, because there's no confirmation signal with password, whereas with seed : checksum ack like a validator from my point of view.
Excuse my bad English, as you can see, it's very difficult for me to express myself.
@_date: 2018-05-24 09:59:18
Maybe you're right. I can't be sure. But from what I've seen by playing with seeds : when you miss one word in a seed, you've got between 5 and 10 working word to get a valid seed.  That's not a lot of chance to get it straight right without testing, that why I'm optimist.
@_date: 2018-08-29 22:18:52
Yes this two line are from ProcessMessage method, which process the messages you receive.
But from what I understand from the source code, you don't receive any TX if you don't ask for it. This part is just the end of the process.
First you receive the inventory (tx hash list) from your neighboors, in the same method : strCommand == NetMsgType::INV
and if you find a hash from a tx you don't know, you flag it "askfor"
else if (!fAlreadyHave &amp;&amp; !fImporting &amp;&amp; !fReindex &amp;&amp; !IsInitialBlockDownload()) {
The fact that you flag the tx as "askfor" from the source node, will produce a GETDATA message to this node and this node will answer with the NetMsgType::TX you pointed to. The line 2218 is just another "last" control.
I find it's a very smart way to manage bandwidth between node, but my instinct tells me that this approach should be slow. But after timing it on mainnet on my node, I'm amazed by the speed of tx propagation. There's a lot to learn here. Fascinating project, code, team : respect.
@_date: 2018-05-24 10:02:12
I think too that's it's suspicious. But maybe it's too early In the puzzle. That's not because it took me a lot of time to get here, that's steps are complicated. And for OP it may be just the beginning.
@_date: 2018-05-24 09:59:45
Alteration of derivation path.
@_date: 2018-05-24 09:54:17
Yes but without any real method from the puzzle or clues : just basic monkey testing.
@_date: 2018-05-25 13:02:57
I think 00212121 is for password OR path derivation, because the seed I'm working with is related to 00212121 : it indicate it AND it give clues on how to use it after. That's why I'm so optimistic on the seed I'm working with, could not be random.
By the way, the arrival is certainly far far away, just hope it's before infinite :\)
@_date: 2018-05-24 05:54:38
No : the seed is valid, but is empty. It's not the solution, just an intermediary step. I'll post the address for later check. But by adding the passphrase (the extra word, which is not necessarily a bip39 word) the wallet generated is completely different and will point to the right address.
@_date: 2018-05-24 06:19:20
Agree with you, but when it's the good one, you'll have no doubt because the puzzle give it to you in plain sight.
@_date: 2018-05-24 05:43:35
I think that even if posting activity is dying, a lot of people are actively searching.
It's clearly not a trivial puzzle but the more you go, the more you're sure to be on the good path.
I'm done with the the firsts steps and I got a valid seed from the puzzle : the words used AND the the order make no doubt at all, because clues point to this. I'm sure a lot of people are here too or even further.
Next step : find the password.
If I abandon, I'll write here every steps.
@_date: 2018-05-24 10:03:24
I use electrum, but it's not important. Every bip39 compatible wallet works.
@_date: 2018-10-02 21:24:09
Yes I can understand how to code that (are miners running propritary code ?) but Bitcoin Core don't authorise this behavior (except with RBF flag), that's why I don't understand how to reach miners node in the first place.
@_date: 2018-10-02 21:45:00
But it's seems to be the same point with low fee tx. By default Bitcoin Core set 1000 sat as minimum fee. If I configure my node to relay lower tx fee but all my neighboors node run Bitcoin Core 0.16.3 with default setting, my tx never reach the network and is never relayed to miners. But If I try the same with my ledger HW, which use the Ledger Node, my tx is always relayed... I don't get the subtility except if their node have direct path to some miners.
@_date: 2018-10-02 21:42:20
That's my point of a view currently. Their's a possibility to have a working path, but no garanty. And after testing it in pactice, this tx is never relayed in my case, because every node around me reject it.
@_date: 2018-10-02 21:28:12
Ok that is certainly what I don't understand.
By testing it so far with bitcoin core in debug mode and with a modified node by myself (for testing purpose), the transactions is not relayed (conflict tx reject).
The transaction arrive on line 2107, next is rejected by AcceptToMemoryPool on line 2137 and is never relayed to other node on line 2139.
Because it's not relayed here and because it's not accepted in my mempool, it won't be expose in my Inventory and connected node arround me wan't be aware of this transaction. It's seems to me that is the exact same process of filtering than as a classical double spend attempt with conflicting tx.
Maybe it's relayed elsewhere, but I can't find it.
@_date: 2018-10-03 08:50:38
Thanks    for all your feedback on this !
I can confirm it's interesting to have a set of node. I currently try to understand the behavior of the Bitcoin Core code and the Bitcoin network. I work with 5 nodes around the globe (US, China, Europe) in different datacenter, plus one in my home. The nodes in datacenter are modified to lookup at specific tx that I initiate and get statistics about propagation speed and propagation origin. Plus they refuse to connect to each other to be sure to have a minimum one hop between them. 
When I send a simple tx with enough fee and no conflicting tx, the propagation is very very fast. After 3 seconds every nodes of my set known about it. I'm pretty sure that after 5 seconds max, nearly every node are aware of the tx.
When I send two conflicting tx (diffrent fee or different output address), with one minute between the two broadcast, the second one is neither propagated to the network. I don't see it on my own node set or on blockexplorer. If I chain two of my node, I can see the conflicted mempool rejection log on the second one.
When I send conflicting tx at the exact same time, to different peer (the process is handled by the modified node) : I can see the fragmentation of the mempool. Different tx reach different nodes of my own set. I can check it on blockexplorer too, different blockexplorer present different unconfirmed tx variant. In the end, the different point of view are resolved by the mined block.
When I try to do statistics about propagation, it's seems that I get different result if the broadcast point is not one of my node (via Ledger, or via HTTP submit on blockexplorer).
Like you point it, there's no agreement on pre-consensus rules. And I've tested modified behavior by myfself : there's clearly a big gap between standard Bitcoin Core code and behing banned for bad behavior.
That's make me think that Ledger, Blockexplorer and miners run slightly different pre-consensus rules about routing / filtering / connectivity strategy.
Is somebody aware of content about this : what modification / optimisation do they applied ? what's the purpose of this ?
 
@_date: 2018-12-15 21:28:07
If you can't convince those guys : fork it, do a better job with others dev, and full node owner will be happy to run the best code. Good Luck.
@_date: 2018-12-18 21:15:30
I'm going to give you reference to Bitcoin Core source code, and mainly those files :
First you need to understand that messages (in and out) are processed in a thread loop : look at net.cpp line 1996.
The loop process incoming message, then send message, then restart. If there is more work to do, the thread don't stop. If there is no more work to do, the thread sleep 100ms (max, because it can be wake up earlier by signal). This thread only handle the messaging part and not the real socket transmitting part, but it's not the point here.
When your node want to relay a TX (previously added to your internal mempool), you call RelayTransaction (line 988 of net\_processing.cpp). The relay function add the TX (th tx hash in fact) in an INV (= inventory) ready to be push to every node. (detail of PushInventory function in net.h file).
On the next SendMessages (line 3154 net\_processing.cpp), the INV will be send to your peers.
When you peer process your INV in his ProcessMessages (line 1854 of net\_processing.cpp), it will discover an unknown TX hash from you and will add it to his wishlist from you (AskFor line 1905). On the next SendMessages, your peer will send you a GETDATA message, to ask for the TX content.
Your node will process the GETDATA and answer it with a TX message with the full TX inside.
I'm not aware of the 1/4 part you talk about, but I'm sure you'll find it in the source code around net\_processing.cpp or net.cpp. For me the 1/4 type of filtering are use to filter inbounds connexion and not for TX relay, but I'm clearly not sure about it.
Good luck in your research.