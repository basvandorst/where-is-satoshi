@_author: antiduh
@_date: 2014-03-20 00:34:34
Sure, but who's to say it wasn't simple theft? An inside job?
@_date: 2014-03-11 16:46:45
I agree that wallet addresses are cumbersome, but the problem is of trust and security. If you add another translation layer between buyers and sellers, you create more risk of theft. Given how big of a target bitcoin is, I don't think this will work.
For instance, if you took something as simple as DNS and applied it to bitcoin, then diverting funds only requires that you temporarily hijack the DNS entries, which is trivial.
You could attempt to use DNSSEC, but even then not everybody gets it right.
@_date: 2013-04-15 23:14:07
Open currency, global participation. 
@_date: 2013-12-03 15:37:09
Coinbase is good for getting money into the system, but as you've found out, they take a while before they'll let you buy on-demand lots of coin:
* You have to wait a week for your first purchase to complete before you get anything, and you can't do any more purchases in that time
* After your first purchase is complete, you can only buy 0.1 btc on demand, once a week, until your 30 day wait period is up, meanwhile transactions larger than 0.1 take another week to go through.
I wouldn't consider coinbase an exchange, per say, but more of a way of getting money into the system. They just buy and sell at market price, there is no way to queue orders at certain prices, etc.
Some true exchanges are places like Bitstamp, BTC-e, and the ever-popular Mt Gox. 
So typically, one acquires btc through some place like virwox, vircurex, coinbase, etc, transfers the btc to an exchange like Mt Gox, and then you can start trading. 
@_date: 2013-12-03 03:19:47


Unfortunately, not true usually. Many file systems don't reuse blocks until they have to. ZFS, for instance, is a copy-on-write block transactional model. From wikipedia:


@_date: 2013-12-03 03:39:34
Honest answer: Watch the markets. The price right now has been hovering around 1050 - 1150, with a sudden excursion down to 840 last night.
There's a chance that we'll never see 700 again, heck, it could rise and rise and rise for the next 5 years and we'll never see prices lower than 1000 again.
My suggestion is to get some usd into an exchange. Set up a buy order at some low but maybe possible price (say, 870). If you're not paying attention and there's a dip, you might get lucky and your order might execute without you even knowing the price dropped.
On the other side though, it's possible your order won't ever execute because the price will never go that low again. There's talk of bitcoin being undervalued significantly, which means that the price ought to keep going up.
The best you can do is at least get money ready in an exchange so you can act on immediate notice. From there, you have to judge the markets and estimate for yourself whether or not you can live with buying at today's prices.
@_date: 2013-12-03 03:32:52
Entropy is the measure of unique information; it's the maximal amount of information you need to represent the state of a system.
A seed that's only 128 bits wide only has 128 bits worth of entropy. Using that to generate a 256 bit key is possible, but that means that in reality, the entropy in the key is only 128 bits - i can describe it in terms of a value that only has 128 bits: key = hash(128bit_seed).
Lets say you have some crypto system like AES that takes 128 bit keys.  So you need 128/8 == 16 bytes of data to generate a proper AES 128 key. Most systems take your (short) text password "myPassword" and run it through a hash algorithm (usually with some known salt), which does a great job of hiding the original password and generating enough key bytes to feed as a key to aes to do the crypto.
Yet, "myPassword" is a really stupid simple password, and doesn't contain much entropy. It's two out of roughly 30000 commonly used words in the english language. Password strength programs estimate that password only has 27 bits of entropy in it; that's tiny. Yet I could feed that to sha128 to generate a key for aes128 and have it all work, but it all boils down to having only about 27 bits of security. You could try encrypting the worlds secrets with that key, and it would encrypt, but it's not actually secure since the key is so weak.
As they say, garbage in, garbage out.
@_date: 2013-12-03 15:30:39
I agree, it's a little silly, but it's actually only one of a few ways that your unencrypted data can leak to disk.
One very popular way that it leaks is when the memory the program creates to store the data in memory gets written to the swap file. Swap files are usually unencrypted and can contain all sorts of goodies. Memory may get swapped to disk even if there's no memory pressure, for instance, if the memory hasn't been used in a while, the OS might reclaim it to use as filesystem buffer, since that's always getting used.
There's a few things you can do to help it though. Some OSs and file systems offer the option to encrypt certain directories or such, or you could go for whole-disk encryption on a drive you use just for crypto coins (like a USB stick). To get around the swap problem, you can either disable swap if you have lots of memory, or put swap on an encrypted drive.
This way, regardless if the program writes data unencrypted to disk, it still gets encrypted.
One downside to filesystem-based encryption is that you have to unlock and lock it every time you use it, for it to be useful. Keep in mind that, even though the blocks on the disk are always encrypted, if your computer gets broken into while you have it unlocked, they can still get the unencrypted bytes all the same.