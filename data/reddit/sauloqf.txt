@_author: sauloqf
@_date: 2019-03-22 18:15:18
It seems to be that you are not yet running a synchronized bitcoin full node, as it is not able to get even the 1st block. Please make sure that you are able to run commands such as:
    bitcoin-cli getblockhash 568323
If this command is not working in your node, it is not synchronized.
Also make sure that your **bitcoin.conf** file contains the line:
    txindex=1
After you add this line, you should restart your node with the command:
    bitcoind -rescan
and wait until all blocks are synchronized.
My program retrieves the transactions for a block. You should run for example:
    ./blockParser.pl N
Where N is any number between 1 and the last block (now 568323). It is not possible to get the genesis block (number 0).
@_date: 2019-11-13 18:22:40
Thank you for the warning. I was not paying attention :-)
@_date: 2019-10-14 12:13:48
Hi you all
Here is an example that can help you calibrate your programs. Imagine that the data to get the key is the following:
* Password: bitcoin
* Base: 3
* Exponent: 2
This would mean the chain is 3^(2) = 9 hashes long. These will be the hashes:
1^(st) \- 6b88c087247aa2f07ee1c5956b8e1a9f4c7f892a70e324f1bb3d161e05ca107b  (this is the SHA256 of the word bitcoin in ASCII)
2^(nd) \- f1ef1bf105d788352c052453b15a913403be59b90ddf9f7c1f937edee8938dc5  (this is the SHA256 of the first hash in HEX)
3^(rd) \- 19688a2fa0e4ffca9d82775df190b823382d83a91180464031ada84a086c1d65  (this is the SHA256 of the second hash in HEX)
4^(th) \- edfc1efaabf6ca37466e9427af70c969ca0ace915ac0dffaa3ea1bddb5f76563   (and so on ...)
5^(th) \- a367920b45822a1ea37625d8b3081b2dffddfebc01e1290b45f7954aba27e4ce
6^(th) \- c025c116bad28bc4cfca57ea22a77e409d7004d8c2deec37192786eadaa74cf9
7^(th) \- 8b1deb70b1448c76aa08f8f48af0a16b366a5833cdd3e539235657a7ad71ddbb
8^(th) \- 4078f386d477710e967ae1188c4d68e02ffa4634a4a7ba07c07439a0bddce711
9^(th) \- 569b9451981f4c21ed596c5607d6bb136f387bcb100e52144996568a83de291f  (this is the last hash in the chain. It is used as the private key. In this case, it corresponds to the public address 1JJPi1V5P6ng8xcoir1M3bwsNp5tnGQRmC).
If your program gets exactly these values, you are on the right track.
You can test the hashes here:
* [ (in ASCII for the password)
* [ (in HEX for the hashes)
By the way, my program runs at 850 Kh/s on my computer (an iMac 2017).
@_date: 2019-10-08 05:25:12
The idea is to give him a false password and he has no way to verify it.
@_date: 2019-10-07 18:43:46
Please accept the challenge as it is. No further tips here.
@_date: 2019-10-17 09:34:05
This was a very good technical explanation. Thanks :-)
As answered in your other post, not sure if it can beat my computer.
@_date: 2019-10-18 08:44:51
It seems to be a great material to start with. Thank you again :-)
@_date: 2019-10-18 08:48:31
You are right. The throughput of the wire connection to the external device could be a bottleneck, no matter how fast the device is.
If I use USB 3.0, it runs at 5 Gbits/s, which corresponds to 625 MBytes/s. If I need to send 32 bytes to the board and it sends me 32 bytes back, it means a speed of at most 9.7 MH/s. It is less than what was suggested for the Artix 7 (12.5 MH/s). It would be in fact less than that, because we need to add the time to process the hash and some extra bytes to control the communication.
But it seems to be that the Artix 7 uses USB 2.0, which, by my calculations, would mean at most 937 KH/s. This is about the same speed I get with CPU.
A solution would be if the board calculates the entire ChainWallet on its own and sends only the last hash back.
@_date: 2019-10-17 10:12:52
Without parallelism it would be 400 / 32 = 12.5 MH/s. Not bad. This is 14.7 times the speed of my computer. I will take a look on it. Thank you for the tip again.
@_date: 2019-10-17 06:39:09
I think you are right. Thanks.
@_date: 2019-10-17 09:29:18
Thank you for the tip. Not sure if it would be faster than my computer. I have reports that an GPU can do 78 Kh/s on one single core. Those old FPGAs are probably not faster than that. My computer can do 850 Kh/s using only the CPU. The advantage of a hardware implementation seems to be only when you do many runs in parallel. But such runs are not possible in a ChainWallet. Anyway, I will research about it.
@_date: 2019-10-17 06:37:45
You are right. This is a test of concept. There are many possibilities here. I want to explore then all :-)
@_date: 2019-02-04 14:33:45
As I told, different sk's means their public keys are symmetrical (as R is the same). This is improbable by itself, but resulting in the same S is even less probable.
It is not a problem on the collision itself. It is only strange, as this is a huge number space. Thank you for your contribution anyway.
@_date: 2019-10-16 16:08:38
Hi afk11, thank you for your answer.
You are right. Most implementations of an ASIC are prepared to realize a double SHA256. But it could be useful. In a ChainWallet, we calculate a long chain such as:
* sha256(sha256(sha256(…sha256(privKey)…)))
If I could get a double SHA256, it would at least be useful if the length of the chain is an even number.
Because the idea is to create a chain with billions or trillions of hashes in series, the time to create it is already very long. So, the time to get the pubkey is irrelevant.
By the way, I don’t want to get the key for the address [12FnVGpLqxmPTfENdyBso9HNbEdQEiHuhH]( because I already own it. I am the guy that created the challenge ;-)
I already have a [C++ version]( of the idea that runs on 850 Kh/s on CPU. What I want is to create an ASIC version of it to see if it would be faster, so that I could create even safer wallets.
@_date: 2019-02-04 14:30:23
Thank you for your answer. I am glad to meet a known bug such as this one :-)
@_date: 2019-10-16 16:36:17
It makes sense. But I saw in the cgminer code that you could deliver a 32 bytes midstate instead of the complete 80 bytes and thought we can give some low target in order to trick it.  I am thinking how that could work.
@_date: 2019-02-26 10:16:24
You should add this entry to your bitcoin.conf file:  txindex=1
This will enable you to see any transaction, not only the ones related to your wallet. After you start bitcoind, it will start syncing and adding many gigabytes to your already huge .bitcoin folder. After this sync is ready, you can use this command with any transaction:
bitcoin-cli getrawtransaction &lt;txid&gt;
@_date: 2019-09-02 06:28:34
The program creates two addresses from the same private key: a  P2PKH (starting with 1) and a P2SH  (starting with 3). The latter is compatible with Segwit and is what is meant in the specific line where the comment is placed. So, if you use the program for your coins, you can choose which type of address you want to use.
For this challenge, I used the P2PKH address (the first one), which is better known from the public.
@_date: 2019-09-27 05:15:35
No :-)
@_date: 2019-09-04 18:28:42
That is the idea. Why use a 24 words mnemonic if you can protect your key with such a small set of information? This method seems to be even quantum safe! But I want to be sure. Maybe there is some way to speed-up the brute force attack that I am not aware of. Therefore, the challenge here.
@_date: 2019-09-02 06:38:52
Please take a look on my answer for Shancer\_'s comment.
@_date: 2019-09-06 11:04:46
It does :-)
By "possible hashing" I think you mean "possible chain length", right? Only to be sure that you got the idea right :-)
@_date: 2019-09-27 06:07:38
Thanks, I will try those :-)
@_date: 2019-09-02 06:32:06
Keep in mind that an ASIC has a huge hashrate because it calculates the hashes in parallel. It would be much slower when a hash depends on the last one, such as in this case.
@_date: 2019-09-27 10:41:30
Hi, thank you for your thoughts.
You are right. The market will decide what is useful or not. I use it to my coins and feel much safer.
Some people are really not prepared to deal with this kind of stuff. Even if they have 24 words, they will write it down on a paper under the keyboard. A wallet can force a minimum length for the chain and block commonly used words for the password. It is a matter of design.
By the way, I think there is no other solution for the case of someone trying to steal your coins by force. Only those that experienced this situation in person know about it.
@_date: 2019-09-27 05:58:17
Hi Keatonantron
I someone steal your original key, there is no way to protect yourself against it, no matter which method you use to generate it. This is not the intention of the ChainWallet.
An ASIC has its huge hash rate because it calculates several hashes in parallel. You would need to rewire an ASIC in order to create a ChainWallet. Even so, the speed today of a hardware implementation of sha256 is only about 17 times the speed of a computer.
If you use a smart contract, someone only needs to wait until the time arrive to point a gun to you.
The ChainWallet is an alternative to BIP39. Instead of memorizing 24 words (which is difficult), you only need to memorize a small password and two numbers (base and exponent).
To generate the chain, it takes some time. Even if it takes 1 second, it means that a brute force against your wallet would be impaired, as the attacker would at most get the speed of 1 pass/sec to go through the search space.
If the time is longer, such as days or weeks, you protect yourself from sudden changes on your funds. If someone points a gun to you, you could return the wrong password and the person has no way to verify that. So, you have time to recover yourself from the situation.
@_date: 2019-09-04 14:17:35
Hi, thank you for your contribution. A small tip: your program is slow because it calculates the Bitcoin address for each step in the chain. You don't need that. You can go much faster if you calculate the address only if the length of the chain reaches one of the predefined values for base ^ exponent. 
Good luck :-)
@_date: 2019-09-29 19:21:09
Thank you for your suggestion. I will think about it :-)
@_date: 2019-09-28 09:35:16
If you use multisig and have a gun pointing to you or a beloved family member, you would call all the other key holders and ask for their keys. The robber would only be satisfied after he has the coins, which can be transferred right away. This do not solve the problem. A ChainWallet would delay the transfer, even if you really want to do it. The chances that the robber will wait weeks or months for the key generation, or even that he/she is able to calculate the chain, is very small.
Even more, not everyone has family members / trustful people that knows how to deal with a crypto key. This is a risk even without a robber.
@_date: 2019-09-06 16:23:05
@_date: 2018-12-06 15:17:29
A timelock has a fixed appointment in the future. But you never know when a bad guy will torture you. Being sure that you are forced to delay the decision of getting your own hands in your private key is the proposed approach. Of course this is for hodlers.
Besides that, you can also use this approach in combination with multisig.
@_date: 2018-12-06 17:48:00
I added a new post that better focus on the main arguments of this proposal without the misleading word BrainWallet or a source code of a test-of-concept:
@_date: 2018-12-06 10:59:28
If your wallet took 1 week to be generated, the bad guys would need to torture you that much time to get the coins.  You could also create a wallet that takes 6 months to be generated. Would the bad guys wait that long?
Besides that, if it is possible to have immediately access to your key, no matter how many persons are involved, you are in trouble. And if your keeper dies you would also be in trouble.
@_date: 2018-12-29 13:37:41
Sure :-)
@_date: 2018-12-06 15:04:39
As I posted in the other comment,  I didn't mean that it has more entropy. I mean it takes more time. Please forget old style brainwallets. What I am proposing here is a way to delay the creation of a private key. I mean, delaying for days or months. This is the main point of the proposal. If you don't know your own private key and the bad guys cannot get it from you in a short time, your coins are safe.
Here it is irrelevant if your private key would be generated by a brain password of by a BIP-39.
@_date: 2018-12-07 07:29:02
I agree with the use of a slower hash function. Bcrypt is maybe a good candidate. I need to research if it preserves the entropy of SHA256. Thank you for the suggestion. This would also avoid using ASICs, since they are normally designed for SHA256.
It would be great if you can resist an intruder by giving him an intermediary wallet. But I believe if your life or from your beloved ones is being threatened, you will say the true. This is an extreme situational. My proposal is a way to prevent you from giving your private key to an intruder, also if you really want to do it.
@_date: 2018-12-06 12:36:53


Of course it provides. It takes more time. This is exactly what you need in this case. I didn't mean that it has more entropy.
@_date: 2018-12-06 10:17:19
The problem it that the word "brainwallet" got a bad reputation. This was because people was using the first SHA256 of a password as private key. It is pretty easy to create a brute force attack on it. But if the attacker needs to create a billion hashes for every password tried, his attack would be impossible. It would take too long. And this if the attacker knows that exactly 1 billion hashes was used. Nobody should know how long your hash chain is.
@_date: 2018-12-29 14:06:39
You are welcome. This is a good idea.
@_date: 2018-12-29 16:18:01
This is how I installed my node on a Rasp 3B+ using Raspibian 9:
    sudo apt-get -y install git autoconf libtool libboost-all-dev libssl-dev libevent-dev
Create Berkeley DB (necessary if you want to use a wallet):
    mkdir db4
    cd db4
    wget " 
    tar -xzvf db-4.8.30.NC.tar.gz
    ./db-4.8.30.NC/dist/configure -enable-cxx -disable-shared -with-pic
    make -j$(nproc)
    sudo make install
    rm -rf db4
Install Bitcoind:
    git clone 
    cd bitcoin
    git tag
    	Show available versions
    	Versions with "rc" at end are beta (release candidate)
    	Select the last stable (without "rc")
    git checkout v0.16.1
    	Example of choosen version
    ./autogen.sh
    ./configure LDFLAGS="-L/usr/local/BerkeleyDB.4.8/lib/" CPPFLAGS="-I/usr/local/BerkeleyDB.4.8/include/" --without-gui --disable-tests
    make -j2
    sudo make install
    rm -rf bitcoin
vi .bitcoin/bitcoin.conf
    server=1
    daemon=1
    rpcuser=&lt;yourUser&gt;
    rpcpassword=&lt;yourPassword&gt;
    walletrbf=1