@_author: zero_iq
@_date: 2018-01-20 11:34:56
it's from Iain M. Banks's Culture novels. The advanced "utopian space civilization" known as the Culture looks down on other civilisations that have money because the existence of money implies limited resources that must be bought/sold/rationed/worked for/etc.  The Culture doesn't need money because their technology provides them with everything in limitless abundance. They are a "post-scarcity" civilization. Nobody has to work. Nobody has to be paid for anything.
Money is poverty.
@_date: 2018-01-19 19:25:07
Money is poverty.
@_date: 2018-01-30 15:32:26
You don't. It relies on base58, which is not part of the python standard library. You'd most likely download and install it from PyPI. In theory, that library could be changed at any time by whoever uploaded it so that it does something totally different next time you update your libs with pip. What you install is not necessarily what is hosted on the github repo, nor does PyPI provide any kind of guarantee that the uploader is who they say they are. And many people run pip install as root too, so you're giving root access to the package maintainer.
It might be totally fine. It might not. It might be fine today, and not fine next time you upgrade your system.
And if not it wouldn't be the first time spoof libs have been uploaded there and installed by unwitting Devs who blindly trust external software repos that allow contributions by anyone. PyPI has very few checks and balances compared to other repos like Linux package repos, maven etc. No mandatory PKI keys/sigs, mentoring, or community standards, or anything really. All you need to upload a package is a working email address.
@_date: 2018-01-10 09:16:43
-- --- .-. .
@_date: 2018-01-18 14:36:13
More like replacing Swish with a central public service instead of a proprietary private company. Swish is a very popular Swedish instant money transfer app that is increasingly replacing cash transactions originally for person-to-person payments, and now supported by more and more businesses as a method of payment. Swish has something like 5 million users out of a total population of about 10 million.
@_date: 2018-01-18 14:04:53
The longer you hodl your breath, the higher you get.
@_date: 2017-12-27 21:17:47
How very dare you question his expertise! He spent an *entire night* researching it! 
@_date: 2018-05-12 12:10:36
Why, you'd need to keep some kind of permanent public ledger with records of every single transaction ever made to be able to do that! Crazy! /S
@_date: 2018-03-21 21:39:59
I've made at least 3 payments to coinbase from my Lloyds accounts (current/SEPA + credit card) and not had a problem so far. I'd use Revolut for any further payments now though.
@_date: 2018-03-16 10:22:20


You will never learn anything with an attitude like that. You clearly have some fundamental misunderstandings about bitcoin and even what inflation is. Please listen to @_date: 2018-02-01 00:32:24
Exactly, don't get me wrong -- your code is fine, but once you start down these paranoid lines of thought, it's amazing how there can be cracks in the security of even the smallest, simplest code snippets, and how many assumptions you're really making about the software (and hardware...) stack. Keeping financial data secure is hard enough, but in the case of cryptocurrencies, where the data being processed effectively *is* money the temptations and motivations for attackers are extremely high, and I think it's worth being pretty paranoid.
I'm sure we can fairly safely assume something like base58 is fine currently, but on PyPI it's really only as safe as the uploader's email account... and how much you trust the package maintainer. (Of course, even if they are trustworthy, they could be threatened or blackmailed, or simply be hacked themselves.)
Talking of attacks on random number generators: your 10-minute 'burn-in' test can be fooled. One example: by using a cryptographic hash of a clock and counter (reset every clock tick), you can produce a random number generator that passes your test, but still allows an attacker to regenerate the output for a known time period, making reasonable assumptions about your call rate. The output will still appear truly random, no matter how long (or how fast) you generate test keys. You could also mix in a smallish random salt so that the spoofing remains undetected even if you run the test on a number of parallel machines with synchronised clocks. The pool of possible keys for a given time frame remains large enough to go undetected, but small enough to make brute-force practical. If the attacker knows to a higher degree of accuracy when you generated your key, then the pool is correspondingly reduced, especially if you don't typically generate keys at a high rate. If the attacker has access to a lot of computing resources, then this could be made extremely hard to detect by making the random salt highly random, and increasing resolution of the clock, and yet still keeping things crackable in practical time frames instead of aeons.
Putting your paranoid hat on, how do you know your CPU's RNG doesn't already do something like this? OK, maybe we're getting too far down the rabbit hole now... maybe.
Rather than a 'burn-in' test, you're better off getting your randomness from multiple sources and XORing it together, under the assumption that the same attacker is less likely to have compromised all of them at once.
@_date: 2018-04-19 15:59:14
But is good in Arstotzka, yes? I give you for stamp passport?