@_author: gorpherder
@_date: 2013-11-18 20:10:07
How's that help?
Decentralization does not actually help address the trust problem I am describing.  Fundamentally wallets, etc. need to have an inherently centralized (if briefly) authority performing the transaction.  
You could build a system that required multiple parties to participate in a transaction for it to occur (N-phase commit schemes) but that's not how bitcoin is used today.
I think you could construct such a thing with the primitives that bitcoin offers, perhaps.
@_date: 2013-11-24 05:19:13
My point was that decentralization doesn't help when it comes to trust; look past blockchain.info specifically and recognize that the problem is that you are going to end up having to trust entities (for example, whoever built your bitcoin client, if you use a client directly).
Confirmation here was multi-phase transactions, not the block chain, and was more of a meandering into a thought on whether you could totally eliminate the idea of a single wallet being authoritative for its value.
@_date: 2013-11-16 20:38:42
In the honest spirit of trying to raise the bar a little I want to point out that you cannot audit some code published on a website and use that to find your way to trust.
Even if the code was open source, you have no way of verifying that the code they published is what the server is running. 
Even if you had some way to do so (you don't), you further don't know anything about the execution context which is just as important.  What's sitting in libc?  You don't know unless you audit that, too.  In order to do that, you need to prove that the compiled code was built from the provided source.  That's a very hard problem.
Security is about more than a part of the code that is (maybe) executing - the environment in which the code runs is a huge factor; what good does it do you to see the source code if it's running on an insecure server where other, unaudited random code may have been injected into the process that is running the code you're inspecting?  What good does it do you to check code that relies on an enormous standard and framework library that may have been tampered with?  It's a much harder problem than "make the code open source."
What open source does is expose incompetence .. maybe. 
The problem is that above a certain size, a code base is not comprehensible without significant experience and investigation and even then you need to control and verify not just that code, but all of the code around it - the environment, every imported library and framework, and the OS and component libraries themselves, not just statically but at runtime.  Trivial bugs are obvious but beyond that it is unlikely that you will spot any real security issue on the server side code and it's a pinhole view anyway.
What it comes down to is: you either trust the organization or you don't based on their overall big picture - their responsiveness, visible competence, etc.  In this case, that seems to be somewhat lacking.
Read  and then ponder how open source would help.
@_date: 2013-11-16 20:26:13
Let's say they posted the server code on GitHub.  How do you know that's what the server is running?
How do you know their tools (VM, compiler, etc.) have not been compromised?
The idea that open source helps you solve these problems is extremely naive.
@_date: 2013-11-17 02:58:54
I cited it in my other post, so yes.  And no, open sourcing doesn't help in this regard at all except in terms of making rank incompetence obvious; nothing more.
@_date: 2013-11-20 01:38:13
Neither decentralization nor open source are going to help much there.  When trying to solve a problem it helps to actually push for solutions that do actually help.
In this specific case, what you have is the need for multiple agents to prove that they have the authority to issue/confirm a transaction as legitimate - that's a tough problem.
@_date: 2013-11-24 22:40:06
Accept that you got lucky and take the money off the table at the peak of the bubble.