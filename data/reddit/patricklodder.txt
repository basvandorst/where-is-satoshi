@_author: patricklodder
@_date: 2016-04-10 13:14:11
Thx. (I know HOW to do it, just need to install some windows PE debugging toolchain)
@_date: 2016-04-10 10:55:58
The same user has uploaded a copy of wallet-key-tool:
Since those are binaries, virustotal and local scanner say it's clean (the .jar, the .exe triggers jar-packaging positives) I quickly tried to verify if it sends out any packets (using a packet capture setup) but haven't seen anything suspicious over standard protocols yet and it didn't do any dns lookups.
I'll spend some time on disassembling the jar file and investigating that. Perhaps someone with proper windows tools can look at the packaged .exe?
Edit 1: the jar seems to be untouched, but the .exe sha256 hash does not match:
```1890e30159c36042daf8d3313ad1d5bfdff1455016da346fa147d47ff6573d1b  wallet-key-tool-1.4.2.exe```
```5ff9747bf128e9e9590f72e403de8bfe1ad521be5b1c091e38852e04f09d8453  wallet-key-tool-1.4.2.jar```
compared with 
**Edit 2: Hex editor finds this in the diff between the .exe files:** 
@_date: 2016-04-10 14:35:43
Indeed goes to the same host: 
- I ran it 20 times with different wallet formats / contents and it only shows this pattern: it does the DNS lookup and establishes a TCP connection to the server at port 80 but it does not send anything out, or do any HTTP calls. 
- I also simulated having the wallet files in their actual directories but it does not pick them up from there either.
- TODO: I still need to run this through something where I can inspect memory (hence debugging env) to make sure that it doesn't have any other fallback and hopefully find what I'm doing wrong to trigger it actually sending something.
@_date: 2016-04-11 19:01:15
You're right, not everyone here or elsewhere on reddit is uneducated. I may not have "hacker" tattooed on my forehead, but that doesn't mean I will run forensics a suspect windows program without taking precautions.
And yeah... VM. The type without persistence that you script to install wine on and then find how how much bloat is needed to even run a windows binary.
@_date: 2014-10-07 19:41:37
you can do that if you want, but we call that 2-of-3 (because out of 3 possible, 2 sigs are needed) :)
@_date: 2014-12-04 20:04:08
30 (oof)
@_date: 2014-10-07 16:56:52
I completely understand that.
I think it's all about choice and this is exactly why we have our n-of-m option in the works, so that you can choose the right security model for your own use case, and whatever you're comfortable with.
For example, if you want to have a 1-of-3 address (we'll add one to this for ~~green~~ key-increment facilitation, so it'll be 2-of-4 on the blockchain) you will soon be able to do that. You'd just supply us with 3 public keys, and put 2 in separate safes, keep one locally (ie: passphrase derived like we do with 2-of-2.) Same goes for 2-of-3 or 4-of-5.
We're working hard at the moment to implement this functionality in a friendly and understandable way in our client libs and docs, and I am confident we will soon officially announce this additional feature. :)
@_date: 2014-10-07 16:13:33
Yes, that is correct, it is a password/phrase. We enforce a minimum of 8 characters.
For me personally, I always make sure my pin is more than 48 characters.
*Edit: forgot to mention, we do multiple rounds of pkbdf2 with sha256 (as used in scrypt) on the passphrase so bruteforcing it when all you have is cyphertext is still rather expensive* 
@_date: 2014-10-07 16:33:49
Yeah excessive is king, just takes some time to start stuff up :)
@_date: 2014-10-07 19:52:44
Absolutely right, corrected my answer, thanks!
@_date: 2015-04-24 07:49:08
Correct, I'm not. The only time I seriously mentioned it was in the context of someone building a microblogging protocol by abusing p2pkh outputs and I suggested to create a specialized chain for that rather than bloating one that's meant for value exchange. 
Creating yet another coin/currency is not on my todo list :)
@_date: 2015-11-11 11:51:53
Sorry, I'm not sharing my stress-test project, not in compiled or source form. I didn't write it to enable anyone to spam the blockchain, I just wrote it at request for doing a single stress-test on the dogecoin testnet, which it did very well within set parameters. 
In my opinion, if you want to test bip-101 or any other disruptive change, you're best off just setting up a simulation on regtest or another alternative throw-away chain. IIRC Gavin did this already for this particular bip, doing it on testnet is not adding anything except that you cannot just throw stuff away if things go wrong?
If someone needs my help with a high transaction volume test on a throwaway chain, I can help out by supplying that volume, just ping me with a proposal :)
@_date: 2015-10-06 13:36:50
Thanks for your explanation.


To elaborate: whenever you spend coins, you are linking a transaction hash and the position of an output in the transaction identified by this hash, this is referred to as unspent transaction output, or utxo. 
Because the hash is malleable (has different possible values for the same outcome) the consequence is that if you spend a utxo for which the transaction hash has changed between the creation of your spending transaction and the mining of the transaction, your transaction is invalid because you are trying to spend an utxo that according to the latest state of the blockchain does not exist.
This means in practice that as long as transactions are malleable:
1. It is not safe to spend utxo that have not been mined yet (0 confirmations)
2. It is not safe to spend utxo that have been mined but risk a blockchain reorganization (can happen every block, for a couple of blocks)
3. If you absolutely need to spend an utxo quickly, (like with 1 confirmation), you need to be sure that the inputs  ~~to that transaction~~ that provided the coins you're spending have enough confirmations.
What do you (or your wallet service provider) need to do to protect yourself until transactions are provably non-malleable? (this has been said before, nothing new here)
- Do check the amount of confirmations on inputs you're receiving from outside before considering a transaction valid.
- Don't spend utxo without reasonable amounts of confirmations, not even from "change addresses". Having a "fifo" input selection in your wallet software (or manual like coin-control in Bitcoin Core) may help you with this.
- Edit 2: Do be alert about split chaintips and be more cautious about what amount of confirmations is reasonable when such an event is happening.
Edit: rephrased for clarity (i hope)
@_date: 2015-03-25 00:46:20
The IDs of all members of the Board of Directors of The Dogecoin Foundation have been verified. If you have any indication that our procedures have been breached, please contact me by PM or through the form at 
PS: Why is this being discussed in @_date: 2015-10-06 19:37:05
Coins being your "property" or not is a cool analogy from a human perspective, I agree. The network does not care though. It cares about an unspent output being provably spent in a transaction.
You are right that from a single node/wallet perspective, you can never see more than one version of a transaction confirmed at a time. However, from a network perspective, when it's segmented (last time happened ~130 blocks ago according to `getchaintips` output) it is.
Your wallet will always choose a single version of the truth, but a reorg can change the truth. In the old truth you can have tx hash A and in the new truth tx hash B. If you have a new tx with hash C that spends hash A, then that tx becomes invalid after the reorg. If you have a tx D that spends C, and both C and A were in the block that got reorganized out, then you have a problem.
Luckily, I don't see any chain forks longer than 1 block lately, so it's not too bad, but that doesn't mean you can always trust a single miner mining your tx to be sufficient.
@_date: 2015-03-07 11:50:11
** flips some more signs **