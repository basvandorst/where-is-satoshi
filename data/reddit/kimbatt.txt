@_author: kimbatt
@_date: 2019-07-25 05:37:38
Every private key produces 4 different addresses:  
- p2pkh uncompressed (starts with 1)  
- p2pkh compressed (also starts with 1)  
- p2sh segwit (starts with 3)  
- bech32 native segwit (starts with bc1)
@_date: 2019-07-30 16:28:38
Yeah it's probably segwit related
@_date: 2019-07-30 15:48:40


That's pretty much how it is.
Here is my implementation of it:   
  
Quickly explained:
- Get the EC keypair from the private key (X and Y coordinates).  
- Create the compressed public key (33 bytes: first byte is 0x02 if the public key Y coordinate is even, 0x03 if it is odd; the remaining 32 bytes are just the X coordinate).  
- Compute the hash of these bytes: RIPEMD160(SHA256(keyBytes))
- Add 0x00 and 0x14 to the front of the hash: [0x00, 0x14, keyhash[0], ..., keyhash[31]] (0x00 is the version of the address, idk what 0x14 is but you need it)  
- Convert all these bytes to base 32, and create the bech32 string from it (using the characters from [here]( so if you have the byte 0, it becomes the character 'q', 1 -&gt; 'p', 8 -&gt; 'g', 9 -&gt; f, etc...)
- Add "bc1" to the front for mainnet, "tb1" for testnet
- Add the bech32 checksum to the end (to calculate the checksum, you'll basically need the algorithm from the bech32 (or you could copy it from [here](
@_date: 2018-09-01 02:34:12
It is because the colored version is different every time you generate a new address (the white lines around the bitcoin logo change), and the grayscale version also has boxes around the address, so I thought that was better.
@_date: 2018-08-31 08:46:47
I made this one a while ago, it should do the job: 
@_date: 2018-08-31 13:14:20
You can even use your own image, and you can also input your existing private keys and addresses if you check the "Use your own addresses" checkbox on the paper wallet tab.
@_date: 2018-08-13 14:39:37
The problem is that you hash the string itself, not the bytes:  
the first byte in your calculation is the ascii value of the character '0' so 48 (0x30), then '4' what is 52 (0x34), etc...  
You should calculate the hash from the byte array, so [ 0x04, 0x79,  0xBE, 0x66, ...etc], instead you now calculate the hash of the byte array of the ascii values, so [ 0x30, 0x34, 0x37, 0x39, ...etc]  
If you look at this page:  , you see that you will get the same wrong value if you paste the 0479BE...10D4B8 string to the 'string hash' field, and the correct 50929B...803AC0 value if you paste it to the 'binary hash' field.  
Look for a "byte mode" in your sha256 function, or if it doesn't have one, convert each pair of characters to a byte.
@_date: 2018-05-31 17:05:23
No, but since I'm only changing the index.html file most of the times, it is not that hard to copy the modified parts over to the split version.
@_date: 2018-08-12 20:37:58
Until 0479BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8 the calculation is correct.  
If you take the sha256 hash of this, you should get 50929B74C1A04954B78B4B6035E97A5E078A5A0F28EC96D547BFEE9ACE803AC0, then the ripemd160 hash of this is 91B24BF9F5288532960AC687ABB035127B1D28A5.  
After adding 0x00 to the front, you get 0091B24BF9F5288532960AC687ABB035127B1D28A5.  
Take the double sha256 of this: first 79FA926BF4AC874060B244D6E985C694233EED0D5562C0B88CDF37BFBB80B44F, then another one: 0074FFE0526D823BE09B39865422A1D6135AFC85AFB0A6863C58E9FE89989170, the first four bytes are: 0074FFE0.  
The final bytes are 0091B24BF9F5288532960AC687ABB035127B1D28A50074FFE0, after base58 encode: 1EHNa6Q4Jz2uvNExL497mE43ikXhwF6kZm.  
You should always hash the bytes, not the string.
@_date: 2018-05-31 16:52:35
Added it!
@_date: 2018-05-31 16:58:17
It's my nickname, it doesn't mean anything, I just wanted a nickname that no one else has :D
@_date: 2019-03-04 11:52:27
Yeah I had a tough time figuring out how to transform screen coordinates to world coordinates (and vice-versa), y value is up to down in screen coordinates, and down to up in webgl, also calculating the zoom and camera position made it even harder (and of course everything needs to be recalculated when the screen is resized). But it works now, so it's fine, I can rename it if you want :D
@_date: 2019-03-16 22:44:13
If you are thinking of a list of addresses sorted in alphabetical order, that is not possible (with the current technology at least).  
Addresses are just representations of the hash of the public keys, which means in order to create such a list, we would have to reverse sha256 and ripemd160 (which we cannot do); or to go through all 2^256 addresses and sort them (which is also impossible).  
Also, having such a list would make bitcoin pointless, since you could just look up the private key for any address (and spend from it).
@_date: 2018-10-18 17:34:51
There are (almost) 2^256 different private keys for bitcoin, and 2^160 different addresses.  
That is: 1 461 501 637 330 902 918 203 684 832 716 283 019 655 932 542 976 different bitcoin addresses.  
This number seems big, but how big it actually is?  
It is so huge that you just cannot think this big. But here is an example:  
  
The surface of earth is 510 000 000 square kilometers.  
That is 510 000 000 000 000 000 000 square millimeters.  
  
So, if we distributed every bitcoin address (not even private keys) evenly across the surface of the earth, there would be:  
2 865 689 484 962 554 741 575 852 613 in one square millimeter.  
Well, that still seems big, so let's go even smaller.
Let's say we want to know that how many addresses are in one square nanometer.  
1 millimeter = 1 000 000 nanometer -&gt; 1 nanometer = 0.000001 millimeters  
1 square nanometer = 0.000000000001 square millimeters  
  
If we calculate it, we get that there are still 2 865 689 484 962 554 addresses in ONE SQUARE NANOMETER.  
And there are many many square nanometers on the earth.  
  
  
About the address generation:  
On my machine, I can generate about 25 million addresses per second with vanitygen, with gpu acceleration. Let's round that up to 100 million.  
If we take 100 billion of these machines, we can generate 10 quintillion (1×10^19 ) addresses per second.  
If we left them running for 100 million years, we would have generated 31.5 decillion (3.15×10^34 ) addresses by then.  
  
There are about 3.5 million bitcoin addresses that have any balance on them.  
So if we generated 31.5 decillion addresses, we have about 0.0000075% chance that we have generated ONE address that has non-zero balance.  
  
So the chances of finding an address with non-zero balance is practically impossible, and you shouldn't even bother trying.
@_date: 2018-10-20 11:00:34
@_date: 2018-06-17 20:55:30
 I made this address generator a while ago, it can generate bip38 encrypted segwit (and bech32 segwit) paper wallets.
@_date: 2018-06-02 22:17:29
Just added bip38 encryption for paper wallets!
@_date: 2019-10-20 15:11:10
This is a very nice video that explains how it works: 
@_date: 2018-06-01 11:20:00
I'm planning on adding it, but I need to do some research on it first.
@_date: 2018-06-01 22:39:15
Thanks for the donation!  
I just finished the bip38 encryption, but it is only for bulk generate for now. I'll probably add it for paper wallets tomorrow (it's getting late here :D )  
You can decrypt the wallets at the "Address details" page.
@_date: 2019-06-02 12:42:47
You should look up Shamir's secret sharing scheme. It allows you to split up a secret into n pieces, and allow reconstruction of that secret from any m pieces (m &lt;= n).  
Ian Coleman made a tool for exactly this (splitting your seed  phrases), here it is:   
In your case, you'd need the 2 of 2 split (so generate 2 shares, and both of those are needed to reconstruct the secret).  
Note that this is the only implementation of it, so if you decide to actually use it, you should save that site for later.
@_date: 2019-02-17 15:05:12
I created a browser-based version of revealer, here it is:   
You can create and decrypt revealers from this page, it even works with revealers created by electrum.  
The tool is a single file, so can be downloaded and used offline, and is [open source]( .
@_date: 2019-04-04 10:29:53
 This is a tool I made a while ago, it has bip38 password protection.  
WARNING: I haven't seen any other tool that generates segwit addresses with bip38 passwords (bitaddress.org will generate the corresponding legacy address), so you either need to use this tool for decrypting, or generate non-segwit addresses so other tools can also decrypt it.
@_date: 2017-09-09 01:57:31
@_date: 2017-09-10 00:52:38
 It took me about 15 minutes to modify my bitcoin address generator program to this task. 
 It took the program about 17 minutes to brute force. 
 It would have taken more time if I didn't know that it had 3 letters modified, probably 1-2 days 
 You should probably not use this method 
 Thanks for the bits u/shazvaz
@_date: 2019-09-08 13:43:32
There are two addresses for an encrypted private key, you can try to decrypt it on bitaddress.org (wallet details tab), it will show both addresses
@_date: 2019-05-15 12:31:35
There are 24! possible order of words (24x23x22x...x3x2x1), which is 620448401733239439360000. If someone could check one billion of them per second, they only could try all possible combinations in [19.67 million years](