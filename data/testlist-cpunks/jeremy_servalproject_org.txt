
@_date: 2011-06-14 09:18:02
@_author: Jeremy Lakeman 
@_subject: [serval-project-dev] OpenBTS, OLSR and Serval 
FYI, there's a write up of the recent integration work I did in DC
with Serval, OpenBTS and OLSR here;

@_date: 2011-11-04 17:02:02
@_author: Jeremy Lakeman 
@_subject: [serval-project-dev] New 0.07.RC1 build 
There have been a couple of annoying bugs that we've found with the
last two releases that we really need to get fixes out for. Plus the
new automatic device detection support that Paul has been building has
been getting close enough to be useful. So I've been trying to tidy up
what we've got for a new release.
There's still lots of testing we need to do before we even contemplate
a release to the android market. But I've run out of blocking issues
that I'm aware of and I think these changes are ready for some wider
testing on more handsets than we have access to here.
However, there are still a couple of things we MUST change before we
build an official 0.07 release and encourage it's use for a wider
audience. Mostly to give the user more control over which experimental
support scripts to try, and make sure the process restarts after a
reboot / force close, as running a script may cause the device to
crash hard.
Some quick release notes;
- New post installation screen to display the progress of tasks we
have to do on install
- New automatic wifi chipset detection process that tries to guess how
to put you phone into adhoc mode
- Stop dna from corrupting it's data file and crashing which would
leave the phone unreachable.

@_date: 2011-11-27 19:41:30
@_author: Jeremy Lakeman 
@_subject: [serval-project-dev] Architecture questions 
Yes we currently default to using BATMAN to generate the route's
between nodes on the network. We also support olsr as the underlying
mesh routing protocol. And we can run our software with a network of
just an access point and its clients, mainly to support clients that
don't allow the right wifi modes for mesh networking. And longer term
we intend to replace the mesh routing layer with our own protocol
Our long term goals also include removing the need for running a full
blown asterisk installation, and SIP client, on a phone with
effectively only one extension. This would also drastically reduce our
installation size.
The main pieces of work that will need to be done for any port as I see them;
- see if we can connect to, or start, an adhoc wifi network. May be impossible.
- compile and run dna for number -> network address resolution.
- minimal VOIP server, perhaps with simplified network protocol, to
handle in/out call state. Porting asterisk might work, but is
- UI layer for user interaction, dialing, answering and configuration.

@_date: 2011-11-27 20:02:39
@_author: Jeremy Lakeman 
@_subject: [serval-project-dev] Why wireless mesh networks wonbt save us from censorship 
"Reason 1: Management is hard and expensive."
That's why we want a network that auto-discovers topology. And
provides easy to use debugging information to assist in placement of
additional nodes.
"Reason 2: Omni-directional antennas suck. ... Reason 3: Your RF
tricks wonbt help you here. ... Reason 4: Single-radio equipment
doesnbt work; multi-radio equipment is very expensive."
Fair enough. But we don't actually plan to build a wifi mesh network
covering the globe. One un-censored connection to the internet is
enough to join each little mesh network into the global internet.
Store and forward; and wandering nodes may be enough to enable *some*
communication in places where there isn't enough coverage yet for
real-time traffic. Some communication is better than none.
"Reason 5: Unplanned mesh networks break routing"
Well, partly. Sure you're going to use bandwidth in order to compute
routing paths. But I think this is not insurmountable. Definitely
needs to be more work in this area though to ensure you avoid routing
loops and black holes. And this is something that we are already
researching and plan to tackle further.
"unplanned wireless mesh networks never work at scale"
Yep, there's an "event horizon" issue. If you spend too much bandwidth
describing remote paths through the network, you'll have nothing left
for actual data. So we absolutely need to limit the distribution of
full topology information to ensure that local nodes can still
communicate even if the greater mesh network is practically infinite.
Beyond that limit you either interconnect via the internet, or we
invent some other high level structure, address prefix / numbering
There are 2 billion(-ish) people out there with no affordable access
to communications. This is absolutely a problem we should be
dedicating time to solve. Not just to "fight Internet censorship", but
to allow these people to be heard.
On Sun, Nov 27, 2011 at 7:17 PM, Alasdair Mclellan

@_date: 2012-12-14 08:12:46
@_author: Jeremy Lakeman 
@_subject: [serval-project-dev] Implementing a different routing protocol 
The real world isn't a flat 2d plain with no obstructions. But with
ACK's, NACK's and re-transmission it shouldn't matter too much if we
try to send a payload to a node that's now out of range. It should be
possible to detect broken network paths lazily with minimal impact to
throughput and latency. Plus when the network is busy, every data
packet can act as a beacon without wasting bandwidth.
How to you communicate the current geographical location of the destination?
How does the node that creates the payload work this out?
For that matter, how are we going to communicate the device's location
to the servald daemon?
What about devices that don't have a working location service? Or they
don't currently have the available power to run one?
But don't let that stop you from experimenting.
I would recommend you keep the existing messages and formats, and add
new message types that are sent at the same time, in the same packet.
Firstly, if the existing messages change, you don't need to maintain
your forked version. Secondly, network nodes that aren't implementing
your routing protocol will still be able to communicate in other ways.
Which is an important point. I want to make it easy to use servald as
a platform for future routing experiments such as this. We should aim
to build a single generic payload format and internal memory format
for tracking links to neighbours, while allowing the storage and
communication of extra protocol specific link information. It may be
useful to forward this protocol specific data even if we don't
understand it.
I think it's reasonable for the core of servald to build a map of all
2-hop neighbours, regardless of the routing approach being used. This
should allow us to limit unnecessary repetition of messages that need
to be flooded to all nodes, similar to olsr's MPR selection.
We can't assume all network links are symmetrical. At the physical
layer, a high powered transmission can be heard by nodes in a large
area, but that doesn't mean they can all transmit with enough power to
send a packet in the other direction. Localised interference can also
be a significant factor. The adhoc wifi standard has a number of flaws
that can prevent packets being delivered. Just because you can hear a
broadcast packet, doesn't mean you could receive a unicast one and
vice versa. And since Android doesn't support adhoc mode specifically,
it isn't tested at all by device manufacturers. And most android
devices deliberately drop all broadcast traffic when they enter power
saving modes, eg when the display powers off. The real world is a very
messy place.

@_date: 2012-12-17 09:28:42
@_author: Jeremy Lakeman 
@_subject: [serval-project-dev] Implementing a different routing protocol 
Rhizome doesn't route. It just floods, one hop at a time. Though now
that we have a rhizome transport built on MDP it would be possible to
transfer content directly over a number of hops.
Just because we have a novel tool doesn't make it a good fit for every
problem. Just because you have a good hammer, doesn't make every
problem a nail.

@_date: 2012-11-27 11:10:26
@_author: Jeremy Lakeman 
@_subject: [serval-project-dev] Re: Adding GPS location to IPv6 header 
Allocate an IPv6 private network range using a scheme like this;
Probably with around 36 bits (100m) of precision, leaving the rest of
the /64 to flag that it's private and geographically based.
Internet gateways have their own "real" /64. Internet traffic would be
routed to the correct gateway based on the network of the source
If each device uses the same 64bit host id on each network. Local mesh
route calculations can be based on a single main address per device,
with an additional routing entry added for each network we believe
that host should have.
A protocol like SCTP will also allow both parties to change networks
without needing to re-establish links.
Then the biggest scalability problem for routing packets world-wide to
an individual is a directory service for publishing and resolving
current network locations.

@_date: 2012-11-28 09:30:10
@_author: Jeremy Lakeman 
@_subject: [serval-project-dev] Implementing a different routing protocol 
Close, next_hop always points to our immediate neighbour that we
should forward the payload to. The payloads themselves are almost
always sent in broadcast packets which may contain multiple payloads
addressed to multiple neighbours. Including payloads that should be
flooded across the entire network.
See overlay_queue.c / overlay_stuff_packet() where we pull payloads
from our QOS queues and make a final decision about where the payload
should go next.
overlay_payload.c / overlay_frame_append_payload() is where the header
format is written into the packet.
overlay_packetformats.c / packetOkOverlay() is where those payloads
are parsed out of an incoming packet and processed or queued if they
are addressed to this node.
That's for connected client applications to send and receive messages.
If you want to pass some extra messages between daemons, the process
is a little different.
You can schedule an alarm to periodically queue a message, or you can
hook into every outgoing packet and write your payload just before
it's sent. eg overlay_tick_interface() is called for each interface
periodically to force an outgoing packet.
You can add a case to process the message in overlay_mdp.c /
There's a tree in memory, built in overlay_address.c as each node is discovered.
Yes, basically overlay_route.c is currently responsible for path
discovery. These decisions are written into the subscriber structure
so that none of the rest of the code needs to know the internal
details of how these routes were calculated.
I also have plans to implement a different routing protocol. I've been
trying to tease apart our current spaghetti code to separate the
different layers of the implementation as much as possible. This
should enable us to drop in a different path discovery process without
needing to change much of the rest of the daemon.
I've been doing some more work in that direction recently in a
currently private branch. Mainly to tweak the packet format, reducing
header overheads, so we can lock in the network byte format for
forward compatibility. I've still got a couple more changes to
implement though.
Neighbour discovery & link state detection need to be split out from
overlay_route.c and redesigned. But I'm not quite ready to start that
task yet. We don't have any bandwidth throttling yet. If you're
planning to send large volumes of data, any excessive latency added
from buffer bloat can cause havoc with route statistics. The list of
things I'd like to get done before I start replacing the routing layer
never seems to get any shorter.
You should also check out our testing framework, specifically
tests/routing. While the setup process for these tests is a little
verbose, and the file based network simulation is a bit different to
an actual adhoc mesh. It gives you a quick way to tell if you're on
the right track without needing to wander around with phones all the

@_date: 2012-10-30 16:26:10
@_author: Jeremy Lakeman 
@_subject: [serval-project-dev] Serval Mesh and ham radio 
So after a quick bit of research;
- HSMM is a custom radio protocol that exposes a standard IP network interface
- olsr is being used to mesh these devices together
- other devices may use the network through the LAN interface
So you would have a second access point that the serval phone can
connect to for internet and mesh traffic?
This doesn't sound like a network that serval can transparently
co-exist on. Yet.
Though we have done some initial work to support serval nodes
discovering each other over an olsr network, we haven't built any
protocol to exchange reach-ability information for other locally
connected serval phones. This is a reasonably large piece of work that
we don't have the time to build right now.
You could build servald for the mesh routers and run it on every
device in the network. Though our routing protocol is not as mature as
So this router is operating as a simple ethernet bridge?

@_date: 2013-02-13 11:35:09
@_author: Jeremy Lakeman 
@_subject: [serval-project-dev] Smart Phone Ad-Hoc Networks 
We are already aware of the SPAN project and have been communicating with them.

@_date: 2013-01-03 16:19:25
@_author: Jeremy Lakeman 
@_subject: [serval-project-dev] Encrypted rhizome bundles! 
I've just pushed the final changes to land encrypted payloads in
rhizome, covered by some appropriate test cases.
But don't try to use the latest serval-dna in the android batphone
application just yet. There's a breaking API change related to
extracting files that we need to deal with first. That's hopefully a
small job I can tackle tomorrow.

@_date: 2013-01-04 12:15:15
@_author: Jeremy Lakeman 
@_subject: [serval-project-dev] Re: Encrypted rhizome bundles! 
And done. We now have encrypted MeshMS messaging between android phones.
