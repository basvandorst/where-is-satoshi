
@_date: 1992-12-10 17:24:57
@_author: Mark 
@_subject: Questions about US/Canadian Laws about public encryption 
David Banisar  quotes:
One might ask that they prove it is encrypted and not merely garbage your
pumping down the line to defeat traffic analysis attacks. I dont think it's
illegal so send garbage down a line assuming your paying for it and noone
is being defrauded by your use of the medium.
If you have good enough cryptography they cant prove it's encrypted. If they
managed to decode it to something that looks like text but isnt the original
cleartext then they are just grabbing at straws and not 'decrypting'.
If you choose to put the "standard" bytes in front and behind every block to
make it *look* like it's encrypted with a well known algorithm thats your
To me proving it's encrypted amounts to decrypting it which is what your
trying to protect against. If they can prove the algorithm is weak then you
can just pay the fine and choose another method.
mark at coombs.anu.edu.au

@_date: 1992-12-10 17:31:26
@_author: Mark 
@_subject: Questions about US/Canadian Laws about public encryption 
On a discussion of devices one can attach to a phone line to encrypt
your comms:
So much for "ignorance of the law is no excuse". They want it both ways?
Secret laws and you obeying them? Sounds like the rules my roomies make up
as we play any board game. (aka cheating :)
mark at coombs.anu.edu.au

@_date: 1992-12-18 01:16:11
@_author: Mark 
@_subject: TEMPEST/Van Eyck data 
Ever realised that some things come along that just tickle your curiosity
nerve and you wont let go until your satisfied? Im sure there are
individuals and organisations out there that would love an excuse to shut
down lists of this type, especially considering the type of information and
the implications in the not too distant future if people start implementing
half the concepts that are presented here.
I would like to see indepth technical information, or at least pointers to
said information presented here. Does anyone know of mailing lists out there
that concentrate on levels of computer emissions and methods of diminishing
them to negliable amounts?
Where would one obtain copies of articles on the subject? I have saved the
article posted by treason at gnu as it does contain a lot of references which
give one something to go on. I commend him for posting it for it's
informational content. It wasnt his fault it may have contained obselete or
inaccurate information.
So, anyone have lists of books, periodicals, email lists or papers that discuss the topic of computer RF emissions and how to protect a machine
*AND* monitor the levels of others? mark at coombs.anu.edu.au
P.S. That NASA guy had better watch for list members waiting for the postie

@_date: 1992-12-23 13:19:37
@_author: Mark 
@_subject: Signing ascii text 
If the message contained a table of figures formatted and seperated with
spaces then that method would destroy the readability of the table. If the
file was processed to change tabs to spaces, according to your .exrc
settings, then the message would be cleared of any ambiguities from
differing lengths of tabs. This is assuming none of the forwarding mail
systems between parties replaces a sequence of spaces with a single tab.
I personally havent seen such behaviour, nor would I expect it. It makes
too many (bad) assumptions.
Trailing spaces should of course be nulled as they serve little purpose.
mark at coombs.anu.edu.au

@_date: 1992-11-16 01:23:23
@_author: Mark 
@_subject: Nuking CD's 
If you dont have small children about the house get a container of the
right acid so you slip your cd through the slot and 3 bubbles later it's

@_date: 1992-11-16 05:12:40
@_author: Mark 
@_subject: Cryptographer jailed for selling crypto to political opposition? 
Shades of Ross Perot.
Is it illegal to attempt to attack Iraq's computer systems if you were sitting
in your room one day and decided it was time to play havoc right back at them?
I realise the CIA etc would be involved in that sort of thing anyway but if a
private citizen decided to quietly have a dabble, and he wasnt spotted by the
Iraqi's at least, would many people get upset? There is the possibility of
encroaching on USA clandestine operations I guess...
Are there any precedents for this? Has anyone actually become aware of
attempts? :)

@_date: 1992-11-16 20:01:36
@_author: Mark 
@_subject: IP bouncers 
I have and use something along these lines. It was written by someone for
other purposes but it should be easy enough to port to this application.
It's rather inefficient at the moment unfortunately. I'll see what I can do
to it.

@_date: 1992-11-19 04:30:00
@_author: Mark 
@_subject: IP Bouncer.. source included. 
Ok an IP bouncer is something that runs on a host that basically accepts
connections on one port and redirects them to another specified host and port.
The one below is for tcp connections but it could also be for udp with
a little work. I actually have the code for a 'server' version of this that
you connect to it, tell it which host you want and then it opens a connection to it. It's on another machine at the moment which is down.
I had the sent to me via IRC a while ago and have used it off and on. Ive
been meaning to fine tune it a bit as it's supposed to chew CPU a bit...
-------cut here--------cut here--------cut here---------cut here-------------
   written by "Hal-9000".  Much of this package was developed by Richard
   Stephens and my thanks go to "Xanadude" for providing me with that
   section.
   To compile, type "cc -O -s telserv.c -o telserv". */
        SERV_TCP_PORT 12345 /* port I'll listen for connections on */
 REM_HOST_ADDR "128.128.128.7" /* host I will bounce to */
 REM_TCP_PORT 23               /* port I will bounce to */
  int sockfd, newsockfd, clilen, childpid;
  struct sockaddr_in  cli_addr, serv_addr;
  sockfd = socket(AF_INET, SOCK_STREAM, 0);
  bzero((char *) &serv_addr, sizeof(serv_addr));
  serv_addr.sin_family      = AF_INET;
  serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
  serv_addr.sin_port        = htons(SERV_TCP_PORT);
  bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr));
  listen(sockfd, 5);
  while (1) {
    clilen = sizeof(cli_addr);
    newsockfd=accept(sockfd, (struct sockaddr *) &cli_addr, &clilen);
    fcntl(newsockfd,F_SETFL,O_NDELAY);
    childpid = fork();
    if (childpid == 0) {         /* child process */
      close(sockfd);             /* close original socket */
      telcli(newsockfd);         /* process the request */
      exit(0);
    }
    close(newsockfd);            /* parent process */
    wait(0);
    }
  }
  int servsockfd;
  struct sockaddr_in  serv_addr;
  bzero((char *) &serv_addr, sizeof(serv_addr));
  serv_addr.sin_family       = AF_INET;
  serv_addr.sin_addr.s_addr  = inet_addr(REM_HOST_ADDR);
  serv_addr.sin_port         = htons(REM_TCP_PORT);
  servsockfd = socket(AF_INET, SOCK_STREAM, 0);
  connect(servsockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr));
  fcntl(servsockfd,F_SETFL,O_NDELAY);
  communicate(servsockfd,clisockfd);
  close(servsockfd);
  exit(0);
communicate(servsockfd,clisockfd)  {
   char rec[1];
   int num;
   extern int errno;
   while (1) {
     num=read(servsockfd,rec,1);
     if (num==1) write(clisockfd,rec,1);
     num=read(clisockfd,rec,1);
     }

@_date: 1992-11-19 05:43:04
@_author: Mark 
@_subject: How far is to far? 
Maybe it's not in the spirit of this mailing group but what of the question
of purposeful abuse of the anon mailers/newsposters? Say for instance some
person posts either a sh*tload of garbage to every known group, flooding
the USENET or a more personal attack whereby they send out anonymously information that was so fundamentally personal to someone they could
possibly react very badly....
What if someone posted some top secret information and the various three
letter acronyms all went out for someone's blood.
As a few people have mentioned they would *like* the opportunity to use
an anon system but the initial step of creating and running it isnt so
appealing due to the fundamental dangers of it.
Most people would respect such systems but you find one really rotten or
immature loser that will use it for there own anti-social ends.
mark at coombs.anu.edu.au
mark at gnu.ai.mit.edu
markm at rmit.edu.au

@_date: 1992-11-25 05:24:15
@_author: Mark 
@_subject: Secure PK swapping.. what are the methods? 
Below is a letter Ive sent to a person designing a communications system
similar to IRC but designed with the ability to be anonymous and as secure
as possible. Further details will be announced soon when it's stable.
----End of Letter----------------End of Letter----------------
Now what Im curious about is any other methods of secure key exchange where
the exchange mid point may be lying about the keys, the hosts and the ports.
Assume each person knows the others 'style' etc. How does one get the real keys to each other with an unreliable "medium"? (It might slip in it's PK).
Assume that they havent previously organised a key exchange.
Replies to me or the list.. (but not both please.. my mbox is busy enuff :)
mark at coombs.anu.edu.au

@_date: 1992-11-25 16:23:55
@_author: Mark 
@_subject: Electronic Banking 
So *thats* why nnacct is there :)... Does the tax office get an email from each news admin every fiscal year? :) So they can charge us for services rendered by the net?
With regard to digital cash, I have yet to read (or have forgotten the
definition) the implementation. What I preceive it as is a form of IOU's
that if someone does something for you then you send them an applicable
amount of credits. To simplify it a bank could issue credits and people
could trade in them, sending them back and forth, each digitally encrypted
and based on the amount of credits in each persons bank account. I assume each transaction would be validated through a bank to ensure the credit is
unique and the right value?
  Customer gets suppliers account number from the supplier encrypted with
  the banks public key.  They send it and the amount of cash to transfer to
  the bank all encrypted with the public key of the bank.   The bank decrypts, gets the amount and decrypts the destination account.
  It then sends a message to the supplier saying that amount has been
  deposited in their account and the transaction between the customer and
  supplier can be completed. Otherwise it tells the supplier (and customer)
  there is a problem with insufficient funds or incorrect data.
  The cash may be held in ether until both parties confirm the transaction
  has been completed. If the commodity is electronic data the supplier may
  send to the bank a transaction private key encrypted with the customers
  public key so that the customer cant cheat the supplier as he has to ask
  the bank for the information to access his/her data which has been encrypted
  with the other half of the transaction keypair. That way the bank knows the
  transaction has been completed and it finishes the transfer of funds and
  sends the transaction private key to the customer.
  Each commodity, especially if it was physical might be serialized so there
  could be proof that the customer purchased that item with that SN. If the
  merchant was a crook the audit trail would catch him... the customer wouldnt
  be able to cheat as the merchant wouldnt have to release the goods (as is
  the situation now in Real Life (tm)) until the funds were paid.
  Issues of Big Brother spying on your transactions apply here but I guess
  one could always use a psuedonym for the electronic commodities and a
  postal box paid for with digital anonymous cash for the physical stuff..
  (assuming it was mail order... you wont have to give a name for store
   buying, just a bank public key and your encrypted account number.)
  Someone might even want to set up a physical forwarding company which   merely acts as a buffer for people to increase their privacy. Paid for   anonymously and digitally. I havent heard of any companies specialising in
  this type of service to date.
This make any sense? Has it been said before?
mark at coombs.anu.edu.au

@_date: 1992-11-28 04:39:57
@_author: Mark 
@_subject: comments on Don's "Cypher Bank" 
richard childers (rchilder at us.oracle.com) :
It is said information should be free... however, if someone was (and someone
undoubtedly would), to monitor the bank(s) they would probably see accounts
going up and down by various amounts and it should be possible to track transactions between identities. This, coupled with widespread traffic
analysis (assuming no padding had occured) would allow someone to deduce that
Alice had asked something of Bob and had then paid him. This probably isnt particularly inviting to the majority to know that your funds could be traced
very anonymously and that patterns could be formulated... for instance three
times a month various amounts are deducted from your account and those exact
same amounts appear in an account known to be owned by a 1-900 phone sex number. That would have an affect on your reputation, (if not your marriage
if your True Name was known), if it was published. (The 1-900's identity
could be discovered simply by someone using the service and noting what
psuedonym took your funds, or if that was changed, noting which account
increased by your $127.30. (It was an intense call I guess :)
If you wish to entertain such a testbed financial system be very careful with
any decision made and work through each possible consequence. Most people I
think would prefer to remain anonymous. I know I would, in the long run.
mark at coombs.anu.edu.au

@_date: 1992-11-29 14:20:56
@_author: Mark 
@_subject: Secure PK swapping.. what are the methods? 
Since Im not sure this got through to the list last time I'll resend. Certainly I havent had any pointers to where to find the information I

@_date: 1992-11-30 15:27:53
@_author: Mark 
@_subject: Offshore banking.. 
With respect to offshore banking, what about the legislation governing the
export of money from the coutry? Here in Australia if we send an amount of
money overseas then we have to pay a tax/levy of an amount based on the
size of the funds being sent offshore.
If we start snailmailing certified envelopes full of money overseas then
someone will want to know about it so they can tax us. Im fairly sure there wouldnt be a problem (from the governemnt) with shuffling your funds from offshore bank to offshore bank. If encrypted
money was going in and out all the time from a (legal) onshore bank that
accepted digital transactions to an offshore one, then you would face the
same export laws.
How do the banks handle this when they send fifteen trillion overseas to
have their money working for them while we all sleep at night....?
mark at coombs.anu.edu.au

@_date: 1992-11-30 19:38:20
@_author: Mark 
@_subject: Why not just do it? 
With all the talk of banking regulations etc with regard to messing
with the monetary system, why dont we just create a test system where
everyone emails in an amount that they are prepared to coughup if they really had to, but at the moment dont (have to).
Then we can go ahead with the digital "cash" scenario and not be
governed by the banking/security laws of any country because no real
money is involved. The object is to get a system going, find flaws, create software and protocols and basically experiment with it. The issue of actual cold hard cash is, to me, a not important. After all it's just numbers.
Eric volunteered to do this earlier and, if he still wishes to, I'd be
willing to participate in it. Maybe he doesnt have the benefit of a big
cushy bank trust account earning him intrest for his work, but I dont
think that was a consideration for him anyway.
mark at coombs.anu.edu.au

@_date: 1992-10-20 02:19:05
@_author: Mark 
@_subject: Home security... 
What's the best sources for faraday cages and TEMPEST etc? And does anyone
out there implement anything of this type of security at home to protect
against monitoring? The cost of such an exercise would be rather prohibitive
to say the least.
Just curious..

@_date: 1992-10-28 18:09:15
@_author: Mark 
@_subject: How far would this extend... 
With regard to the FBI bill, the definition of electronic communication
provider is rather vague IMHO. It seems to cover a BBS, any unix site
(or equiv) etc.
(I deleted the article so I cant quote it)
Anyway if the above is true will this mean all machines that electronic
communication traverses have to have a 'backdoor' so the gov can sit in
their offices and run through the mail spool as root? :)
Or log into any BBS and do the same?
There hasnt been any talk of it as such, probably because they can do it
fairly easily anyhow, but it just seems like another loophole in their
(the FBI's) favour.
_Sometimes_ I'm glad Im an aussie.

@_date: 1993-04-07 14:15:29
@_author: Mark 
@_subject: Real-time BBS Encryption?? 
You might want to look at the link.tar.Z program newsham at wiliki.eng.hawaii.edu
wrote. THe server is currently unix based but it should be transportable.
It uses pgp to swap des session key and happily talks away. There are still
some bugs and when he has the time they will be taken care of. The client is
written for an amiga at the moment, I havent had the opportunity to do the ibm
port yet. Contact him at the above address. He is busy with studies but you
might get some joy from emailing him.
Hope this helps
mark at coombs.anu.edu.au

@_date: 1993-04-13 18:17:29
@_author: Mark 
@_subject: alt.whistleblowers 
We're sposed to be anarchists right? :) 'sides alt.* groups come out daily
with little or no discussion. Ours wont rock boats, at least in it's creation,
the content is a different story. Personally I hope it doesnt degenrate into a
narc fest for people who have grudges against people... that would be sad..
I vote to just make it. Not all will like it, but then they are maybe the ones
who will feature in it (great way to shut them up :).
mark at coombs.anu.edu.au

@_date: 1993-04-20 22:30:50
@_author: Mark 
@_subject: Just a thought... 
Whilst being heavily opposed to the chip although less affected by it since
I dont reside on US soil, one useful purpose of it would to exploit the
functions of it to send your pre-encrypted data through it and have it come
out the other end in the same form, thus using it's protocols of retransmission
and error correction. Using the encryption part of it isnt worth considering
due to the real lack of data integrity if (as?) the TLA's have backdoors.
Basically mooch it's good points and ignore the bad points as your data wont
be channeled to the phone in cleartext anyway.
(This isnt an advocacy of the damn thing, just a note that it has SOME
functionality for those that wont use the encryption functions).
mark at coombs.anu.edu.au

@_date: 1993-08-10 18:42:10
@_author: Mark 
@_subject: Using a 'telserv' program to redirect mail 
Um guys, it was already posted here over a year ago by myself and another
person. It's a simple port bouncer and not that hard to write. treason: just post it. it's no big secret.
If anyone is in a hurry it's been up for ftp as /pub/perl/telserv.c on
coombs.anu.edu.au [150.203.76.2] since Nov 92. It's still there.
(Note it's C code not perl, thats just the tree I maintain).

@_date: 1993-02-21 14:19:32
@_author: Mark 
@_subject: Sources for perl code 
On coombs.anu.edu.au in /pub/perl/misc/perl.code.sources there is a list
of places to get perl source/binaries for Ataris, IBMs, Macs, and VMS.
Unix is available everywhere in the GNU sections of ftp archives.
Also there is a large number of scripts in /pub/perl/scripts.
See the README file for usage details and for the European mirror site.
The INDEX file lists each script and gives a short description.
Hope this helps,
mark at coombs.anu.edu.au

@_date: 1993-02-22 22:29:37
@_author: Mark 
@_subject: Unbreakable MacHD encryption 
I have used a product in the past called Hard Disk Deadbolt. It has from
memory three encryption methods; quick-and-nasty hard-disk-deadbolt's-own
(no idea on the security of this one) and DES. The first is fastest for
stuff you dont want anyone to read but isnt super secret, whilst DES takes
the longest.
I liked the package all things considered. It was friendly, files didnt
change size and it was speedy enough for my uses.
Availability is unknown at this stage, ask in comp.sys.mac.* if you want.
mark at coombs.anu.edu.au

@_date: 1993-02-22 23:54:15
@_author: Mark 
@_subject: anon.penet.fi remailers 
This, unfortunately, is true. I *have* to use a remailer to hide any
anon.penet.fi alias I have or the sender will see it and know I am
(for eg) anon1234 at penet.
I balk at Yet-More-F******-Header-Lines (YMFHL) but a _possible_ patch
is to have a:
X-Show-My-Anon: yes|no       (in the header),
X-Show-My-Anon: yes|no       (in the body)
addition so people who reply to a message from penet can feed their real email
address through the system rather than having it bounced to the recipient as
their anon id.  This would require either a smart mailer, checking exactly who
the orig letter was addressed to (your anon or your real address) and
inserting the line as appropriate. It *should* be automatic actually. All it
has to do is check a local list of your anon addressed and if someone has
mailed it then alter the above line as needed.
This raises question of the security of local lists of your anon addrs of
course.. but you get the idea..
(BTW I saw someone's .sig where they *advertised* their anon id on USENET.
 Presumably this was because he thought thats what you had to do so others
 could email them anonomously... obviously he wont be a whistle blower :)
mark at coombs.anu.edu.au

@_date: 1993-02-24 23:05:32
@_author: Mark 
@_subject: a project for those who like it 
Hmmm, are you talking about '4m'? That is a similarly goaled communication
system as well. Currently it exists in plain text format, between the clients
and the (as of today, five) servers. The system has always been destined to
have encryption built into it, from triple des and PK for the key
To get into it quickly ftp /pub/misc/4m-212.tar.Z from ftp.santafe.edu and
install. It runs on suns, bsd, aix and similar. I have an hpux port done by
someone if it is required.
It would seem smarter to develop an already existing and debugged instead of
reinventing the wheel.
Contact chasin at santafe.edu for details.
mark at coombs.anu.edu.au

@_date: 1993-07-05 14:55:59
@_author: Mark 
@_subject: Non-cypherpunk question. 
I use elm to read the list and it barfs on metamail messages as metamail hasnt
been installed. What i did was to get cat.c and remove the arg checks so it
didnt try to interpret the metamail switches elm piped to it and to not report
missing files. Then it just catted it's arguements so /tmp/mail-aa0127 is catted
and piped through less so i am able to read metamail (which are just nomal messages
with a different Content-Type: line int he header anyway). Bit of a kludge but it
mark at coombs.anu.edu.au

@_date: 1993-06-02 02:39:39
@_author: Mark 
@_subject: FYI: White House Mail 
Hmm, 10 bucks says some larrikin sends fakemail from PRESIDENT to
VICE.PRESIDENT asking him 'what this little red button does' etc.
Though in real.life I suspect 10 press secretaries sitting behind
the mail alias. They're going to need them.
Lets hope no one is stupid enough to try busting into there...
mark at coombs.anu.edu.au

@_date: 1993-06-02 03:56:14
@_author: Mark 
@_subject: Crypto anarchy in a VW? (not the bug) 
Heh, I have a system liek this, designed by Viglen in the UK. It was/is originally from the BBC micro to allow easy use of swapping over 'sideways'
ROMS instead of opening the case. It's basically a ribbon cable with a 28way rom socket on the end with a edge connector socket on the other. Each ROM is
enclosed in it's own sturdy tiny black package with an edge connector that
slots into the socket that is mounted in the 'ashtray' of the Beeb.
You could easily copy the idea with a rom socket, a length of ribbon cable
and a ZIF socket to allow easy usage. The Viglen has pin protection so you
dont spike the thing, so it's able to be used on the fly without power
One thing about ROM's, they're faster than disks....easier to hide too :)
Me either, apart from TEMPEST issues...Linux comes with slot in file system
modules (as detailed in a letter to Jim) that you can easily adapt to your
own uses. Ive been playing around with this idea for a while. Adding a
desfs(tm) (me :) to a linux kernel is not going to be that hard I think..
(touch wood).
mark at coombs.anu.edu.au
"liek", "smiel" and "soar" are derivatives of JenSpeak(tm). Spread the word.

@_date: 1993-06-02 18:24:26
@_author: Mark 
@_subject: Term software development/design 
Those of you with a 386 or greater and over 40Mb Hd (most of the
pc's these days are usable) might want to take a look at running
linux/386bsd/netbsd at home and then running term(1). It's a
program with it's own packetising, compression of data (which is
good for a quick and nasty anti-tap system) and you can telnet, rsh, ftp, finger etc all from the unix command line of your home
machine. Uploads etc can all be done at the same time as you read
mail on a remote host.
the lastest version is term107.tar.z and should be avaliable from
most archie sites. It has  for suns, nexts, hps, linux etc.
When i find the guy who wrote the telnet client for it I'll probably
add des encryption to it.
The above is for plain modem usage, it's a semi tcp link at home and
you can dial anywhere and link up in seconds, no special system file
changes, just compile the remote binary and you're away. If you're
just using the dialup host as a bouncer then all that is running is
one innocuous looking binary, even though you might have several
ftp's and telnets etc running at once. Honestly it's an admins
Linux etc also has slip and inet options if you want to explore
those. The only problems I find are people being unable to listen
(usefully) to your sessions and killing the line :)
Most of the tools are written I find, all thats needed is the adding
of encryption to them for a totally secure session. No need to write
another term program, just use whats out there.
mark at coombs.anu.edu.au

@_date: 1993-06-03 17:15:10
@_author: Mark 
@_subject: Pc environ (fwd) 
For those others that insist on living in 640K... :)
Forwarded message:

@_date: 1993-06-03 19:53:30
@_author: Mark 
@_subject: CryptoStacker, long term vision 
This problem is most easily solved by copying the entire partion/file
that is encrypted as blocks. These blocks are size according to the
destination media. If you use floppies you break the encrypted fs/file
into (e.g.) 1.44 meg chunks, if you use tape you can throw the whole
block at the media, similarly with another hardisk.
The unix/linux/386bsd 'dd' program is especially useful for this purpose
and I assume there are similar utils for dos.
For replacement you simply dump the whole lot back as one encrypted file
This method should be faster than grabbing individual files and backing
them up as the program just has to seek to a specified place and start
reading a defined amount of [encrypted] data.
mark at coombs.anu.edu.au

@_date: 1993-06-06 09:50:31
@_author: Mark 
@_subject: CryptoStacker 
How does someone no on compu$erve get access to these? archie didnt
report anything.
(Want to peek at the cphant.zip file)
mark at cheops.anu.edu.au

@_date: 1993-06-08 18:02:02
@_author: Mark 
@_subject: Statement of dissatisfaction with your recent efforts (fwd) 
Probably shouldnt have, but they get on my goat.
Forwarded message:

@_date: 1993-06-11 20:56:41
@_author: Mark 
@_subject: Mail logging 
Well, I hate to point out the obvious but can we organise with the
list maintainer to have our mail routed through random machines until
it gets to us? I'd only recommend this for the more email aware members
as it might prove confusing. Also, to save my own sanity and others
certain header munglings might be desirable to ensure that the mail is
still filterable. I'd suggest either an addition to the remailer scripts
to allow a predefined header line through, or the Subject: line of each
message is prefixed with CRYPTO: so the end users can still filter the
messages as they now do.
Currently I use 'procmail' to filter out various things and it works on
the contents of the mail header as so:
# Filtering for cypherpunks
:2                                          # Two 'if' clauses
(^To:.*cypherpunks at toad.com.*|^Cc: .*cypherpunks at toad.com.*)
(^Subject: .*(UNSUBSCRIBE|nsubscribe).*)
If we were to route all the mail through remailers I would lose the
functionality of filtering as I wouldnt know where the email was
coming from, nor would I be able to know it was cypherpunks mail until
I read the message body. thats why a Subject: line change or a modification
to the remailer scripts (if needed) should be made.
Assuming the above was made, all the maintainer would have to do is change
my mark at coombs.anu.edu.au line in the alias file to a:
where 'random-remail' is a short program that scans a list of remailers
and randomly selects some, puts the addresses and remail triggers into a
file, appends the message and changes the "Subject: blah" line to
"Subject: CRYPTO: blah". 'random-pgp-remail' does the same and encrypts the
whole message before sending, possibly encrypting again a few times with
remailer keys.
This approach would (dramatically :) increase the remailer traffic to levels
where mail re-ordering is possible. Padding would be the next step, add the
lines on the end to bring the message to 512 bytes, 1024 bytes, 2048 bytes or
greater. Maybe pad all messages to the nearest 1024 bytes? (see below for a
method :)
The only problem I can see after the programs are debugged etc is the extra
overhead on toad.com, wther it's a non encrypted mail out or not. But if that
is acceptable to the maintainer in the intrests of giving remailer operators
some fodder then we can implement it
I dont see any of the random-[pgp-]remailer programs being longer than 30 or
40 (perl script) lines. I'd write them myself if I could get some mail
aliases installed on this host. Admittedly they aren't essential but I'd
like them for testing purposes.
mark at coombs.anu.edu.au
PADDING PADDING PADDING PADDING PADDING PADDING PADDING PADDING PADDING
PADDING PADDING PADDING PADDING PADDING PADDING PADDING PADDING PADDING
PADDING PADDING PADDING PADDING PADDING PADDING PADDING PADDING PADDING
PADDING PADDING PADDING PADDING PADDING PADDING PADDING PADDING PADDING
PADDING PADDING PADDING PADDING PADDING PADDING PADDING PADDING PADDING
PADDING PADDING PADDING PADDING PADDING PADDING PADDING PADDING PADDING
PADDING PA       <---- end of padding to make this 2048 bytes long

@_date: 1993-05-25 16:39:51
@_author: Mark 
@_subject: Say again? 
Wouldnt the NSA just get a feed to their internet machines, say maybe
dockmaster.ncsc.mil? All they would have to pay for is the line, which is
there anyway. No need to buy tapes. Makes more sense to me. I assume they
have news readers on Multics systems :)
mark at coombs.anu.edu.au

@_date: 1993-09-01 20:36:49
@_author: Mark 
@_subject: general purpose telnet bouncer. 
Several people have expressed interest in a utility such as this. It's
existed for several years but Ive recently decided to fix it up into a
releasable condition.
Share and enjoy.
flames to /dev/null
mark at cairo.anu.edu.au
---------------------- cut here ----------------------------
     written by "Hal-9000". Much of that package was developed by Richard
     Stephens and his thanks go to "Xanadude" for providing him with that
     section. Performance fix by Darren Reed. */
   on the fly. - Mark 31st Aug 93
   Compiled and tested on:
       HPUX 9.01 9000/700 series        NeXTStep 3.1 NeXT 68040
   To compile, type "cc -O -s ts2.c -o ts2".
   MY_PASSWORD and SERV_TCP_PORT are all that is required to be altered. */
    MY_PASSWORD    "pass"
    SERV_TCP_PORT  12345    /* port I'll listen for connections on */
                QLEN           5
char sbuf[2048], cbuf[2048];
extern int errno;
extern char *sys_errlist[];
void reaper();
int main();
void telcli();
int main(argc, argv)
int argc;
char *argv[];
    int srv_fd, rem_fd, rem_len, opt = 1;
    struct sockaddr_in rem_addr, srv_addr;
    bzero((char *) &rem_addr, sizeof(rem_addr));
    bzero((char *) &srv_addr, sizeof(srv_addr));
    srv_addr.sin_family = AF_INET;
    srv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    srv_addr.sin_port = htons(SERV_TCP_PORT);
    srv_fd = socket(PF_INET, SOCK_STREAM, 0);
    if (bind(srv_fd, (struct sockaddr *) &srv_addr, sizeof(srv_addr)) == -1) {
        perror("bind");
        exit(-1);
    }
    listen(srv_fd, QLEN);
    close(0); close(1); close(2);
 TIOCNOTTY
    if ((rem_fd = open("/dev/tty", O_RDWR)) >= 0) {
        ioctl(rem_fd, TIOCNOTTY, (char *)0);
        close(rem_fd);
    }
    if (fork()) exit(0);
    while (1) {
    rem_len = sizeof(rem_addr);
        rem_fd=accept(srv_fd, (struct sockaddr *) &rem_addr, &rem_len);
        if (rem_fd < 0) {
            if (errno == EINTR) continue;
            exit(-1);
        }
        switch(fork()) {
        case 0:                             /* child process */
            close(srv_fd);                  /* close original socket */
            telcli(rem_fd);                 /* process the request */
            close(rem_fd);
            exit(0);
            break;
        default:             close(rem_fd);                  /* parent process */
            if (fork()) exit(0);            /* let init worry about children */
            break;
        case -1:
            fprintf(stderr, "\n\rfork: %s\n\r", sys_errlist[errno]);
            break;
        }
    }
void telcli(source)
int source;
    int dest;
    int found;
    struct sockaddr_in sa;
    struct hostent *hp;
    struct servent *sp;
    char gethost[100];
    char getport[100];
    char string[100];
    bzero(gethost, 100);
    sprintf(string, "Password: ");
    write(source, string, strlen(string));
    read(source, gethost, 100);
    gethost[(strlen(gethost)-2)] = '\0'; /* kludge alert - kill the \r\n */
    if (strcmp(gethost, MY_PASSWORD) != 0) {
        sprintf(string, "Wrong password, got %s.\n", gethost);
        write(source, string, strlen(string));
        close(source);
        exit(0);
    }
    do {
        sprintf(string, "Host: ");
        write(source, string, strlen(string));
        read(source, gethost, 100);
        gethost[(strlen(gethost)-2)] = '\0';
        hp = gethostbyname(gethost);
        if (hp) {
            found++;
 !defined(h_addr)        /* In 4.3, this is a  */
 defined(hpux) || defined(NeXT) || defined(ultrix) || defined(POSIX)
            memcpy((caddr_t)&sa.sin_addr, hp->h_addr_list[0], hp->h_length);
            bcopy(hp->h_addr_list[0], &sa.sin_addr, hp->h_length);
 /* defined(h_addr) */
 defined(hpux) || defined(NeXT) || defined(ultrix) || defined(POSIX)
            memcpy((caddr_t)&sa.sin_addr, hp->h_addr, hp->h_length);
            bcopy(hp->h_addr, &sa.sin_addr, hp->h_length);
 /* defined(h_addr) */
            sprintf(string, "Found address for %s\n", hp->h_name);
            write(source, string, strlen(string));
        } else {
            if (inet_addr(gethost) == -1) {
                found = 0;
                sprintf(string, "Didnt find address for %s\n", gethost);
                write(source, string, strlen(string));
            } else {
                found++;
                sa.sin_addr.s_addr = inet_addr(gethost);
            }
        }
    } while (!found);
    sa.sin_family = AF_INET;
    sprintf(string, "Port: ");
    write(source, string, strlen(string));
    read(source, getport, 100);
    gethost[(strlen(getport)-2)] = '\0';
    sa.sin_port = htons((unsigned) atoi(getport));
    if (sa.sin_port == 0) {
        sp = getservbyname(getport, "tcp");
        if (sp)
            sa.sin_port = sp->s_port;
        else {
            sprintf(string, "%s: bad port number\n", getport);
            write(source, string, strlen(string));
            return;
        }
    }
    sprintf(string, "Trying %s...\n", (char *) inet_ntoa(sa.sin_addr));
    write(source, string, strlen(string));
    if ((dest = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        perror("telcli: socket");
        exit(1);
    }
    connect(dest, (struct sockaddr *) &sa, sizeof(sa));
    sprintf(string, "Connected to %s port %d...\n", inet_ntoa(sa.sin_addr),
                                                          ntohs(sa.sin_port));
    write(source, string, strlen(string));
 FNDELAY
    fcntl(source,F_SETFL,fcntl(source,F_GETFL,0)|FNDELAY);
    fcntl(dest,F_SETFL,fcntl(dest,F_GETFL,0)|FNDELAY);
    fcntl(source,F_SETFL,O_NDELAY);
    fcntl(dest,F_SETFL,O_NDELAY);
    communicate(dest,source);
    close(dest);
    exit(0);
communicate(sfd,cfd)    {
    char *chead, *ctail, *shead, *stail;
    int num, nfd, spos, cpos;
    extern int errno;
    fd_set rd, wr;
    chead = ctail = cbuf;
    cpos = 0;
    shead = stail = sbuf;
    spos = 0;
    while (1) {
        FD_ZERO(&rd);
        FD_ZERO(≀);
        if (spos < sizeof(sbuf)-1) FD_SET(sfd, &rd);
        if (ctail > chead) FD_SET(sfd, ≀);
        if (cpos < sizeof(cbuf)-1) FD_SET(cfd, &rd);
        if (stail > shead) FD_SET(cfd, ≀);
        nfd = select(256, &rd, ≀, 0, 0);
        if (nfd <= 0) continue;
        if (FD_ISSET(sfd, &rd)) {
            num=read(sfd,stail,sizeof(sbuf)-spos);
            if ((num==-1) && (errno != EWOULDBLOCK)) return;
            if (num==0) return;
            if (num>0) {
                spos += num;
                stail += num;
                if (!--nfd) continue;
            }
        }
        if (FD_ISSET(cfd, &rd)) {
            num=read(cfd,ctail,sizeof(cbuf)-cpos);
            if ((num==-1) && (errno != EWOULDBLOCK)) return;
            if (num==0) return;
            if (num>0) {
                cpos += num;
                ctail += num;
                if (!--nfd) continue;
            }
        }
        if (FD_ISSET(sfd, ≀)) {
            num=write(sfd,chead,ctail-chead);
            if ((num==-1) && (errno != EWOULDBLOCK)) return;
            if (num>0) {
                chead += num;
                if (chead == ctail) {
                    chead = ctail = cbuf;
                    cpos = 0;
                }
                if (!--nfd) continue;
            }
        }
        if (FD_ISSET(cfd, ≀)) {
            num=write(cfd,shead,stail-shead);
            if ((num==-1) && (errno != EWOULDBLOCK)) return;
            if (num>0) {
                shead += num;
                if (shead == stail) {
                    shead = stail = sbuf;
                    spos = 0;
                }
                if (!--nfd) continue;
            }
        }
    }
----------- end of file ------ cut here -------
