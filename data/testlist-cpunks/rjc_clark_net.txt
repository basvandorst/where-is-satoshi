
@_date: 1995-08-01 09:15:27
@_author: Ray Cromwell 
@_subject: a hole in PGP 
That's a neat metaphor, but it doesn't always apply. It shouldn't
apply to algorithms which are primitive recursive. Elementary
algorithms like multiprecision add, sub, multiply, divide, modmult,
and modexp (the basis of public key encryption) are all provably
correct and all terminate. (the basis is polynomial operators over a
ring) It is possible to verify the implementation (assuming the
correctness of the compiler). Now there could be a "factoring"
trapdoor in RSA, but that's a trapdoor not in the implementation of
PGP, but in the algorithm itself. RSA-in-4-lines-perl is probably
provably correct.  To guard against trapdoors in PGP, you should
verify the correctness of the PRNG, Key Generator, and that no private
key bits or session key bits are leaked. I would suspect this could be
difficult, but approximations could be determined to within a high
degree of confidence.

@_date: 1995-08-01 12:25:27
@_author: Ray Cromwell 
@_subject: Provably Correct Crypto? 
[Tim responds to my note on "provably correct implementation"}
  What I meant by my message is in some circumstances, an implementation
can be proven correct (i.e. to do what it says it does correctly) What
I mean by implementation is the source at the highest level, not the
module dependencies which are abstractly disconnected from the application.
(e.g. if a multiprecision math library that comes with the operating
system is used by PGP, the source to PGP could be said to be "trapdoor free"
even if the math library has an NSA monitoring function built into it)
 Each layer of course relies on the correctness of the layer beneath it, much
like a theorem proof relies on the proof of the statements that makes it
up. Thus, RSA-in-4-lines can be observed to be a correct implementation
of RSA without any trapdoors (like secretly storing or leaking private
key bits) at the level of its source code. Of course, the Perl interpreter
itself would have to be proven correct, but we assume that no RSA trap
doors have been put into perl because perl was available long before
PGP and RSA-in-4-lines perl and is widely distributed. The probability
of a trapdoor in perl is small.
The hierarchy looks like this:
RSA-in-4-lines :: DEPENDS_ON_CORRECTNESS_OF { Perl, DC, RSA_Algorithms }
Perl :: DEPENDS_ON_CORRECTNESS_OF { C, Unix, Perl_Algorithms }
DC :: DEPENDS_ON_CORRECTNESS_OF { C, Unix, DC_Algorithms }
C :: DEPENDS_ON_CORRECTNESS_OF { C_compiler } C_compiler :: DEPENDS_ON_CORRECTNESS_OF { Assembler }
Assembler :: DEPENDS_ON_CORRECTNESS_OF { instruction_set }
instruction_set :: DEPENDS_ON_CORRECTNESS_OF { hardware }
Now even if it were possible to prove the correctness of all those layers
(which I find doubtful. Some kind of Goedel/Turing limitation is going to turn
up somewhere), what if the 'hardware' isn't correct. (e.g. Pentium bug)
There could be a one-in-a-zillion bug that randomly leaks keybits. IMHO, there's no sense in worrying about stuff like this. If your data
is so valuable that you need absolute theoretical security, use a one-time-pad with a simple redundant provably secure device
(also shielded from TEMPEST attacks), and have the thing implanted
in your skull. ;-)

@_date: 1995-08-03 08:10:59
@_author: Ray Cromwell 
@_subject: Transport Layer Security (Was: Re: "Cypherpunks Write Code" as a Putdown) 
It seems to me that many of these attacks can be defeated by anti-spam
routines (with exponential time buildup) and economic mechanisms. That is,
you pay "credits", which can possibly be based on real money, for each
access. When you use them up, you must contact the service to request more.
Coupled with authentication, this makes DoS tough because you must request
more credits for your ID, however, if you use them up quicker than
average, you must justify why you need them again so soon.
  Anti-spam routines have been successful on IRC and MUDS against DoS. Each
"request" is measured against the time since the last request. If the time
is less than the delay, the request is denied (and with exponential
buildup, you double the delay so that even "needling" attacks where
a DoS attack finds your delay and transmits just under that, has trouble)
If the resource is disk space, or network memory buffers, or whatever, you
impose similar timing sensitive constraints.
  This covers most spam based DoS.

@_date: 1995-08-03 22:17:39
@_author: Ray Cromwell 
@_subject: Java, Netscape, OpenDoc, and Babel 
Uh, no. There is no difference between this and Java. File I/O
operations can be added to any Safe-TCL restricted interpreter
via "declareharmless". The trusted and untrusted interpreters
don't run in separate process spaces, nor is it chrooted(). Perry's
criteria is that a failure can not result in the interpreter gaining
priveleges it doesn't have. In Safe-TCL this is possible because there
is no protection between the trusted and untrusted interpreters. It's
possible that a bug could cause the interpreter to use an operating
system privelege the model clearly wasn't supposed to have.
(e.g., what if, by chance, the restricted and unresstricted interpreter
pointers get swapped or given to a function in reverse argument order
within an application? Kaboom, the safe-tcl script executes with full
  This is much less secure than Java. First of all, there is no
"declareharmless" in Java. The only way to access any low-level
I/O in Java is via a class interface, and the "final" keyword on
the Java i/o classes prevent any subclasses from overriding these
methods. You can not tell the Java runtime to add a new privelege
to the interpreter like in Safe-TCL. The only way to extend Java is to
create "native" C-code methods and link them in.
  Java relies on its class loader and byte-code verifier to make sure
unauthorized code is attempting execution (such as overriding a system
  It's not as secure as chroot() the Java runtime and running it in a separate process with only a pipe to communicate with the outside
O/S, but I feel it is a lot safer than Safe-Tcl. (not to denigrate
Safe-TCL, I am using it in a large project, but this is MHO)
  Finally, all you have to do to remove all I/O ability from Java is delete
the File I/O classes from the class hierarchy on your disk where HotJava
runs. Most apps don't use any File I/O anyway. (Java forces file i/o to
only be allowed in ~/.hotjava or wherever an environment variable
points) Java has no built in I/O primitives in the language itself.

@_date: 1995-08-03 22:32:46
@_author: Ray Cromwell 
@_subject: Appropriate Topics? 
Right, I wasn't saying that. I was being sarcastic. I have my mailbox
filled up everyday by noisey messages like that PBS under the
Republican's post (which is old, I saw it months ago), discussions of
the newest conspiracy behind the Randy Weaver incident, etc, without
uttering a peep. I just hit 'd' and go on. So I post a message about
crypto and coding, and all of a sudden I get accused of not being
on topic. I obviously put some time and thought into my message,
I experienced a weird sort of ironic feeling when I saw the comment
(about being off topic) Kinda like, "what is this world coming too
when an annoying 800 line policy analysis forward, and discussions
of the OJ trial are considered 'signal'"
 I don't think the only valuable contribution to c'punks is writing code,
in fact, I'm not writing code, I'm discussing theoretical abstractions.
All kinds of posting types from t-shirts, to meetings, to
political activism are valuable. In order to write code, you must
think about and discuss what you are going to write first.  In order
to fight politically, you must have discussion and debate. What I don't
think is valuable are these massive forwards, subscriptions of cypherpunks
to Web servers, and 2-line followups with snide remarks.
  Decrease the entropy. ;-)

@_date: 1995-08-04 07:59:58
@_author: Ray Cromwell 
@_subject: Java and Safe-TCL security (was Re: Java, Netscape, OpenDoc, and Babel) 
The same applies to Java. Anything can be ripped out of Java by removing
the classes with the "native" methods on the local side. The class loader
will barf at an object that references a class that doesn't exist. In fact,
since that class contains the only way possible to access that privelege
(it encapsulates all the nasty unix system calls you don't want to allow)
there is no way for the untrusted code to call for instance, open(),
because it doesn't know the address of it. Java does compile-time
emasculation. (the compiler I'm speaking of is the Java compiler which
must be run from the shell. The compiler is not a part of the browser)
Now Safe-TCL has another mode of failure altogether. First of all, the way
the interpreter is made "safe" is to take a fully working tcl interpreter
(with full priveleges) at run time, and use TclDeleteCommand() to remove
offending commands. Safe-TCL is not emasculated at compile time, but at
run time. Now what if this removal-of-dangerous-commands process fails
sometime, or fails to remove just a single command, because of say, a
fence-post error, and that command just happens to be 'exec'?
Furthermore, two interpreters are created, a "safe" one and an "unsafe"
one. It is very possible for a programmer to accidently pass the pointer
to the wrong interpreter. You should be nervous of an unsafe interpreter
ever existing at all.
Lastly, "declareharmless" allows priveleges to be added to Safe-TCL at
run time, vs Java which only allows that by recompiling Java classes.
If by any means, a trusted interpreter ever gets to execute this command,
all is lost.
One last comment: Java is a language specification, not an implementation
specification. Sun wants Java to be a free and open language with other
vendors creating compilers and runtime environments. Whether or not
the Java runtime executes in a separate process space, chrooted(), etc
is an implementation detail. In fact, I'm not totally sure that Hotjava
doesn't do this already. Implementation details are not documented in
the Java papers available at the Java home page.
You have to read more than just the Java whitepaper to get an estimation
of its security.

@_date: 1995-08-04 11:12:25
@_author: Ray Cromwell 
@_subject: Java and Safe-TCL security 
One of the designs I have one the drawing board is to store per-script persistent data in a dbm file, and allow scripts to import/export data
from/to a shared tuple-space. I would limit the data storage to 1024
bytes (to make it portable, some DBM libraries have this limit)
  Scripts could store variables via a new command added to the interpreter
like 'SafeTcl_putvar varname value', and access valuables with
'SafeTcl_getvar varname', 'SafeTcl_varlist'. Also, there would be a
'SafeTcl_read_variables' which could be executed at the beginning of
the script to reload all stored variables.   Scripts could talk to other scripts by means of a   The other script(s) could check for any incoming imports and use SafeTcl_import to retrieve the value. (when the last import is done,
the data is garbage collected. Also, there would be a timestamp so that
old data would be purged after a time limit anyway)
   An example might be, a calendar application in your mailbox which maintains
your weekly schedule. An incoming message script (agent), could "export"
some data to this calendar script which would correspond to some command.
For instance, asking if you would like to have dinner at a certain time.
If the calendar agent says yes, it could send a reply agent to inform
your calendar.   The calendar could be programmed to wakeup every so often and check for
imports, or the interpreter could just be made to "wakeup" any script
that got an import immediately.   Telescript's checkpointing of execution state is of course, much cleaner.
Too bad they don't know how to market a programming language.
  If anyone writes an enabled-mail java runtime, the same things could be
done a lot easier.   The problem with all safe "agent" designs is that the programming language
itself isn't enough. There needs to be a meta-agent language for querying capabilities of local environments.

@_date: 1995-08-04 11:40:35
@_author: Ray Cromwell 
@_subject: EU Data Protection 
Just more evidence for why even "well meaning" policywonks are dangerous.
Take for instance the rule that "data must be kept up to date and accurate"
How up to date and what is accuracy? So if I have a commercial web page
which records transactions on my server, and I stop logging and keep
year old records, do some statistic processing on them, I am in
violation for having stale data.   And what the hell is "accurate" data? All information about other people is subjective. I should be entitled to record any statistics about you for my use that I want. Just by interacting with me you transmit information. If
I interact with you and get the "wrong impression" about what type of
person you are, am I in violation for storing inaccurate data? (e.g. if
I write in my computerized diary "I think John Smith is a jerk.")
  How will this law affect reputation servers? If my reputation server
has what you consider a bad review of you, am I in violation?
  Privacy should be implemented via cryptography, not obscure politcal
machines which are doomed to fail and produce a black market for personal data anyway.

@_date: 1995-08-04 14:52:48
@_author: Ray Cromwell 
@_subject: Java and Safe-TCL security (was Re: Java, Netscape, OpenDoc, and Babel) 
SafeTcl or Java? I wish SafeTcl was isolated into a separate library
with compiled-in safety so I could embed it into my applications. As it is
now, I have to just use normal Tcl and hack in the MakeInterpreterSafe()
function which removes dangerous commands.

@_date: 1995-08-06 20:29:50
@_author: Ray Cromwell 
@_subject: RSA has been proved correct 
All you need to do is verify yourself (i.e. formally prove the
correctness of the theorem prover) to rely on the results of the
theorem prover. It's the web of trust model. And before you jump up and say "but how can you prove the theorem prover, maybe Godel...", there is a very simple theorem prover that is provable via mathematical induction. If you don't trust induction, then I don't know what to tell you. (it's like denying the Peano postulates) The theorem prover works like this:
Start off with your axiom set and your rules of production. (for instance,
a context free grammar, that might say "if x+y=z is a theorem, then
x+(y+1)=z+1 is a theorem") And enumerate all possible theorems on
the parse tree. If you reach theorems of length N that exceed the
theorem you're trying to prove than either it is a nontheorem or
undecidable. This procedure will never produce a "yes" answer for
a false theorem, although it will fail to prove some theorems. And it is
news to me that "the general mathematical community is still suspicious of
the four color theorem." Not only are they not suspicous of the theorem,
they aren't suspicious of the proof. It's been verified and reproduced
over and over again, and it has also been shortened down from the
original (I believe 2000+ special graph cases) to just over 400.
Physicists aren't suspicuous of relativity either.
[note above: the theorem prover fails if the production rules allow
theorem shortening. The system must be primitive recusive, but there
are many restricted domains of theorem proving which are.]
  The classification of the simple groups was a 1000+ page written
proof. Which one is would you trust to have a mistake somewhere? The
computer checked one, or the human checked one?
  This general line of discussion is getting out of hand. You can't
*prove* anything for sure. Even if it seems logical to you, how do you
know your own mind isn't buggy? How do you know you're not hallucinating?
Even something as simple as Euclids proof of the infinitude of primes.
You think it's been proved? ha! You are merely delusional. The rest of
us sane people saw the disproof years ago, but every time you start
to read the disproof, your mind goes into its own little universe
and starts substituting in screen memories making you *think* you just read a proof, not a disproof.
  Ultimately, you can't even trust yourself. The world is a risky
place, and sometimes you just have to live with the fact that one
day, something you chose to place faith in and rely on is going to be
pulled from underneath you.

@_date: 1995-08-07 09:53:38
@_author: Ray Cromwell 
@_subject: Quibbling about definitions of "proof" 
Phill Hallam-Baker summarized it best. I advise anyone interested in this
issue to read up on pancritical rationalism (a favorite extropian topic of
debate). "The Retreat to Commitement" by Bartley (?, sorry, can't recall
at the moment, the book is not with me) is a good writeup of the subject.
At the lowest level, even the basic axioms can be cricitized.

@_date: 1995-08-09 07:14:32
@_author: Ray Cromwell 
@_subject: Prime Number Gen's. 
And how do you do this? I'm not aware of any deterministic primality
test which isn't atleast as hard as factoring. P-1 factorial is such
a number which could demonstrate P is prime (compute the gcd, check if
they are relatively prime). Good luck computing it.

@_date: 1995-08-11 06:36:46
@_author: Ray Cromwell 
@_subject: PRZ encrypted voice software release imminent 
My question is, how portable is it, and does it work over TCP/IP rather
than just modem connections (I suggested this about a year ago)? My ideal
implementation would function on the following architectures:
Unix: can be used through either /dev/tty?? or Socket (probably want
to use UDP). Works on Solaris, IRIX, AIX, NetBSD/FreeBSD/BSDI and Linux.
(audio devices are all proprietary)
Windows: uses Window's sound card device drivers, works via either comport or WinSock Mac: uses Mac sound drivers, uses Mac modem port or MacTCP
I'm looking for someting that has the look and feel of Internet Phone
(but ported to multiple platforms) with encryption.

@_date: 1995-08-11 10:50:51
@_author: Ray Cromwell 
@_subject: PRZ encrypted voice software release imminent 
If you reread my message, you'll see I mentioned UDP. I just refer
to IP protocols in general as "TCP/IP", implicit is that UDP and ICMP
are atleast included. The mention of "Winsock" should give you the context.

@_date: 1995-08-11 11:17:28
@_author: Ray Cromwell 
@_subject: PRZ encrypted voice software release imminent 
I just hope they isolated the operating system dependent code into
seperate modules so that "PlaySoundChunk(Chunk)" is used rather than "MacDeviceDriverCall(MacSpecificDeviceStruct, MacSpecificFormat)"
The application layer should be abstracted above the transmission
layer above the link-layer. At the application layer, communications
should be sent through the transmisson layer, e.g. "GetNextPGPFonePacket(Protocol, Packet)". The Protocol here would be TCPIPDriver or ModemDriver.    Therefore, all one would need to do to port it to different platforms
is code up a TCPIPDriver (for Unix == Berkeley Sockets, for Windows = Winsock, for Mac = MacTCP), code up a modem driver
(Unix = tty's + ioctl, Mac = Communications Manager, Windows = TAPI),
and finally port the SoundPlay and SoundRecord functions to the platform
dependent way of playing sounds and recording them.
  If you are forced to abstract above "modems", your algorithms will
be designed to work over more general transmission schemes. I fear
that coding for modems first will lead to an overall application tuned for
modems, but poorly designed for asynchronous networks. The tunning should
be done in the driver, not the application/algorithm level. (for example, modems don't experience much "packet churn and loss",
and they usually have a dependable bandwidth. Even if they retrain
randomly from 28.8 to 14.4, they can still be counted on to atleast have
9600 bps throughput more consistently deliverable than say a slip/ppp line   Far too often on Macs and PC's I see code "welded" to specific hardware
dependencies. I only hope that PGPFone is more like PGP2.0 and less like
PGP1.0 (and less like HotJava, which is also a bitch to port), because
for general acceptable, I don't think it will succeed until it
atleast runs and interoperates on Mac, Windows, and Linux.
   I don't think there is a problem with developing on the Mac. Atleast
the Mac has a real O/S. If it had been done for DOS first, it might have
been poking SoundBlaster registers with arcade magic constants in the
program. However, the application should be isolated away from its
I/O mechanisms so that all I/O is done through a module which
"maps" I/O requests to the local operating system mechanism, rather
than depending on them directly.
Sorry about the rant. (I haven't seen PGP phone's code, but I am
just remembering RealAudio/InternetPhone/VidPhone and a whole host
of other internet utilities that are either available only for windows,
only for Mac, or only for unix. Netscape seems to have done things

@_date: 1995-08-11 11:42:41
@_author: Ray Cromwell 
@_subject: PRZ encrypted voice software release imminent 
I don't think CPUs and modems are an issue. When I bought my 486/DX2
more than a year ago, it was a near top of the line machine (a P66 was the only thing better and it was a lot more expensive). Now, I can look
in computer shopper and see that not only is my machine not near the
top of the line, it's not even "Entry Level". Pentium 75/90 systems are
going for 1/3 the price I bought my computer for, and those systems have
PCI buses (vs my VESA local bus), larger HDs, EDO RAM, faster video
cards, etc. Assuming a baseline of a 486DX/33 or faster (like a DX4)
is not unreasonable. Secondly, 14.4K modems are a dime a dozen. You
can get them as low as $50 (with RPI) or $70-80 for full functionality.
28.8K modems can be bought for $150.   The problem with PGPFone as I see it, is that it's an application and not
a application to a protocol. To get voice encryption in large scale
use will require several things IMHO
1) performance is reasonable
2) user interface is very easy to use, as easy as using a walkie talkie
     with a key
3) software is very easy to setup up (no knowledge of hayes commands required,
no editing of slip configuration, etc)
Finally, even that is not going to drive the system into a defacto
ubiquitous standard unless
4) a complete, easy to read specification of the protocol used is
   published (perhaps as an RFC)
5) third party applications that use the protocol evolve.  is needed because competition between applications writers will
improve the human interface of the software beyond what the PGP
authors can design. (who are more likely algorithm specialists, not human interface people)
6) network independent
   this will be a benefit to people who want to make long distance calls
over data networks. it could also be used by companies for secure I would like to see a secure voice communication protocol that is divorced
from the particular details of the algorithms used (although a base level of some voice compression technique + DES + RSA will have to
be used) That way, new and better algorithms can be dropped in depending
on the network used (modem, ipx, tcp/udp, etc) and the bandwidth required
(CELP vocoder, MPEG-audio, lossless encoding, progressive PCM, etc)

@_date: 1995-08-13 01:13:26
@_author: Ray Cromwell 
@_subject: PRZ encrypted voice software release imminent 
Uh, that's why you define a base level of support like I said. This
same arguments applies to all communications technology, such as secure ip, e-mail standards, etc. You always have a base defined to
insure something to fall back on. that has absolutely nothing to do
with my comments which are directed at developing an open standard
for inteoperability that allows other algorithms to be sused rather
than locking everyone into a particular codec. The codec is irrevelent,
it's cement in the foundation, but the design of the house is more
important to the end user. The message protocol and application
level is much more important because it controls 1) how easy
it is to create applications, and 2) how those competing
applications can interoperate with each other. These supports
a rich market with lots of interoperating "phones". on the other
hand, a poorly designed protocol will lead to a market dominated
by one or two proprietary players that is hard to upgrade
when better capabilities come out later, or new demands are made.   There are other reasons to abstract above codecs, for instance, a
lot of codec algorithms are patented or trademarked, so that
if a program is "welded" to any particular codec, you create hassles
for application developers who can't use non-open algorithms.
  Finally, abstracting above the codecs allows competition between
codec developers ( a sub market) whereas a design that locks in
one particular codec pretty much forces price competition

@_date: 1995-08-13 01:29:18
@_author: Ray Cromwell 
@_subject: PRZ encrypted voice software release imminent 
[stuff about tuning algorithm to channel characteristics]
 I agree with this, but it is still possible to do all this through
an abstract interface layer. One can "query the line characteristics"
of a transmission layer and then limit the selection of algorithms
based on those characteristics.
Example: we have a class TransmissionLayer, and two derived
classes "syncrhonouslayer" and "asynchronouslayer" (subclass as
appropriate). Note, no underlying link type is being refered
to.  It could be a network or a modem.
Now we have a bunch of algorithms (codecs), CodecA is optimized for
a synchronouslayer with atleast 16kpbs. CodecB for asynchronous
packet networks.
At the application layer, the user chooses a way of connecting.
The application instantly picks the best codec (supported
by both ends) for that transmissionlayer. it alo updates the user
interface automatically, e.g. displaying a "half duplex"
mode for one type of link, or "conference call' for another.
Some types might not support all encryption types
because of cpu limits (also detected)  There's no reason
this could not be programmed. It would also be highly portable,
highly maintainable, and more easily adoptable.
Direct-to-hardware hardwired algorithm software is good for
proof of concept. But I'm thinking ahead, to a time when
a multimedia protocol will be just another transport layer ontop of
which cool applications are running. (like http+mime runs over

@_date: 1995-08-15 11:01:36
@_author: Ray Cromwell 
@_subject: CoS Raid on "Copyright Terrorist" 
One of the reasons I used to receive all my mail at the "FSF" machines
(GNU.AI.MIT.EDU) was because I had a completely anonymous account. I had
the GNU account long before the FSF started registering people's name/phones, and I used to telnet into GNU from several completely
open annexes in Maryland. (the colleges would allow you to simply
telnet from the terminal server to anywhere with no restrictions.
This was back in 88-89 when the internet wasn't as big. Of course,
they shut it off later when outside users started busying up
the lines) And since I had root on the system, I could delete the
logs recording which IP addresses I was coming from.
Nowadays, a $10-20/mo maildrop at places like "Mailboxes, Etc" works fine.
(although there's still the possibility of them nabbing you when you go
to pick up the mail)

@_date: 1995-08-26 16:31:07
@_author: Ray Cromwell 
@_subject: proliferation of voicesystems 
It's really great that there are all these voice transmission/encryption
programs out there, the problem is, none of them will talk to each other.
If I have a unix box, I have to use product X, if I have a PC, product Y,
and a Mac, product Z, and X,Y, and Z all speak different protocols. The
issue is more frustrating with web clients. I like to use Netscape, but
if I want to view RealAudio, I have to switch to Windows, etc. Rather than have one "successful" product set a defacto standard and lock the rest of the market into one algorithm, cypherpunks who are working on
voice products should collaborate to product an open standard, which
specifies base level functionality, and drop in algorithm improvements.
Perhaps even video should be considered as that too will eventually be
a reality. Sooner or later, there must be a shakeout and a "standard" (defacto) will emerge. The question is, do you want this to be
an extensible open standard that can cope with changing hardware and
network capability, or do you want, say, InternetPhone, to win
and set the standard by shear market share like Netscape is doing now and like Microsoft has been doing?
Just something to consider.

@_date: 1995-08-27 15:00:34
@_author: Ray Cromwell 
@_subject: proliferation of voicesystems 
And Windows95/NT has a Audio Compression Manager which comes with
GSM and TrueSpeech compression drivers.   The problem is, what will be done for the Unix users? A standard
audio API is sorely missing in the unix world (NetWork Audio System and AudioFile aren't solutions)

@_date: 1995-08-27 19:44:17
@_author: Ray Cromwell 
@_subject: proliferation of voicesystems 
That's too low-level to deal with the proliferation of PC sound systems,
especially since even non-intel workstations are adopting PCi buses.
If I recall, /dev/audio relies on u-law/a-law encoding. That's only one
component of a higher level audio system. That's like having a
interface doesn't admit good hardware acceleration, such as if you
had to play an MPEG layerIII audio, but your sound card had a DSP.

@_date: 1995-08-31 20:28:32
@_author: Ray Cromwell 
@_subject: sums with BIG numbers 
Try Knuth's The Art of Computer Programming, Volume 2, Seminumerical Most bignum routines work like this. An integer is represented
as a polynomial p(x) with coefficients a_0, a_1, ..., a_n, where
x is the radix or "base" of the number. The coefficients come from
the ring of integers, modulo the base. For instance, if you are
using base-2 (x=2), the number 28 could be represented as
p(x) = a_4 x^4 + a_3 + x^3 + a_2 x^2 + a_1 x + a_0 where a_4=a_3=a_2=1 and a_1=a_0=0.  Each a_n is an element of Z mod x
To add two bignums, P(x) and Q(x) simply sum coefficients of like
terms like you would with any polynomial addition, with one simple
modification. If a_k is the coefficient of the x^k term of P(x), and
b_k is the coefficient of the x^k term of Q(x), then the
x^k term of P(x)+Q(x) is a_k+b_k+(carry of previous term) mod x.
(new carry=(a_k+b_k + previous carry)/x)
All this says is, the new term is the sum of the coefficients on the x^k terms, modulo x (because your coefficients can not hold
numbers larger than 'x'), plus the carry of the last term. The
carry is 1 if a_k+b_k+previous_carry > x. Now you may ask, if our coefficients in our bignum are stored as
32-bit integers, how do I compute the result in C and take into
account overflow?
Well, add the two numbers together. If the result is less than either
of the numbers, an overflow has occured and you must carry (the
machine register has 'rolled over'). For multiplication, you can
either break a 32-bit number into 2 16-bit chunks and perform 4 16-bit
multiplies to get a 64-bit result (using 16x16->32 bit hardware
multiplication) or you can use a number of type "long long int" in C
and let the compiler do it for you.
A short example: let X=123 and Y=789 be bignums represented via the
polynomials P(x)=1 x^2 + 2 x + 3 and Q(x)=7 x^2 + 8 x + 9  with
x=10. let r_n be the coefficients of the resultant polynomial Start at the least significant term. Carry=0
Now r_0=(a_0 + b_0)+carry mod x, or r_0=9+3 mod 10=2, carry=(9+3)/10=1
    r_1=8 + 2 + carry = 11 mod 10 = 1    carry=11/10 = 1     r_2=1+7 + carry = 9  carry = 9 / 10 = 0
So the result is 912.
Explicit modulos are only required if you are working in some base
other then the machine's natural word size. (otherwise the
'roll over' effect gives you the mod for free)
If you are seeking the fastest practical methods of doing multiplication,
division, and modular exponentiation, look up information on Karatsuba multiplication, fast reciprocals via Newton's Method,
and Fast Integer Squaring combined with exponent shifting.
(if you are looking at PGP's source code, PGP does not use the
fastest algorithms)

@_date: 1995-12-07 20:26:00
@_author: Ray Cromwell 
@_subject: Netscape stock on 12/7/95 
I don't think it is a coincidence that Microsoft also made their
major announcements today. I doubt the feeding frenzy over Internet
related stocks and technology is even close to over. Having seen
the new Shockwave plugin for Netscape, I expect Macromedia stock
to go up again soon. (it already went up 50% after the original Netscape
announcement of Director integration)

@_date: 1995-07-11 16:32:29
@_author: Ray Cromwell 
@_subject: Moby ints [Re: Num Rat] 
The state of the art in multiprecision integer arithmetic is Scho"nhage.
Schonhage invented the all-integer Fast-Fourier-Transform based big-int multiplication method. An n-bit can be multiplied in O(n ln n) operations. This is a big improvement over the Karatsuba method which is
O(n^1.5) and the classical method O(n^2). Surprisingly, the constant
factor isn't that large. This can be combined with modmult techniques
for fast modexp routines. However, it's only worthwhile for large
numbers (>512 bits). At n=512, if your bigints are stored as polynomials
with a 32-bit radix, then N=512/32=16. 16^1.5 = 64, 16 * lg(16) = 64
(so the FFT method and the Karatsuba method are equivalent for numbers
of that size)
If you are dealing with 2048 or 4096 bit keys, it starts to look attractive.
Schonhage published a book in the last year, the result of more than 10 years of research into this area. It's hard to get a hold of though, you
have to order it from germany.
95-133299: Schonhage, Arnold.  Fast algorithms : a multitape Turing
     machine implementation /  Mannheim : B.I. Wissenschaftsverlag,      c1994.  x,
     297 p. : ill. ; 25 cm.

@_date: 1995-07-12 07:48:40
@_author: Ray Cromwell 
@_subject: Moby ints [Re: Num Rat] 
True, the Karatsuba method does seem "simplier" than a fast fourier
transform (which a naive implementation would use complex math), however
Karatsuba has some hidden costs which the FFT technique doesn't. Karatsuba
requires dynamically resized integers. (i.e. when you split into subproblems,
you have to rescale to n/2 bit integers) Karatsuba also has to do several
big_int additions per subproblem that the FFT doesn't. If the FFT-Poly
routine is done over a prime field, and it is coded iteratively, it just
might come close to Karatsuba for small n. I am not aware of any experimental data, but I am working on the implementation of a high
performance portable big_int library right now, and I'll be doing
some data collecting.

@_date: 1995-07-20 09:13:06
@_author: Ray Cromwell 
@_subject: Netscape the Big Win 
I concur with everything you said Perry. However, it may be possible to
write code "for netscape". If their NSAPI (control the browser remotely
via message/event passing) allows full control, you could probably hook
into the crypto functions. If not, you could always generate forms and
html pages on the fly with the data you want to send, and force the
browser to submit them. If the other end has an SHTTP/SSL enabled server,
it will be sent encrypted. It's a yucky solution. If Netscape incorporates
*full* hotjava capability (like defining new protocol handlers such as
SECURE://), then that would be much better. I have some doubts that Netscape
will implement all the Hotjava functionality when they incorporate Java because it would allow people to change the look-and-feel (and functionality)
of the browser too much, and also because they would have to softcode
(in java), a lot of the functionality they have hardcoded right now.
  Browsers are beginning to become like emacs. Virtual operating systems
unto themselves.

@_date: 1995-07-20 09:32:10
@_author: Ray Cromwell 
@_subject: Netscape the Big Win 
[why favor the browser approach of sticking all the client functionality
for various protocols into one program]
   The answer is: integration. While TRN is a great newsreader, and Eudora's a great mail reader, etc, if I read a post in TRN or a message
in Eudora, there is no hyperlinking. If I see a link or reference,
I have to cut-n-paste it into an ftp session or a web browser.
If "helper applications" for web browsers could talk bidirectionally
with the browser in a meaningful way (display output in the window for
example, and use the browser to open and fetch data), there would be
no need for all this. Isn't it much better to have inline jpeg viewing
in a page rather than launching 10 jpeg viewers externally?
   Since not all operating systems have a standard cross-platform technique
of interapplication communication, it makes porting these helper apps and
browsers all the more difficult.
   The future is in component systems like OpenDoc and HotJava. With HotJava,
you can once again return to "shopping around for the best mail reader
application", however this time, it will be a program you can run from within
the browser. Not only that, but you can automagically download it just by
going to a home page, or placing the mail reader application in your own
  It used to be that each media type was stored in a different document,
and a special tool had to be used on each file. Now, all media types
can coexist in the same document, and the "handlers" for each media type
are packaged into the document too (or, links on where to find them)
  I wouldn't be surprised if in 5-10 years, your operating system basically
looks like a cross between Netscape, OpenDoc, and HotJava. The "browser"
would be ubiquituous, and local/LAN/WAN data would be treated transparently.

@_date: 1995-07-20 09:36:52
@_author: Ray Cromwell 
@_subject: Netscape the Big Win 
Go to  and join the java porting list and also the
linux porting list. Suffice it to say, it is being worked on by many people.
The next port coming out will be for the Mac. Linux will probably be right
after that. The problem with porting HotJava (and Java) is that it uses
Solaris Threads, and if your operating system doesn't have a lightweight
process/thread library, you have to port one, or write your own. Secondly,
HotJava uses OpenWindows, and third, it relies on some Solaris specific
memory mapping tricks. (I've heard, there's also some endian problems)

@_date: 1995-07-20 11:51:19
@_author: Ray Cromwell 
@_subject: Netscape the Big Win 
[extension languages]   The "crufty" extension syntax, is a simplified and improved C++, with all
the features any lisp extension has, minus closures. For user interface
work, and applications existing in a larger environment, object oriented languages are superior. LambdaMOO shows lots of evidence for this.
Sun, by choosing a C++ syntax for Java, gains a tremendous advantage by
allowing C/C++ programmers to translate their experience to Java
programming rapidly. In fact, I wish Java had actually been the real
C++. C++ suffers from not having garbage collection, and from overreliance
on pointer manipulation. Now, if only someone can convince Sun to add
operator overloading to Java for the final release..... (really useful
for BigInt programming)
(netscape may not release source code, but the full source code to hotjava
is available)

@_date: 1995-07-20 13:45:51
@_author: Ray Cromwell 
@_subject: Netscape the Big Win 
I agree wholeheartedly with this. When General Magic first released
the Telescript white paper, I was really hot for the technology. I tried
to become a developer, I sent mail to every General Magic employee on the
net I saw posting (one guy even CC'ed me accidentally to his manager
saying they should hire me). I did searches in the media for any
mention of it. Harry Hawk even had dinner with the VP of Product Development
at General Magic. Alas, they would not give out alphas/betas of the development environment, which is all the same, because they don't know
how to market Telescript and make it a defacto standard. Instead of charging
for the interpreter/server, they should have given away the servers and
development stuff for free, or near free, and made their money by selling
services and clients (personal digital assistants using Magic Cap and
Telescript). The result is that no one uses Telescript except AT&T.
If I had gotten my hands on Telescript, I would have wasted lots of time
and effort on a failed product (failed in my eyes, because of its potential)
[lesson: proprietary programming languages fail unless they come embedded
within a killer consumer application]
    Then I got into Safe-Tcl, which is a little more promising, but still
a failure because there was no "killer app" which used it and which would
encourage its incorporation into other servers and clients. HTML would
have failed were it not for Mosaic. I was on the Web when it only had a line
mode browser and it was about as exciting as Gopher.
   I think Sun has taken the right approach with Java. Giving out Alphas
and Betas for free with source code. Encouraging heavy porting, and
incorporating it into a "killer app" (HotJava). They will make money
by licensing and selling tools and environments for Java, but their biggest
success will be that it will become the defacto "enabled content" language.
   Java still lacks what Telescript has (the ability to checkpoint execution
state and migrate execution across servers seamlessly), but what Telescript
has that Java doesn't isn't enough to make people wait for it, or pay
lots of money to be developers for.
   I could be wrong about how successful Java will be, but my confidence
factor is high.

@_date: 1995-07-20 14:01:05
@_author: Ray Cromwell 
@_subject: Netscape the Big Win 
HotJava runs fine on a 486/33 with 16mb running WinNT 3.5. 486s are
pretty much standard. 1995 and '96 will be "the year of the pentium"
Entry level systems are now Pentium 90s with PCI and 64-bit video. Pentium
120 systems now cost less than my 486/66 system did a year ago. HotJava
is compiled into efficient byte-code with the option to be translated
to machine code at run time. This is the same principle behind the Newton.
Since the majority of the CPU time is spent in native-C code function
calls to the user interface, and network latency is high, the "slow"
interpreted code is hardly noticed. In fact, I wouldn't call the
Java runtime slow, it beats the performance of many Lisp interpreters
which have been adequate for "home" users. (e.g. Emacs Lisp) HotJava is
not meant for writing applications to decode MPEG in real time. It's best
use is for interactivity on web pages. It doesn't take a powerhouse
of CPU to put up a slider, "sleep" for an event, and they call a ScrollList()
routine. There's going to be a huge use of Java for doing sales catalogs
and online ordering on the web.
  Netscape software is not just a pretty user interface, it also has the
best layout algorithms I've seen of browsers. That's some pretty hefty
dynamic programming there. Mosaic and Arena frequently produce poor
or incorrectly formatted pages. (or less optimal pages than I've seen

@_date: 1995-07-21 08:45:24
@_author: Ray Cromwell 
@_subject: Netscape the Big Win 
Yeah, but does it fire up 1 browser process everytime you click on it, or
will it command an already running browser to follow the link? Secondly,
this still doesn't solve the problem of interactive content and custom
interfaces. With Java, you can build arbitrarily complex web interfaces
with objects that can be linked together. An example of this is Sun's
Spreadsheet Java App which is connected to a StockQuote app which runs
a cute ticker tape scroller in the page. If you fill out the spreadsheet
with stock symbols and amounts, it automagically updates your net-worth
in real time, and simultanteously updates a line graph of your net worth
in a window below. I can imagine a newsreader app which automagically
pulls ratings down from a server and communicates with other apps in the
same page.
(plus, Tetris, Reversi, and Video Poker running within a web page with
text and links wrapped around them is really cool!)

@_date: 1995-07-21 10:04:26
@_author: Ray Cromwell 
@_subject: Java (was Netscape: the big win) 
* Protocol Handler
  implement a remailer:  URI that automagically communicates with remailers
  implement a pgp: URI that can decode pgp signed/encrypted text      automagically. Use this to implement a server where users can post
     encrypted messages for other users, and the user, upon clicking the
     link, say pgp://rays_message_to_hal.html, gets the message automatically
     decoded. The encrypted text could even be HTML!
  implement an anonymous mailto: URI that works like mailto:, but uses
    an anonymous return block or blindserver automatically
* Content Handlers
  implement a handler to decode PEM/RIPEM or any other kind of crypto      MIME type
  implement a handler to check signatures, that way users could use
   a multipart message, the first part being a text/html or text/plain,
   the second part being a signature. The handler would automatically
    check the signature and notify the user that the content he is     reading is authenticated (by beep, or icon, or title bar, whatever)
* Applications
Implement a Elm-like mailer app, complete with editor, that can send     rfc822 normal mail, or, optionally, send thru any remailer chain
    at the click of a radio button
  Implement an object which can open a socket to key server or list
    of remailers server, get the list, display properties, etc
The possibilities are endless. All of these things can be done in emacs, but
unlike emacs, Java will be embedded into Netscape meaning the installed based
of users will be much larger.

@_date: 1995-07-24 16:49:41
@_author: Ray Cromwell 
@_subject: An idea about Java and remailer clients and servers... 
If the "duty" cycle is 1 hour and there are 10000 users utilizing
the network, that tells you nothing. All it does it confirm that
User X sent a remailer message within the last hour. One could just
as easily finger User X and use the same reasoning.
  And if one has to suspect User X in the first place, User X has already
blown his cover partially (either by writing style or other leaks)

@_date: 1995-07-24 16:55:30
@_author: Ray Cromwell 
@_subject: An idea about Java and remailer clients and servers... 
I forgot to add. There is no reason User X has to run his remailer
immediately. His software could simply commit to running a remailer for
1 hour at some specified future date < some threshold. Any messages
sent to him for remailing would be queued until that time. Therefore,
all your technique would tell you is that the user remailed a message
sometime between date X and date Y. if Y-X > few days to week or two,
the intelligence gathered on User X is miniscule. Traffic analysis would
detect User X using the remailer network anyway.

@_date: 1995-07-28 00:32:58
@_author: Ray Cromwell 
@_subject: Java, Netscape, OpenDoc, and Babel 
Just a quick note to chime in. The OSF just did a deal with Sun
to port Java to several platforms. The OSF is opening a "web mall"
where you can grab software objects and run them. Expect to Java
*really* take off in about 2-3 months. Every business on the net is going
to want a Java shopping-client-basket on their web-mall/web-store.
(Web Consultants! Learn Java!)

@_date: 1995-07-28 09:24:38
@_author: Ray Cromwell 
@_subject: Java, Netscape, OpenDoc, and Babel 
Holes have already been found in CERN HTTP. The GETS() style bug
was in the first few versions allowing attacks to overwrite the
process stack. Any mail server written in perl is susceptible
to weird attacks. For instance, if you ever eval/exec any variable
that is double-quoted, rather than single quoted, it is possible to
run shell commands via backtics or shell subprocesses in variable names.
In fact, can you even prove that elm or pine don't have some obscure
bug wherein a certain message, say with malformed headers, can
overwrite the stack and allow Morris style attacks? The "Good Times"
virus may actually be possible.   Security is very nice to have. it's nice to rely on. But sometimes there's a need for some liberty. Make everything as secure as you
can, but if security prevents you from doing something that you want
to do, it's not helping you. The internet would be a very cold and barren place if the only application people ran was mail.
  Object Oriented Superdistributed components are so useful an abstraction,
I think it's worth the security risk. HotJava solves some fundamental
issues with protocols. Right now the W^3 working groups have been struggling
to define URI/URCs and a whole host of other web protocols. They've been
doing it for years, but they suffer from Xanadu like problems as far as
I can tell. They don't want to saddle the web with a bad protocol, so they search to define a perfect one. Hence, no prototypes are ever
deployed, because if they were, the user community might make them
a defacto standard and lock them into it much like MS-DOS locked
PCs into the Dark Ages. With Java, you define all the protocols you
want. If your browser doesn't understand how to fetch a protocol,
it can fetch a protocol handler. There's no need for a kitchen
sink application that understands every protocol in existence.
  And with HotJava, you don't NEED to automatically fetch an application
and run it. You can just use it as an extension language. If someone
defines a new application or protocol handler for it, and this person
is fairly trusted on the net, you can decide to run it (kinda like
turning off autoload images), and even review the source code first.
This is no less secure than ftping software from some site and compiling
it.    Maybe for you, the issue is protecting corporate networks behind firewalls.
That's good, well then don't let employees run HotJava. However, I look at
it from the home slip/ppp'ed user standpoint. I think over the next two
years, slip/ppp'ed users will displace corporate/academic users as the
largest group on the net.   There will be worms and viruses. Just like there are nowadays. And there
will be fixes. And there will be yet another arms race between virus
writers and people who write anti-virus software. No doubt, there will
be HotJava based worm/virus scanners, etc. A new market will come into
being. You'll make money off of fixing holes. I'll make money off
custom java clients business web pages. It's the price that should be
paid, that is always paid, with any new technology. I'm not advocating
being careless. I'm just saying that paranoid security hampers development of more robust and better software. HotJava is a piece
of low-hanging fruit. As more people use it and more problems are found,
better fruit will be found.

@_date: 1995-07-28 09:29:42
@_author: Ray Cromwell 
@_subject: Java, Netscape, OpenDoc, and Babel 
re: OSF's mall.   Ah, I misunderstood what they were trying to do from an abstract. Now
it's much less exciting. They are just in effect running a beta ftp
site on an http server.

@_date: 1995-07-28 10:03:03
@_author: Ray Cromwell 
@_subject: Java, Netscape, OpenDoc, and Babel 
I agree with you. However, I think the only way to get a handle on
what the security issues are of such a methodology, is to deploy one
and see what happens. Then you can build a second generation environment based on that knowledge. There's also the issue that
even if the environment is secure on paper, with an application as
large as a browser and an execution environment, you can never
know if it was implemented properly. Sendmail-like bugs could haunt
the system for years. That's why its good to deploy it early, fix all
the big holes discovered as fast as possible. At minimum though, I think
Java should atleast run chroot()ed on Unix systems. Instead, their approach is to define a "writable" directory on disk that apps can write too. This does make me nervous because I can see the potential to send over a program to be compiled and executed. I don't know what you would do
under the MacOS and Win95 to make it secure. There is also security
at the meta-applet level. Even if you chroot() Java to some directory
where applets can write to, one applet can destroy another's data. If
the data saved by one applet is valuable to you, like hotlist settings
gathered over months, a rogue applet can trash them. But sometimes
applets need to be able to read/write each others data so you can't
just disallow it. So HotJava should have a access protocol for applets
too. The Java team could learn a lot from the experience LambdaMOO.

@_date: 1995-07-28 10:54:29
@_author: Ray Cromwell 
@_subject: Java, Netscape, OpenDoc, and Babel 
If a business wants high security, they probably shouldn't be running
anything but mail. Even allowing users ftp access is dangerous
because someone could download a trojan horse. My college  took
the /exec function out of IRC for this very reason. If data can get  through a firewall by any means, DNS, mail, etc, it's possible to write
some kind of program to send stolen information on those channels. Hell,
there is a big enough problem with users bringing software from home
into work and infecting company networks with viruses.
  I work in an environment which is very security conscious (IBM Watson Research). You should see how paranoid their virus lab setup is.
And I'm frustrated by not being able to run stuff from work I run at
home because of the firewall. I probably shouldn't be running the
stuff at work anyway, but I can't pass up having access to a T1/T3
net connection on my desk. I have no problem with security, as long
as it is user friendly. If everyone had to manually run PGP from the shell
to post a message to cypherpunks, would there be many posts?   At home however, I have full control over my environment. I don't
avoid all potentially dangerous software, because for me, the benefits
outweigh the risks. I have never seen the source code to DOOM's
internet drivers, so I have no way of knowing if data is being stolen
or downloaded to my harddrive. I would rather choose to encrypt
the harddrive, and run the software in an alternate partition even though
this still doesn't guarantee safety. I know people who go farther such
as swapping HD's in-and-out depending on whether they are in "fun, experimental computer use mode", or "serious, money risking mode"
But ultimately that decision is up to me. Most of the people who will
be running HotJava are users in non-corporate environments.   Once you actually browse some HotJava web pages with HotJava, the
ordinary Web becomes static and boring. It's like the difference between
ftp and Netscape, or TinyMUD and LambdaMOO. There's just so much
potential, especially for crypto-clients. Because Java provides a
single development platform, single execution environment, GUI, and
network access.

@_date: 1995-11-11 08:44:47
@_author: Ray Cromwell 
@_subject: Java insecurity - long - argumentative - you are warned. 
[Long list of bullshit deleted]
 "Dr" Cohen. If you want to criticize Java, why not read the technical
papers rather than spewing questions and assertions based from ignorance.
When you want to criticize a piece of engineering, you don't look
at the feature list or white paper. As is made clear in your post,
you don't know the meanings of phrases used in the Java paper, nor do
you understand how the machinery works. (e.g. byte code verifier)

@_date: 1995-11-14 01:51:05
@_author: Ray Cromwell 
@_subject: Java insecurity - long - argumentative - you are warned. 
Dr Cohen could have answered the questions himself if he had read
the literature. What he did was equivalent to asking "how secure is DES"
based on a marketing information flyer. Java does not fly in direct
contravention of expert consensus. Java does not purport to solve
the halting problem or formally prove the correctness of algorithms.
The only phrase you can quibble with is "tamper-free/virus-free",
but how many products on the market make that claim, for instance,
over-the-counter drugs? Anyone with half a brain knows that nothing
is perfectly secure, and what those phrases really mean is
"tamper-resistant". So get over it.
  It seems that after all those Netscape bugs were found, now folks,
many of whom I consider to not be very skilled in computer science,
are trying to conduct a witch hunt against Netscape, it seems in the
hope of gaining some fame or recognition. The general tone of your
messages and Dr Cohen's, leads me to believe that you think you are
conducting some service by "exposing" these "flaws", thinking that
one day c'punks will recognize your contribution and thank you. My guess is that most c'punks view your analysis as content free,
and overly zealous/hostile.

@_date: 1995-11-14 07:56:16
@_author: Ray Cromwell 
@_subject: DejaNews all over again 
Jeff, I think it's in your best interest to not waste your time
responding to this moron (who bears many features in common with

@_date: 1995-11-15 23:26:44
@_author: Ray Cromwell 
@_subject: Netscape rewards are an insult 
The problems found however, were not fundamental flaws in
the Java language itself nor in the Java virtual machine. As
I've said many times, you can pretty much rip any i/o capability
out of Java by changing the runtime class libraries. If someone
finds as way to to defeat the Java bytecode verifier/class loader
and replace a class in java.* with a more powerful one, then that
will be really significant.
[denial of service problems deleted. ]
   This is not a flaw or a feature. If you download a helper
app off the internet that has a flaw, it's not a flaw in the browser. Claiming that it is is like claiming that
"ftp"  or "nfs" has a fatal flaw because it allows you execute
untrusted binaries from other computers. Helper apps are in
the category of third party add-ons and the responsibility for
their correct implementation rests on the companies which sell them.
Netscape never claimed the ability to allow users to download
executable binary applications from the net and run them without
risk. Netscape doesn't come with a postscript interpreter nor does
it have one configured by default, so if the user installs one
and configures it, and it has a security flaw, it's not Netscape's
fault. Installing helper apps is not "easy" compared with
clicking on a Java applet so any user who does it must atleast be somewhat knowledgable.
   If a postscript interpreter is implemented in JDK Beta, and
it is insecure and it is allowed to interpret postscript files,
nothing bad will happen.
   They've never demonstrated otherwise in my entire history on the Java
mailing lists. Their whole mission is to produce a secure environment
for executing untrusted applications. The alpha's and beta's  of
every product have problems, it's to be expected. The whole point
of releasing a beta is so that you can get feedback.

@_date: 1995-11-18 02:54:29
@_author: Ray Cromwell 
@_subject: Java & Netscape security  [NOISE] 
[This is my last response on this subject.] This is a non-sequitur.
Providing hooks for third-party add ons does not make Netscape
responsible for damage done by third party products. If you believe
this is true, find me a legal precedent for it. It doesn't make sense
on a purely intellectual level. If you produces a product that has the
ability to be ugpraded, and someone upgrades it with dangerous
third party products, how can you control that? The only way to assure
against it is to not allow upgrades of functionality except by your own company. This throws the whole idea of reusable software,
device independence, and building "platforms" right out the window.
It's the kind of logic that seeks to make bars responsible for
drunk drivers. Indeed, Microsoft and Apple should be held responsible
for dangerous "applications" that their computers can execute.
   I don't know anyone who has a postscript viewer configured in Netscape
and I suspect the vast majority of people using Netscape don't even
have the knowledge to do it. Your comments are not significant and
the threat is minor. If you had actually exposed a threat to the
JavaVM/Classloader model, which might be installed on a sizable
portion of browser machines, you might have a point. But since
your postingas have made it clear that you haven't read or understood
the Java papers (besides the white paper), nor have you looked at
the actual implementation, your comments are essentially meaningless.
You seem fixated on what is, a semantic argument about what "safe"
or "secure" means.  (e.g. your comments on MD5)  You expect these
words to have a binary meaning. Either something is safe/secure or it isn't.
The world is a lot more fuzzy than that.

@_date: 1995-11-20 08:11:17
@_author: Ray Cromwell 
@_subject: "Junk E-Mail" 
Is anyone else getting lots of junk e-mail lately? I'm getting all
kinds of direct marketing crap to both of my main accounts and I haven't
posted to usenet in months. I pretty much only post to cypherpunks, and
that is rarely. And I never put my real email address on web sites that
ask for them. I fear I am on some kind of direct marketing e-mail
"list". I've warned the perpetrators that if I get another ad from
them, they better expect a denial-of-service attack from me on their
site and lots of mail-bombs.
sick of the clutter,

@_date: 1995-11-30 17:29:36
@_author: Ray Cromwell 
@_subject: Netscape gives in to key escrow 
What's the point? Surely Clark must realize that even if Netscape
adds key escrow to SSL/Secure Courier, it is still possible to tunnel
real encryption through that link thus thwarting the escrow system.
In fact, this is the perfect job for Java:
1) Client connects to server thru insecure key-escrow channel and downloads
Java applet
2) Java applet opens new connection to server using "invincible" security
as Clark puts it, and performs add transactions on this channel. In fact,
in the future, a large number of "forms" will be Java applets which
submit information back to the server themselves.
  And what about IPSEC ESP? Even if the application layer is weak,
the link layer can more than make up for it.
  Now, Netscape has momentum, and if they set a key-escrow standard, there
is a chance of it being adopted widely. However, Java applets and IPSEC
can still make transactions through an insecure netscape payment/encryption
  The genie is out of the bottle.

@_date: 1995-10-03 01:36:55
@_author: Ray Cromwell 
@_subject: New Netscape bug (in version 1.12) 
C'punks,   I just got back from a vacation in Raleigh, and downloaded the
new "fixed" Netscape 1.12. It took me about an hour, but I've
discovered another bug and potential security hole. This one relates
to mailto:.
  The bug is as follows. Create a HTML file with a hyperlink containing
the following URL
 foo This bug doesn't seem to crash Netscape, instead, it crashes my XServer
as soon as the mail window pops op. I'm too tired right now to try to
analyze it, but it might be another stack bug, this time, in the X
libraries because Netscape isn't doing any sanity checking.
I need help testing this bug on other platforms. I have created
a test page. Go to to test.
I have also found 2 other bugs that cause stack trashing in v1.1
however, they are random and I haven't been able to isolate them
completely yet. (I have created a page on my system, such that if you
visit it, after you visit about 3 more pages, it crashes)
What's my point in pursuing this? Netscape's browser is a piece of
software that runs on millions of computers and in effect, allows
outside agents to input arbitrary data into that software. As such,
it is unlike most applications made. Sure, Microsoft Word may have bugs,
but how many people are downloading hundreds of MS Word documents
everyday and viewing them? Users of Web browsers are exposing themselves
like this everyday, and so I think, that web browsers must have higher
standards of robustness.
I think Netscape represents an enormous risk to computer security,
and while I think they are heading in the right direction, there are
some very basic implementation issues they need to clear up which are
orthogonal to SSL and credit card transactions. All the cryptography
in the world won't help you if someone can subvert your cryptobox.
Netscape needs to do some serious quality assurance work. I've never
been a QA person in my life, but within a few minutes, I have been
able to find serious bugs in the software. And while I'm sure
Netscape's coders are fine people, proof reading your own code,
code that you look at everyday, becomes rather hard because you
tend to "see through it". (just like proof reading essays, or messages)
I think Netscape should hire some outside firm/group to review their
code under non-disclosure for potential implementation holes.
-Ray Cromwell P.S. I am running Netscape v1.12 under BSDI2.0 and the XAccel/2.0 server

@_date: 1995-10-03 01:57:17
@_author: Ray Cromwell 
@_subject: New Netscape bug (in version 1.12) 
Thanks for the info.
  It may be a bug in BSDI's Xserver then. However, the overlong
domain bug is also a bug in the NIS code. So while the crash
may not occur within Netscape code itself, I am a little wary that it is not performing sanity checking. If it turns out to do nasty
stuff to Windows clients, then it may be significant.

@_date: 1995-10-03 02:20:50
@_author: Ray Cromwell 
@_subject: New Netscape bug (in version 1.12) 
Just tried it under NT 3.5 with Netscape 1.1. It didn't crash
as soon as the mail window popped up (like it does under my
BSDI2.0), however clicking on "send" caused Netscape to quit/die
(but not with any GPF or failure) Varying the length and data in the
mailto may have other effects.

@_date: 1995-10-03 23:13:45
@_author: Ray Cromwell 
@_subject: New Netscape bug (in version 1.12) 
That's true, but it is also true that Netscape should also be
performing some sanity checking on input rather than relying on the supporting libraries to be secure. Remember, a hole is a hole.
The last sendmail bug was a buffer overflow in syslog, however,
sendmail still got patched to do bounds checking on the strings
it was passing to syslog.   It looks like this is only bug on BSDI2.0/XAccel, and NT3.5/NS1.1. But
is it wise for netscape to be sending 10,000 character strings to GUI
functions anyway?

@_date: 1995-10-04 17:40:11
@_author: Ray Cromwell 
@_subject: New Netscape bug (in version 1.12) 
[lots deleted]
  I agree with a lot of what you say Jeff. What I would do is set the string
limits to be whatever the specs allow. For instance, in the case of
domain names, the limit is supposed to be 256. In a mailto: just what
is the limit of an RFC822 valid e-mail address?   I will say that Netscape is a very robust program. I have created documents
with 10,000 nested  lists, and the program didn't dump. I have
created forms with 10,000 selection widgets with overlong labels and variable
names and it handled them (didn't diusplay them very well) However, I am
a little weary of netscape allowing lists and forms having 10,000
levels. For one thing, although the 10,000 nested lists didn't crash
netscape, they did use up all the swap space on my computer except for
300k. A 10K byte document was able to exhaust 32megs of ram.
  When I combined supernested lists, with overlong FORM variable names,
and an extra long title, I did get a few sporadic coredumps. Some people
may have a religious position on browsers limiting SGML/HTML nested
structures (because they feel the browser should be able to handle any
"legal" document), but I for one am more pragmatic.   I hope you don't take my criticisms as an attack on your programmers.
Netscape is my all around favorite application. I just want to see it
improved and safer.

@_date: 1995-10-07 22:53:45
@_author: Ray Cromwell 
@_subject: Two bugs in CERN3.0 HTTPD 
I have not verified whether or not both of these are security holes yet, but the first one is very probably a security hole.
1) overlong domain bug in Proxy mode
Symptom: send a proxy request to the server, for instance
GET  HTTP/1.0
  This is the same bug that's in Netscape 1.1. The domain buffer
is a 256 byte buffer declared on the stack. (char host[256])
2) too many headers from CGI script
Symptom: HTScript.c allocates an array of pointers to char on the stack. This
array has size 100. The loop where they parse the output of a CGI script
is not bounds checked.  To crash the server, create a CGI script that
outputs a large number of headers before the document body.
(I simply made a perl script that did for($i=0; $i<1000; $i++) {   print "Header$i: $i\n") Although this bug can coredump the process
servicing the request, I doubt it is exploitable. All that happens is an unchecked header_line[header_index++]=malloc(some space) gets executed.
In the worst case, you overwrite the stack with excessive malloc pointers.
You may be able to cause a foreign server to crash by having your own fake
server return the exploit, and then getting the foreign server to
read the headers by issuing a proxy request to your server.
Suffice it to say, the CERN code is *littered* with temporary local
stack arrays, and I'm guessing that many of them have faulty bounds
checking (or none at all)

@_date: 1995-10-08 01:51:13
@_author: Ray Cromwell 
@_subject: Netscape 2.0 beta 
Well, it's not mentioned on their home page yet, but I went to their ftp
site and I found that Netscape 2.0 beta was up there. For those wishing
to get their hands on Java, they don't support Java on the Mac or Linux/NetBSD/BSDI platforms yet. Only Win95/NT, IRIX, and Solaris/SunoS
are supported for Java. I knew it was too good to be true for them to have
ported Java to so many platforms so quickly.
  The good news is that someone finally, after years, has implemented
Progressive JPEG (I've been yelling about it for a while myself), and it is simply *light years* better than interlaced GIFs.

@_date: 1995-10-08 13:55:44
@_author: Ray Cromwell 
@_subject: [NOISE] Caution! Netscape 2.0 and Linux 
It was released as a dynamically linked binary first, however
gazillions of Linux users who didn't purchase Motif (and hence could not
run Netscape 2.0 since it uses Motif), complained, and Netscape
put up a statically linked version immediately.
   No, the Java in Netscape 2.0 is Java BETA. The Java used in
earlier versions was Java Alpha, and Sun explicitly said that
the class hierarchy *would* change. The Java used in Netscape 2.0
is the same Java you get in SunSoft's Java development environment.

@_date: 1995-10-08 20:07:35
@_author: Ray Cromwell 
@_subject: Java 
Well those concerns are all fine and swell, but the same kind
of reasoning applies to any network application. There are buffer overflow
bugs in almost every web browser, there are overflow bugs in CERN HTTPD3.0,
and who knows, there are probably bugs in ELM/PINE. Millions of people
download software from the internet without seeing the source code
everyday and risk getting hit by trojan horses and viruses. People
make all kinds of transactions everyday where they rely on nothing more
than trust. (and a future tit-for-tat legal suit if possible) I am of
the opinion that risk is good. Java will not be perfect. There will
be holes, I'm sure of it. And each generation of web languages will be
more efficient and more secure, but none will ever be perfect. It's all
part of evolution. It's a problem that will be researched and
improved on, but you've got to break some eggs to make a cake
somewhere.   And the situation without Java is not much better. Most of Java functionality is faked with CGI scripts, usually written in perl,
and there are plenty of ways to screw up a CGI implementation to allow
  As I mentioned before, Java file i/o is not built into the language.
It is provided through a Java class you can use that implements native C code
methods. This is where the write restrictions are handled. All that is
needed to remove the ability to do file i/o is to delete this class
from your installation. It's like having C, but no standard library.
  Java is mostly a risk to consumers (the users with the browsers), and
not corporate networks who are running servers, *unless* the employees
are using Java on the firewalled network.   Java is a lot better than the situation with microsoft network, whereby
a user can send you a 386 executable, and it shows up with an icon
saying "click me" on your desktop, and clicking on it will run it.

@_date: 1995-10-09 00:12:28
@_author: Ray Cromwell 
@_subject: Netscape 2.0 beta 
Netscape should be supporting IMAP instead of POP. POP has a tendency
to hose your mailbox and lose mail every once in awhile.

@_date: 1995-10-09 21:42:35
@_author: Ray Cromwell 
@_subject: java security concerns 
I think to require formally proven implementation for something
like Java is simply unreasonable. Even if it were possible. The
whole computer market, and for that matter, most of the market as a
whole, relies on "unproven" products. Most of what you buy and use is
based on a notion of "quality" which is merely an inductive argument
that the product had no problems in the past. Everytime you buy a piece
of software and use it, you risk your security. Everytime you ftp
something off the net and run it, you are taking that risk. How do you know MS Word doesn't have security holes or trojan horses built in, have you seen the source? Software always has bugs, holes, and security flaws. It always will. If we were to require each new generation of software to be
"formally correct", software would never evolve. There is an important
feedback process between customers, software companies, and even
hackers, that drives software towards higher quality. Perfect software
implementations proven correct by mathematics is a pipe dream. Maybe
you can have higher confidence in small, simple software -- I've heard
Negroponte expressing that nostalgia for the days of word processors
that ran in 32k of ram, but frankly, I'm glad those days are gone.
   Will the IPv6 and IPSEC stack implementations be formally proven correct?     Yes, it may be possible that exploiting holes in Java will be easier
than those in sendmail, just as it is easier to exploit a hole in software on a networked machine rather than a non-networked one. But this
can not be an argument against Java or its utility. The same arguments
were raised when Postscript first came out, yet the huge benefits
of postscript are obvious, while the amount of security damage
done by it is minimal. Java will have lots of holes. It will go through
the same evolutionary progress that all software does. Sendmail was
given a chance to evolve, I think Java deserves the same
chance, given its potential.

@_date: 1995-10-09 21:50:34
@_author: Ray Cromwell 
@_subject: Java bugs found? 
Possibly because it makes applications a lot more usable if they are

@_date: 1995-10-09 23:16:10
@_author: Ray Cromwell 
@_subject: java security concerns 
There is a large class of Java apps that need no file i/o capability.
99% of all Java apps on the web right now don't save any persistent state information. I couldn't find any Java apps on the Java page that
used file i/o.  If by "stripped of i/o capabilities", you mean
that the Java interpreter is not permitted to ever call open/read/write,
not even to read in files it needs like config/preferences files or dynamically linked libraries, I'd say that's absurd. There's not many things that can be stripped of such capabilities, including postscript
interpreters, except for those which run the interpreter straight
out of rom. But it's still unclear whether those lack "i/o capabilities",
given that some postscript printers run operating systems and tcp/ip
stacks, and it is feasible for the interpreter to crash and execute
an i/o call. However, the Java interpreter can certainly be compiled
to not allow Java applets to ever do disk or network i/o. It doesn't
even take a recompile. Just delete the file i/o class.    It is certainly possible, to within a high degree of confidence,
to "box in" all i/o calls, especially if they are run in a separate
process.

@_date: 1995-10-09 23:18:01
@_author: Ray Cromwell 
@_subject: Java bugs found? 
Hehe, I dunno, but whatever you're asking, I'll undercut you as I have
it also. Unless you'd like to start an oligarchy. Let's talk. ;-)

@_date: 1995-10-10 13:58:46
@_author: Ray Cromwell 
@_subject: Netscape starts their own "Hack Netscape" contest 
Starting today, Netscape is awarding those who are first to find
security bugs in Netscape 2.0 with cash prizes. (see their
homepage for more info)

@_date: 1995-10-10 22:51:12
@_author: Ray Cromwell 
@_subject: java security concerns 
I agree, however I would point out that not all postscript interpreters
are emasculated (especially those on unix systems like IRIX, they contain
all kinds of calls to fork(), read()/open(), etc). Nothing in the
Java spec tells you that you must call fork() in a Java interpreter
implementation. In fact, Java has nothing to do with the GUI calls, the
network calls, etc. You can support as much or as little system
I/O in a Java implementation as you want. If need be, a Java
implementation could hard code all data needed from a hard disk into executable and run entirely in ram, and totally remove all file
system access. (except the implicit one needed to load and run
the executable in the first place) Even Java apps without network
or filesystem capability are useful (as graphic widgets), but I think
atleast the ability to load URLs is a good thing, and can be done
in a reasonable secure manner.
  Atleast from my reading of the Java Language Spec, and Virtual Machine,
there is no requirement that an implementation implement the File I/O
classes. Having a standardized class hierarchy is probably a good idea

@_date: 1995-10-20 00:59:29
@_author: Ray Cromwell 
@_subject: 50 attacks on Netscape - please send the check 
That would have been a fine piece of work except that Java cannot
take complete control of Netscape. It can't replace the toolbar
buttons, it can't override default protocol handlers like http, etc.
The open location button, as far as I can tell, does not have Java
hooks and will always function as it is supposed to, by stopping
all running Java threads, and going to  a new page.

@_date: 1995-10-20 12:19:49
@_author: Ray Cromwell 
@_subject: 50 attacks on Netscape - please send the check 
I'm frequently seeing this same behavior by lots of people on
this list and it's sad. There are people making claims about
HotJava/Java that are obviously bogus if you even read the white paper,
looked at the source code, or programmed a "Hello World" applet.
The Java papers are an easy read.   If you want to know about the
implementation, read the source. At least criticize specifics about
the implementation rather than speculating what they are and then
proceeding to claim to have found a security hole in the implementation.
I'm even more surprised when I see someone with a Phd acting like

@_date: 1995-10-24 15:39:02
@_author: Ray Cromwell 
@_subject: Does your software? 
Umm, your get only server sounds like it is secure, but what is the
point advertising it to this list? I could program a GET only
server in far fewer than 80 lines in just a few hours. You could
do it in even fewer lines of perl, or /bin/sh. A real HTTP server
must support all of HTTP/1.0 however for it to be considered a server.
Since yours doesn't, it isn't, it's just a toy. a better project would be
to make HTTP requests under CERN more secure.  In fact, if you don't
handle CGI, you can't handle forms, which means you can't handle
commerce securely.
secure perl "get only" server server
copy perl to a secure filesystem
have a chroot c-wrapper there
the wrapper chroot's to this directory and runs the perl script
perl is effectively boxed in
$line = ;
($method, $url, $protocol)=split(/\s+/, $line);
$url =~ s/[^a-zA-Z0-9_]/g;
if($method =~ /^GET/i)
   open(FILE, "$url");
   print "HTTP/1.0 200 OK\nContent-Type: text/html\n\n";
   print ;
   close(FILE);
exit 0;

@_date: 1995-09-06 18:58:17
@_author: Ray Cromwell 
@_subject: fast modular reduction 
Is there a proof of correctness available for this algorithm? It
looks almost like a Radix-B peasant division algorithm with some
modifications. Is there an algorithmic analysis available? I also
I think there is a bug in your description. Let k+1 = n+1
(e.g. the dividend is 1 more "block" than the modulus). Then
i=n starting out, and we have
3. Y=Y - Y[n] * B^n + Y[n] * U * B^(n-n-1)  [we have B^-1] I'm assuming
this was unintended.
How does this algorithm compare to computing the reciprocal
via Newton's Formula, and then multiplying by the reciprocal
using Karatsuba multiplication? While I was at IBM Watson I invented
a modular reduction algorithm that saves 1/4 the number of multiplications required on average once you have the reciprocal

@_date: 1995-09-06 19:05:44
@_author: Ray Cromwell 
@_subject: fast modular reduction 
I wish the damn patent offices of the world would get a clue. It used
to be when someone found a quicker algorithm, it was published in
a journal and sooner or later showed up in Knuth AoCP version x.y. Now,
every single algorithm gets patented. At the rate its going now,
"ComponentWare" of the future will mean the number of patent components
you managed to license simultaneously. The worst patent being
considered by the Patent Office right now is the dreaded Eolas patent
which purports to have invented the concept of "embedded applications"
in Web documents (e.g. Grail, Java, Safe-Tcl) and interprocess
communication between web browsers and helper applications
(e.g. NS-API/NC-API)
  The whole patent system needs to be abolished.

@_date: 1995-09-06 20:46:27
@_author: Ray Cromwell 
@_subject: Scientology and police visit XS4ALL Amsterdam 
Anyone ready to risk running a "Scientology .sig virus server"?
Here's the idea. The CoS apparently freaks out and sues anyone who
distributes CoS material, even those who quote small portions of it.
In the same spirit of the "export-a-sig-PGP" system, why not break
the CoS materials up into n pieces (each piece being 5-10 lines long)
and let people request chunks from a server to put in this .sig?
The assumption is, the Church can't sue everyone (legal funds
being limited). I think I'd do it just to piss them off.
To spread the risk around even more, I'd place the "piece server"
on k different HTTP sites just so they can't raid them all. Even
better would be to use a script on one master server to
dynamically return HTTP redirects to k different URLs to the real
servers. Another option is dynamic DNS.
Finally, you could have the server run thru email via a chained
anonymous return block. The result would be sent back thru
a remailer chain.
The nastiest thing I can think of is to get the CancelBot people to
let a massive broadcast of CoS materials be sent to UseNet. Other
options include servers which detect known CoS source addresses
and provide "fake fronts" to them. (easily doable with CGI/CERN server
and IDENT).
Cypherpunks oughta be able to figure out something to show those idiots
why their actions are ultimately futile.

@_date: 1995-09-07 01:14:50
@_author: Ray Cromwell 
@_subject: fast modular reduction 
Upon a closer look, I see there's no mistake. The algorithm will
never reach k=n because the loop stops at n+1.
 Anyway, I played around with the algorithm a little, and it's neat
and easy to implement, but the speed increase is not worth
the patent hassle (assuming there is a speed increase, I saw none)
  The algorithm is still basically O(n^2) if used in a modexp
routine. It requires n^2 multiplications and additions. Whereas,
a typical Karatsuba multiplication using a high precision
reciprocal will only use 2*n^1.5 multiplications and 5*n^1.5/8
additions. (for n=64 which is a 2048-bit number being reduced, it's about 1/5 the multiplications, but 5 times the additions)
Two other possible algorthms are:
Let P(x) = sum(i=0 to n-1) a_i x^i be a multiprecision integer
radix x.
If m is a modulus, of length n/2, rewrite P(x) as
sum(i=0 to n/2-1) a_i x^i  + x^(n/2) (a_{n/2 + i} x^i)
break the summation into two parts. Focus on the second term.
(both terms are not equal, or one digit larger than the modulus)
Perform modular reduction of the right hand polynomial using
Horner's method
x*(x*(x*...(x*a_i + a{i-i} mod m)mod m)mod m) Those internal mod m's can be done quickly with a 2-digit
trial quotient estimation.
It's still O(n^2), but might be quicker.
Still another technique..
Rewrite P(x) (a_0 + a_2 x^2 + a_4 x^4 + ...) + x (a_1 + a_3 x^2 + a_5 x^4 + ...)
[broken into two Polys with odd and even terms)
Factor out x^2 out of each piece and write
a_0 + ((a_2 + a_4 x^2 + a_6 x^4 + ...)*x^2) + x*(a_1 + x^2*(a_3 + a_5 x^2 + a_7 x^4 + ...)
Now keep applying the recursive rule until the length of the
poly pieces are the same or smaller than the modulus. Now,
start evaluating from the inner layers. Multiply each piece by
x^2 (two shifts), and take the mod. Sum the results, shifting one side by 1 (for the x factor). Shifts are free because an array representation
yields a shift with a pointer movement.
It looks kinda like the method for evaluating  FFTs a little bit,
but it's not. Just something off the top of my head just now.
(I hereby place it in the public domain assuming it's worth
anything, no patents please)  I think with a clever implementation, you can trade some mults for more adds, but still use less additions than russian

@_date: 1995-09-07 17:49:09
@_author: Ray Cromwell 
@_subject: fast modular reduction 
The n=64 implies two 2048-bit numbers are being multiplied. The 2048-bit
number comes from the fact that in a typical crypto app, modexp
will be reducing numbers as large as the modulus squared which runs
2048-bits for a 1024-bit modulus. The reciprocal is 1 block
bigger than the number to be reduced. Hence, you are dealing with
multiplying about two 2048-bit numbers. But since we only care
about the "fractional" part of the result, we can safely throw
away half the computation and only compute half the Karatsuba
recursion tree. (the number before the decimal point is the
quotient) Then, to determine the final remainder, we simply
multiply by the modulus again, throwing away non-significant
computation again. There is a normal n^2 method for reducing
via reciprocal that only uses 1/4 the number of ops as the obvious
Your right about the 1/3 vs 1/5, I dunno where the 5 came from, must
have been a typo in my calcs. The problem with Karatsuba is that it's
hard to implement efficiently. Temporary ints should be kept to
a minimum and be preallocated. The combine step requires 1 store,
and 5 additions, of multiprecision integers. The split step requires
no copying if you use pointer manipulation, and instead of shifting,
don't add in place, but add "with shift" to the destination. Most
of the implementations I've seen do too much copying and shifting.
Given that some modern processors have efficient hardware multiply,
it might not be worth all the trouble to trade mults for adds. If
a processor has an efficient hardware FFT, it might even be worthwhile
to use the FFT multiply method.
Do you have a ref for the Montgomery method? I'm unfamilar with
the name, I wonder if it's something I've seen before under
a different label.
Check out Schonhage's book "Fast Algorithms" They've implemented
all the asymtotic algorithms efficiently and gathered
performance data. I corresponded with Schonhage's grad student
and he told me that Karatsuba wins for n>=8, which I find difficult
to see, when it takes about n=32 for my own implementation (not
optimized) to break even.

@_date: 1995-09-16 19:18:16
@_author: Ray Cromwell 
@_subject: "Hackers"-- brief review and anecdote... 
I think there's a high probability of someone independently inventing
the title "hackers" for this movie rather than steal it. It's not
very original. Besides, the content of your book has very little
to do with this movie. The movie would be more appropriately
titled "crackers" or "phreakers"

@_date: 1995-09-19 00:03:38
@_author: Ray Cromwell 
@_subject: NYT on Netscape Crack 
I doubt this in the case of the browser. Atleast as far as the
parsing is concerned. There may be a buffer overflow for example,
when you input the url in the "open" window, but that has to be
done manually by the user and isn't a threat, like a "rogue homepage"
would be. The reason I doubt string buffer overflows in the case of
the browser is that it seems to be written in some object oriented
language, perhaps C++ (or maybe just oo-C like BSAFE). Once you
have a general robust String class, you can prove it's non-overflowable,
and therefore no composition of operations from the browser code will
overflow it (unless of course, you break language safety by using
casts and pointer manipulation) Secondly, Netscape has been very
robust in my own testing against these common bugs. One of the things
I've done lately is "tiger team" attacks against servers and browsers.
(of course, sendmail is a brilliant counter example)
(if you can find a call to gets() in Netscape, I will instantly retreat ;-) )
  Netscape's security maybe bad, but the rest of their browser, or atleast
their development process, is good engineering. They've built a very
complex application, fairly quickly, that runs with very few bugs,
across a wide variety of operating systems and GUI's, while maintaining
a consistent user interface and feature set. Netscape 2.0 incorporated
Java, LiveObjects, and more HTML3.0 in almost record time. (I wasn't
expecting a Java capable Netscape until atleast December). I'd like to
see Microsoft develop a piece of code that quickly that runs on
umteen different flabors of Unix, MacOS, and Win3.1/95/NT. Hell, they
can't even write code that runs smoothly across all three
flavors of their operating system.

@_date: 1995-09-19 00:34:36
@_author: Ray Cromwell 
@_subject: NYT on Netscape Crack 
Right. Some other common ones are ".." and shell meta characters
in paths. Also, accessing files that you don't have permissions
to. Even if the server is perfect, the setup could be bad. For
instance, if you use CERN's Authentication scheme for protecting
URL hierarchies, do not put the passwd/group file within the
hierarchy. I've noticed this before on some servers, like
   contains the passwd file for the
   URL directory. Although it is convenient
to store the passwd file within the hierarchy it is protecting, care
must be taken to make it unreadable by normal HTTP requests. It's better to put it in a configuration directory somewhere where no server
has access to. (I've seen this mistake plenty of times)
  A barebone's web server is a pretty simple piece of a software compared
to a browser (or sendmail), so it should be possible to make them
much more secure.

@_date: 1995-09-19 21:05:58
@_author: Ray Cromwell 
@_subject: NYT on Netscape Crack 
How would you do this if the buffer overflow happened in a buffer
which was allocated in a separate protected heap apart from stack
and executable data?

@_date: 1995-09-19 21:16:26
@_author: Ray Cromwell 
@_subject: WWW: Unabomber Manifesto 
The Unabomber's whole argument about "industrial-technological
society must continually remove freedoms" and his arguments
about the motives of scientists and technologists, are false by existence of modern cryptography and the cypherpunks.
The Unabomber's whole argument rests on his lack of imagination.
Almost all his arguments about large scalee technology were counterargued years ago on the Extropian's list. The errors
in his essay are numerous, for instance, he uses as argument,
that medical progress (if that were the only kind of technology)
would be bad in and of itself. As an example, he uses diabetes
which, if treated, allows the diseased to live longer and pass
on their genes. But most forms of diabetes happen at adult
onset longer after the individual would have reproduced anyway.
His arguments against leftists, while partially correct, are poorly
constructed and flawed too. All and all, it wasn't worth the 3 deaths and 17 years of bombings
to get tripe like this published. The Unabomber should have found
a ghostwriter friend with a degree in philosophy and got him/her
to write and publish it.
Anyway, the best way to sum up the Unabomber's fantasy world is that
people in the past had high self-esteem, they were simple and happy, and
didn't have to climb the corporate ladder. Too bad he didn't read any anthropological studies first.

@_date: 1995-09-21 22:12:06
@_author: Ray Cromwell 
@_subject: netscape bug 
Maybe I'm missing something here, but I don't see it. While it is easy
to use the "overwrite buffer and stomp on stack" method to execute code
for programs written as so
void foo(char* inputdata)
  char blah[X];
  write_to_buffer_without_knowing_length(inputdata, blah);
How would you do it for a program rewritten as
void foo(char* intputdata)
  char* blah;
  blah=PMalloc(X);
  write_to_buffer_without_knowing_length(inputdata, blah);
Where PMalloc acts like malloc, but from a separate heap. Two
other conditions further hold. All variables in this separate heap
are viewed as "tainted" since they came from user input, and can not
be used as arguments to system(), popen(), fopen(), etc.
Given this, I don't see how it is possible to cause code to be executed.
For one thing, you can't modify the stack. Secondly, since buffers
can't be used as arguments for i/o calls, overwriting nearby buffers like
char *program_path = "auxillary_program" to "/bin/csh" won't do you any
good. (note: a pointer variable should never point to data on the stack
anyway. I'm glad Java eliminated stack data. Pointers to stack data are the source of numerous bugs in C. There is a minor performance gain
to having the compiler generate the stack allocation rather than
call malloc(), but it's not worth it. Stack data has the benefit that
it is automatically deallocated upon function return. My answer is
to simply use C++ to achieve this with dynamically allocated resources)
I for one, never use scanf(), gets(), or anything that doesn't know the
size of the destination storage. It's plain stupid. I was tutoring
a student today who had allocated a 20-byte buffer on the stack and
used scanf to ask for a filename. Sheesh.
One thing that should set off alarm bells immediately whenever your
coding is a fixed size buffer justified with the idea "no one could
ever use more than Y resources." Yeah, no one could ever use more
than 11 character file names. 640K ram. 32-bit IP address space. etc, etc.
If not for security, then for simple future flexability.

@_date: 1995-09-21 23:12:30
@_author: Ray Cromwell 
@_subject: Another Netscape Bug (and possible security hole) 
I've found a Netscape bug which I suspect is a buffer overflow and
may have the potential for serious damage. If it is an overflow bug,
then it may be possible to infect every computer which accesses a web
page with Netscape. To see the bug, create an html file containing
the following:
<a href="
 o.foo.foo.foo.foofoo.bar.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foofoo.bar.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foofoo.bar.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foofoo.bar.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foofoo.bar.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foofoo.bar.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foofoo.bar.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foofoo.bar.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foofoo.bar.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foofoo.bar.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foofoo.bar.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foofoo.bar.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foofoo.bar.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foofoo.bar.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foofoo.bar.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foofoo.bar.foo.foo.foo.foo.foo.foofoo.bar.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo/foo.bar.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foofoo.!
 bar.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foofoo.bar.foo.foo.foo
 oo.foo.foo.foo.foo.foo.foo.foo.foo.foofoo.bar.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foofoo.bar.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foofoo.bar.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foofoo.bar.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foofoo.bar.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foofoo.bar.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foofoo.bar.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foofoo.bar.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foofoo.bar.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foofoo.bar.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foofoo.bar.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foofoo.bar.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foofoo.bar.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foofoo.bar.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foofoo.bar.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo.foo> blah On my BSDI2.0 machine running Netscape 1.1N, this causes a segmentation
fault and subsequent coredump. GDB reports nothing useable (stripped
As you can see, I just chose an extremely long domain name. I guessed
that the authors of netscape probably thought something like "well,
a buffer size of 256 characters is good enough to hold any domain"
It's definately the domain that's causing it, and not the length of
the URL or the data after the domain name.
I also tried to overflow some netscape servers using similar techniques
(and shell metacharacters in all sorts of URLs), to no avail. I suspect
a similar attack may work against the Netscape Server if it is proxying.
Does anyone have a disassembly of Netscape, or more specifically, a disassembly of the URL parse and domain lookup routines? I'd be
happy to collaborate and "Hack Netscape" ;-)
Happy Hacking,

@_date: 1995-09-21 23:26:39
@_author: Ray Cromwell 
@_subject: Netscape bug update 
I just verified in GDB using a stack trace that the Netscape overflow
bug I mentioned is indeed a static stack buffer overflow. It trashes
the stack.
  What this means is that in theory, it is possible to get a simple
URL, if clicked on, to execute some code on someone's browser.
  Now the hard work begins...
Happy Hacking,

@_date: 1995-09-22 00:15:47
@_author: Ray Cromwell 
@_subject: Another Netscape Bug (and possible security hole) 
The bug causes random things to happen because it trashes the stack. I
just did a test with  pattern 42 times, followed by
5 a's), that's 341 characters in the domain. After a coredump, I inspected
the stack, and it has been trashed to hell, including the PC register
which was 0x61616161 (or 'aaaa' in ascii)
THIS IS A SERIOUS BUG!
Unlike the SSL crack (which took a supercomputer to crack), or
the RNG (which doesn't affect many people since there is not much
internet commerce actually going on), this bug has the potential
to damage millions of computers! This is almost enough to scare me
away from using netscape. You can guard yourself by always observing
the URL you are about to click on, but how many people will be
able to keep that up all the time given that Surfing almost
puts many people into a trancelike state?
[I hear Perry in the background groaning and muttering "I told you so"]
These buffer overflow bugs should be taught in every programming
101 course along with fencepost errors.
I'm not even sure if I want to write the obligatory program to exploit
the hack given that some malicious jerk would probably use it
on his home page to attack people.

@_date: 1995-09-22 01:20:30
@_author: Ray Cromwell 
@_subject: Netscape Server Attacks 
No, calmdown,  I haven't found a hole in the server yet, but if you
want to win some T-Shirts, here's some potential avenues to try. I've
been messing with these, and maybe some other c'punk can find
one that will work.
1) buffer overflow attacks in the HTTP request header
Example: The HTTP/1.0 full request has an "If-Modified-Since" header
which takes a date string. If Netscape assumes this string is not going
to be longer than a certain width....
Look for ways to attack the HTTP request headers. See
CGI attacks
2)Shell metacharacters, or extremely long paths, may lead the way to
executing arbitrary shell commands on the server.
3) Overflow the URL in a CGI GET by using too many form variables in
the response. Server attacking client
4) use the Location: redirection header to send a long domain
5) use Location: redirection or Refresh: to load up file:localfile
   You can force the browser to load up any arbitrary file the user
   has access to local to his client
  Example:     Refresh: 1 file:config.sys
6) send back a page with an EXTREME number of Motif HTML FORM widgets
in a . E.g. send back 10,000 radio buttons.
Happy Hunting,

@_date: 1995-09-22 01:30:13
@_author: Ray Cromwell 
@_subject: YET ANOTHER BAD NETSCAPE HOLE! 
Good question. My guess is, Netscape doesn't do any processing on the
mailto: hyperlink at all, but merely passes it to a real mail delivery
agent like Sendmail (or it uses MAPI under Win'95). Which begs
the question, if Netscape is executing an external delivery agent,
there may be the possiblity of sneaking an attack in there and getting
the shell to execute something.
Hmm, let me try something.
WOW!! Unbelievable! Stop the presses! I Can't believe no one ever discovered
this before! Try a page with the following URL
 test Muahaha! Yet another security hole! Clicking on this mailto brings up
an xterm on my machine!  Simply change the xterm& to "rm -rf /" and
Sheesh. I better stop before I am on Netscape's most hated list.

@_date: 1995-09-22 01:37:09
@_author: Ray Cromwell 
@_subject: YET ANOTHER BAD NETSCAPE HOLE! 
Disregard that last message. Those drugs I was taking must have just kicked
in. I was running another program in the background which coincidentally
brought up an xterm at the same time I clicked on the link. Damn,
and I thought I had found another bug. Ah well. There's probably one lurking
there somewhere. It was good while it lasted. When I hit "send" and
that xterm popped up, I almost jumped out of my seat. ;-) Remember
this lesson, you should always try to repeat your bugs atleast three
times. ;-)

@_date: 1995-09-22 02:36:12
@_author: Ray Cromwell 
@_subject: YET ANOTHER BAD NETSCAPE HOLE! 
No problem.  ;-) I congratulate you guys (Netscape) for reacting so quickly. ;-)
  BTW, I checked lynx for the big domain bug and it also crashes. It could
be a unix bug, but my own test program fails to crash looking up a
1000 character domain. Even so, Netscape should be enforcing a
sanity check on the domain.

@_date: 1995-09-22 10:14:04
@_author: Ray Cromwell 
@_subject: Another Netscape Bug (and possible security hole) 
Yeah, I guessed that. I'll work on it, I have a few doubts I have
to research first. For instance, how to embed code in the domain that
1) server/client processing won't "cook" and 2) contains no isolated
zero bytes which would null terminate the string.
  My current idea is to look in Netscape for an "exec" routine,
and call it passing a "/bin/csh" to it.
  Irregardless, it's a nasty bug given that you can crash anyone's
netscape. And on Mac/Win3.1, it may even require a reboot.

@_date: 1995-09-22 10:29:48
@_author: Ray Cromwell 
@_subject: YET ANOTHER BAD NETSCAPE BUG (no it isnt!) 
Just another reminder that the second bug I posted about was a fluke
on my system and not a real bug. I'm hoping that putting the reminder
in the subject will stop people from forwarding it on to other
lists before reading the retraction. Although this was a false bug,
the overflow bug is very real and verified.

@_date: 1995-09-22 13:19:13
@_author: Ray Cromwell 
@_subject: Another Netscape Bug (and possible security hole) 
Did you check 0x20 and 0xa0?  (space and shift-space) I'm sure
that a space will terminate the href in .
   I've been playing around with Netscape today and I achieved two
things. First, I've isolated a routine very near to where it crashes
(if I set a breakpoint in GDB, it only hits the breakpoint when a domain
is looked up by any method) Secondly, even without disassembly I've been
able to place an exact value in the PC register (0x61616161). Now,
all that's left is to 1) find out where the stack pointer is,
2) make the PC point to some area near the stack pointer, and 3)
create some code which does a syscall on execve with "xterm" as
the argument, with the restriction that it cannot contain any of the
above illegal codes.  is the hardest for me since I've never done
assembly under BSDI but I assume it's some sort of trap call I need
to do.
  Once all that is done, just package it up into a URL and you are set
to wreak havoc.
  If someone else exploits the hole before I do, I would urge you not to
reveal the exact implementation to any mailing lists for the simple
reason that even a benign exploitation can be easily modified to be
dangerous. Security through obscurity, I know,  but think about it.
Once you have the URL,  anyone can exploit the bug by pasting it into
their home page. And with the way the net works, this would probably
seem "cool" to most people and it would spread like wildfire. If
you don't reveal the implementation, then perhaps that will buy enough
time for most users to upgrade to Netscape 2.0 before crackers start
exploiting it.
[this bug is far more dangerous than the RNG bug or the 40-bit crypto]

@_date: 1995-09-22 22:16:31
@_author: Ray Cromwell 
@_subject: Another Netscape Bug (and possible security hole) 
You could make a worm out of this Netscape bug by having it look
for a user's homepage when it infects, and then inserting the
URL into that page.

@_date: 1995-09-24 23:49:16
@_author: Ray Cromwell 
@_subject: New Netscape RNG 
I just glanced at the new Netscape RNG source. I don't really see
anything bad, but I haven't analyzed it. However, I'm curious
as to why variables like the username or the language locality
are used as sources of entropy. These seem to provide almost nil.
The username is going to be pretty much constant. In fact, even
the current directory which is used as a seed can't provide more
than a few bits of entropy. In all probability, the user
name will usually be the same, and so will the current directory
(and how many directories are there? 65,000 would only give you
16 bits of entropy, assuming you get a directory listing from the machine)
 I'm thinking from the standpoint of someone gathering data on someone
or some server to mount a specific attack. a "most common directories
on the macintosh" file for instance could be used to attack the
current directory method.
  Using those sources probably can't hurt, they just seemed
like odd choices, "grasping for straws" so to speak.
  Nevertheless, I would like to commend Netscape for releasing
the source code for public review. You guys are clearly an intelligent
company, in both your current developments, but also the way
you have handled this bad press.
p.s. i hope you guys do a good internal review of your code to remove
buffer overflow bugs

@_date: 1995-09-26 06:10:22
@_author: Ray Cromwell 
@_subject: Hack Microsoft? 
Microsoft recently got C2-security status approved for Windows NT by
the National Computer Security Center, a division of the NSA. They
are supposed to put systems through "laborious testing and review" before
they approve C2. So, if one can find bugs in NT's security, one can
toss a little more egg on the NSA's face and the sham that part of
their activies to *help* to secure american computers. A simple
violation of NT's C2 status would be to demostrate a flaw in it's
memory protection implementation. Personally, I think NT is
*riddled* with bugs waiting to be discovered. Hell, even the
NT "service pack" is included in the C2 status, which I bet
has plenty of holes.
  If Cypherpunks can find flaws that the NSA can't, or won't divulge,
what does that say about their so-called COMSEC ability.

@_date: 1995-09-26 06:21:38
@_author: Ray Cromwell 
@_subject: Decompiling Netscape 
I've managed to find a URL which can place an arbitrary value in
the PC register without disassembly. What I did was make  a URL
then, when Netscape coredumped and the PC gets modified, I look
at the PC, say 0x54535251 and see that it is QRST, so I place
the PC register there.  Now all I need is some 386 code under
BSDI2.0 to do an execve.
I just wrote a simple execve in C, compiled it, and stole the appropriate
magic kernel library invocation sequence. What I need to do now is 1) find out the approximate address of the stack pointer,
2) generate some code that has a whole lotta NOPs, followed by the
execve sequence, and finally, preface all that by a PC value that
will hopefully land somewhere inside that field of NOPs on the stack.
And all this has to be done without using any characters which will
stop netscape from reading in more pieces of the domain string.
You might be able to use the same techniques to whip up a quick exploit
on your systems. By far, the best exploits will be on the Mac and
Windows (especially), because those make up the majority of people
using Netscape. Create an exploit on Windows, and stun the world.  ;-)

@_date: 1995-09-26 20:38:18
@_author: Ray Cromwell 
@_subject: Status of Netscape Bug Exploit (suggestions needed) 
Ok Folks, here's what I got so far...
1) a URL that can place a specific value in the program counter
(gdb) select-frame 2
(gdb) info frame
Stack level 2, frame at 0xefbfbc30:
 eip = 0xefbfbc30; saved eip 0x90909090
 ^^^^^^^^^^^^^^^^
 called by frame at 0x90909090, caller of frame at 0xefbfbc14
 Arglist at 0xefbfbc30, args:  Locals at 0xefbfbc30, Previous frame's sp is 0xefbfbc1c
 Saved registers:
  eax at 0xefbfbc2c, ecx at 0xefbfbc28, edx at 0xefbfbc24, ebx at 0xefbfbc20,
  ebp at 0xefbfbc18, esi at 0xefbfbc14, edi at 0xefbfbc10, eip at 0xefbfbc0c,
  ps at 0xefbfbc08
2) A piece of exploit code on the stack near the PC
(gdb) disassemble 0xefbfbc10 0xefbfbc40
0xefbfbc27:     nop    0xefbfbc28:     nop    0xefbfbc29:     nop    0xefbfbc2a:     nop
0xefbfbc2b:     nop    0xefbfbc2c:     nop    0xefbfbc2d:     nop    0xefbfbc2e:     nop    0xefbfbc2f:     nop    0xefbfbc30:     nop    0xefbfbc31:     nop    0xefbfbc32:     nop    0xefbfbc33:     nop    0xefbfbc34:     nop    0xefbfbc35:     nop    0xefbfbc36:     nop    0xefbfbc37:     nop    0xefbfbc38:     nop    0xefbfbc39:     nop    0xefbfbc3a:     nop    0xefbfbc3b:     nop    0xefbfbc3c:     nop    0xefbfbc3d:     nop    0xefbfbc3e:     nop    0xefbfbc3f:     nop    0xefbfbc40:     nop    3) exploit code that calls the kernel syscall() with SYS_exit
  (benign exploit, causes your browser to exit)
The problem? To make a syscall under BSDI2.0, I have to execute
an lcall 0x7,0x0 with 1,0 on the stack. However, to exploit the netscape
bug, you can not embed 0x0 in the URL. No problem I thought, I searched
Netscape's executable for any kernel calls, and found an lcall 0x7,0x0
at 0x257fee. But I can't do a 32-bit direct jump without a zero,
in the instruction (the 32-bit address is 0x00257fee), and I can't
do a relative jump from 0xefbfbc30+ If you can come up with some 386 assembly under BSDI2.0 which can
invoke syscall() in the kernel without any embeded 0x0 bytes
in the code, you can share a Hack Netscape T-Shirt with me.
If it turns out to be too hard under BSDI, I'll gladly assist
in producing exploits for Windows or another operating system.
One trick I thought up for embeding zeros in the code is to self-modify
the code using XOR ADDRESS,ADDRESS where ADDRESS is a byte on the stack
within the code.
Anyone have any better ones?

@_date: 1995-09-26 23:19:34
@_author: Ray Cromwell 
@_subject: Wild Idea for RNG 
Ok, so I'm reading a message somewhere and I see a message about
algorithmic information theory. Cryptography was recently on my
mind and I thought of Chaitin's quote "arithmetic is random"
So, why not construct a turing machine with a large state transition
table, input a random program, and get a 1 or 0 bit depending on
whether it halts in X number of cycles. You could even get more
than 1 bit out of it by measuring how many cycles it takes to halt
(if it halts before X) and use the LSB. Is it as secure as
the halting problem? (intractable to devise an algorithm used
to predict a bit with more than 50% confidence if you knew the
state table?) Ok, so it's impractical.
So how about this:
Grab a picture of the current bitmap on your screen. Run it through
a good compression algorithm (say, an arithmetic/Q-coder or
one of the LZ schemes). Grab the LSB of every 4th byte or so.
If the screen is size 1024*768*8, that's 786432 bytes. Let's assume
a 10 to 1 compression ratio = 78643 bytes. Let's assume you take
1 bit from every 10 byte, that's 983 bits of entropy.
The screen will often contain data like:
random placement of icons and windows
current time
current applications running, and the data in their windows
If Netscape was running for instance, part of the random bits
would come from the bitmap representation of the data in Netscape's
window which would depend on the URL being displayed.

@_date: 1995-09-26 23:26:40
@_author: Ray Cromwell 
@_subject: Coercion-proof remailers (solved?) 
This idea is similar to an approach I posted a month or so ago
entitled "anonymous name resolution" which uses shamir sharing
to break up the recipient's address so that there is no first remailer
to coerce.
  The idea is that you should not deliver to e-mail addresses on
the remailer network, but to "handles", these handles will be
distributed across a DNS-like system that splits up the handles
using shamir sharing. No server stores the handle->email mapping,
but the whole network can perform the mapping. Remailers don't deliver
the message to the final destination, but deliver pieces of the
message to the anonymous name resolver network which perform the
final delivery.

@_date: 1995-09-27 02:21:27
@_author: Ray Cromwell 
@_subject: WSJ on Netscape Hole 3 
Are you sure that Netscape uses an implicit stack for this,
rather than an explicit stack? If they use an explicit stack for
the "web tree", than your argument doesn't apply. In fact, I guess
that they do use an explicit stack, because it makes implementing
the "History" menu which shows the last couple of links much easier.
I guess that they use some sort of "ring" structure which is
a dequeue or plain array, so that after a certain "depth", states
are written over and "scrolled off"
  Also, if they used an implicit stack, all it would do is increase
the uncertainty of where the stack pointer is. However, by
inserting enough NOPs into the exploit code, you can virtually insure
the exploit code will be executed. Even if you are off by 64kbytes,
you can insert 64kbytes of nops which isn't much. My own testing
doesn't bear out your theory. I rarely changed the position of the overflowed stack frame by more than 200 (after following 3 nested links
to my exploit link). I included 256-512 nops before my exploit code.
  How about creating a .rhosts file with your name in it?
  Or, on Windows machines, inserting a virus?
  If an exploit is possible, any exploit is probable, given that a clever
encoding of assembly instructions can be created for any code required.

@_date: 1995-09-27 02:37:36
@_author: Ray Cromwell 
@_subject: getting netscape to support the remailers 
Yes, a while ago I was working on this, but I dropped it as people
didn't seem interested. It was part of my whole "Remailer 2.0" proposal
(before mixmaster was written)
  I was studying ways to make it easier for mail readers to interact with
remailers, in particular, messages which were split, padded, packetized,
and sent along separate chains. All this without some kind of special client. I wanted to use the multipart/partial part of MIME to have
the pieces combined at the recipient end and decoded using an
application/remailer or application/pgp type. (this was also
before PEM was worked on) So I had a lot of work to do in standardizing
stuff. I started working on a remailer which combined those facets,
and also
1) a remailer network which had strong authentication between remailers
so that untrusted remailers could not get in the network (web of trust
for remailers)
2) my virtual handle idea
3) strict addressing for virtual handles on the remailer network
(e.g. set up an explicit chain to anonymous bob by mailing to
remailer1 Also, if you add
a '*' in the path, it means for the remailer to choose a random
remailer as the next in the chain)
4) padding, packetizing, delayed delivery, creating artificial traffic to    thwart traffic analysis
5) a built in keyserver and "list of active remailers" server.    The list of active remailers server would also contain flags
   for each remailer detailing what it supports and special
   flags like if the machine is multiuser, single, firewalled, offline (UUCP    connection only), etc. I wanted as standard, that every remailer
   could serve keys or atleast tell you what other remailers were active
6) socket connection for commanding the remailer so that you can bypass
   sendmail logging and get error/status on the message
7) direct SMTP delivery bypassing local sendmail logging
I wanted to use multipart MIME to allow remailers in a network
to be run from user accounts in such a way that they wouldn't accidently get
mail intended for the remailer and they wouldn't have to bear
responsibility for the mail sent (only the whole machine would, as it would
be delivered via SMTP direct, not sendmail, so no local logs)
Nevertheless, like many things, I completed about 60% of it and it got
put on the back burner never to emerge. Mixmaster came along and I figured there's no point continuing.

@_date: 1995-09-27 21:58:52
@_author: Ray Cromwell 
@_subject: Patch release of Netscape available 
Does this release patch both the RNG and the overflow bugs or just
the RNG?

@_date: 1995-09-30 08:57:58
@_author: Ray Cromwell 
@_subject: Ray Cromwell: Another Netscape Bug (and possible security (fwd) 
Its not a global overwrite on my system. It is very definately a stack
frame overwrite. Ive already put code ony my stack using a URL
so I know its a stack problem.

@_date: 1996-02-11 12:42:24
@_author: Ray Cromwell 
@_subject: The Decense Project 
The Decense Project
  A few days ago I was reading Clarinet Newsbytes Top news. It read
like something right out of 1984. "Germany cracks down on AOL and
Compuserve", "Japan busts Japanese porn web site", "French bans web
sites with banned book", "China issues internet regulations", and
"Clinton signs Telecom bill" The other shoe is starting to drop. The
ante has been raised as governments around the world are trying to
control the content of the Internet. But the politicians writing this
type of legislation have no clue what they are really dealing
with. They are are part of a centralized organization with a
centralized philosophy trying to cope with something inherently
decentralized, non-physical, and constantly evolving. We all know the
genie is out of the bottle. Let's write some code to keep it that
Enough of the rhetoric.
Decense is the name of what I hope to be, a family of software protocols
designed to "decensor" the net. I'm contributing the first, and I hope,
most useful piece. I hope others will join me in developing this software,
making it more robust, and distributing it across the net.
What is Decense?
The first piece of the Decense software is designed to provide "penet" like
double-blind anonymous transactions for the http protocol. It is written
as a cgi-bin script which provides a seamless mapping between anonymous
ids and remote web servers. Servers running Decense can be chained like
anonymous remailers to increase site level security.
Decense works as follows.
The server maintains a database mapping anonymous ids to url directories.
For instance 'foo' -> ' as an example. The anonymous ids are
stored as md5 hashes so that if the site is ever compromised, the db
cannot be used to get a complete listing of all anonids<->sites. The
attacker is forced to hash and compare each one he is looking for. [yes, he still gets a listing of all the urls, but chaining takes care of
that to some extent. In the future, I want to use the unhashed 'anonid' as a key to a symmetric cipher to encrypt/encrypt each url field of the database.
The db would be stored as (hashed(anonid), DES/IDEA(anonurl)
                               ^ key            ^ value       ]
A url is constructed as follows
Decense will lookup the anonid in the database, and map it to a url, such
as " it will then append the relative url portion yielding
It will proceed to fetch the document at that URL. If the document is
an html or text file, it will scan the file replacing any references to
the remote server with the decense url.
Let's say I am running decense at  with an anonid of 'c2' which maps to If I then request and index.html contains the following URL
the URL will be changed to in the returned document.
Future plans for Decense
  I am heavily loaded down with work right now. But future versions of
Decense should have
1) the ability to filter out mailto: and instead, substitute in a url
pointing to a post/mail cgi-script which sends mail to the real recipient
through an anonymous remailer chain.
2) the ability to proxy through SSL servers for encryption
3) the ability to handle authenticated urls properly
4) the ability to handle a document being located on multiple sites, with
optional shamir sharing, so that a site is a) either picked at random
to retrieve a document or b) a portion of the sites are picked, and the
document is fetched and reassembled via a sharing protocol from those
sites.    I will release source code in about a day, I'm now alpha testing it.
If you would like to contribute to Decense, send mail to    rcromw1 at gl.umbc.edu
rjc at clark.net

@_date: 1996-02-11 16:08:54
@_author: Ray Cromwell 
@_subject: The Decense Project 
The same people who are running the anonymous http proxies. If you've
got a T1, it's not much of a problem. And for some people, privacy is
a selling point, like Sameer's c2 system.  Also, let's say NOW
wants to put up a site with abortion information. They could pay a set of
anonymous proxy servers for the "service" of providing a anonymous mapping
service for them. And of course, all the various CyberPorn companies,
many of whom may have their business illegalized, will want to pay for such a service. Especially, if the proxies are offshore.
   I'm not really concerned about who will want to provide the service.
I think there are many individuals who would. I'm concerned about making
the software available. Inline images could always be turned off in the
script if need be.

@_date: 1996-02-12 05:42:57
@_author: Ray Cromwell 
@_subject: Decense v0.10 alpha available 
I've made Decense v0.10 alpha available publically. There's a few
non-critical things to be fixed and plenty of features to be added.
I have other obligations at the moment, so I can't spare anymore time
right now to polish it up. If you're a perl hacker, take a look at it.
The Decense Project homepage is You can retrieve the tarfile there.
Have fun, and Write Code!

@_date: 1996-02-24 07:02:45
@_author: Ray Cromwell 
@_subject: opps, sorry about that last post 
I'm not really unsubscribing, I'm moving to a new host. Sorry about
the noise.

@_date: 1996-01-22 05:31:27
@_author: Ray Cromwell 
@_subject: Microsoft to digitally certify other manufacturers' code? 
The question is, if Microsoft is proposing this to the W3C and IETF, will
they provide a reference implementation with source freely available? Microsoft
has a habit of proposing "open" standards, of which they have the only implementation, which quickly becomes a defacto standard along with
any "extensions" they make.
