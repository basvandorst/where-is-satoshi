
@_date: 1995-07-12 10:00:16
@_author: Jonathan Shekter 
@_subject: general RC4 key searcher: optimisations anyone? 
and just about every other OS known to man, so it's a moot point.
vector elements) then this xor trick requires three read-modify-write cyles --
slow on any architecture. Use a temp variable instead.
long, starting at either 0x00010203 or 0x03020100 depending on endianness,
 adding 0x04040404 at each iteration to generate four bytes per shot. Remember,
on most machines a 32-bit store is the same speed as an 8-bit store. The fastes
I have been able to do on this section was obtained by unrolling the loop
manually, and using *two* long variables, alternating, to remove instruction
1) This loop needs to be unrolled! Using direct array offsets instead of
incrementing the counter is a speedup on many machines. Also, experiment with
the unroll size. Making it larger increases performance until you get too big
to fit in the cache, at which point it slows down. My experiments on a few
different types of machines showed that unrolling the inner loop 16 or 32 times
was usually about right. See the inner loop of bruterc4. Use macros to do the
2) You can avoid the if statement for checking for key wrap around as follows:
in your initialization, construct an array as follows:
for (i=0; i/* do two RC4 operations as a preliminary test. If this fails then test
  Again, swapping with xor probably hurts you here. Use a register temp
 slower than bruterc4. So it can be done.

@_date: 1995-07-13 14:46:17
@_author: Jonathan Shekter 
@_subject: SSL RC4 challenge 
Quoth tedwards at src.umd.edu:
pair. Since the format of SSL is known precisely, we won't have this problem.
