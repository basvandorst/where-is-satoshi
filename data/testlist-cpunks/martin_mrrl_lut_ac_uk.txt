
@_date: 1995-08-11 07:07:41
@_author: Martin Hamilton 
@_subject: PRZ encrypted voice software release imminent 
AudioFile could be one way around the proprietary audio device problem - have a look for "AF" on archie

@_date: 1995-12-22 07:48:35
@_author: Martin Hamilton 
@_subject: Navy hacked by Air Force? 
To combine two favourite threads - it's that sendmail 8.7.3 hole *they* don't want you to know about...!
Cheerio, (and Merry Xmas :-)

@_date: 1995-07-17 00:35:40
@_author: Martin Hamilton 
@_subject: Free The World Web Server project.. :) 
Plus - choose the fonts & point sizes at random too ? :-)

@_date: 1995-09-14 12:44:21
@_author: Martin Hamilton 
@_subject: MOSS [IETF privacy-enhanced mail, modified for MIME] now available 
Just wondering - is anyone working on a profile for PGP under MOSS
and/or the multipart/signed and multipart/encrypted body parts ?
Whether or not they are, it would be useful to have a de-facto
standard for the use of PGP with current MIME implementations.  I
recall there was a draft RFC by Nathaniel Borenstein which dealt
with this, but it was withdrawn to leave the way clear for MOSS ?
Why bother ?  Well, there are lots of mailers out there with "some"
MIME support - enough for launching a helper application to read
and perhaps compose (say) application/pgp, but not nearly enough to
handle MOSS.  I'm thinking about commercial offerings for the likes
of MacOS, DOS, and Windows in particular.  It seems like a really neat hack to use the MIME support to bring PGP in by stealth, but
perhaps most of the implementations Out There are too crippled ?
Over to you... :-)

@_date: 1996-04-07 06:05:31
@_author: Martin Hamilton 
@_subject: pgp keys 
It would be neat if individual Internet sites could run their own key servers in a distributed framework, using whatever protocol(s) they wanted to.  Finding someone's public key shouldn't be rocket science - if you already have their email address.  Checking the signatures might be, though ?
The pgp.net folks have established the convention of "keys..pgp.net", which lends itself to a simple algorithm along the lines of...
  Email address:
    martin at mrrl.lut.ac.uk
  Look for:
    keys.mrrl.lut.ac.uk.pgp.net
    keys.lut.ac.uk.pgp.net
    keys.ac.uk.pgp.net
    keys.uk.pgp.net
    keys.pgp.net
I'm not clear on whether it would be friendlier on the DNS to start with the least specific cases and move down to the most specific (i.e. reverse the order of the steps).  The latter would seem to result in less junk (NXDOMAIN responses) being kept by DNS servers which implement negative caching.
Keyservers might be reasonably be expected to speak a number of protocols ?  e.g. mail to "pgp-public-keys", finger, and perhaps a dedicated key lookup protocol ?
OK so we're lacking a mechanism for indicating things like which protocols/services a host supports, on which port numbers, etc...  Perhaps it isn't even something we should be thinking about in relation to key servers ?  In any case, lots of new DNS RRs have been proposed which could handle the problem - but not implemented or deployed :-)
As a quick hack, I suppose the embedded URL scheme used by Netfind could be nicked and put to use for public key servers, e.g. in   foreach (text record at keys..pgp.net) {
    next unless /^kx-/;     # only interested in kx-
    s/^kx-//;               # toss Key eXchanger prefix out
    &do_something_with($_); # use resulting URL
  }
Do people have any opinions about these ideas ?  Obviously the DNS is going to be vulnerable to spoofing, so those URLs may be dodgy.  If we're checking the signatures aggressively this needn't be a problem, at least in relation to serving up public keys ?
If anyone knows of a forum where this stuff is being discussed, I'd appreciate a pointer.  Would be happy to set up a dedicated list if there isn't anything already.  FWIW, I don't seem to see any discussion on cypherpunks, coderpunks, spki, ietf-pkix, ietf-asid, ietf-ids, ...

@_date: 1996-12-26 12:16:14
@_author: Martin Hamilton 
@_subject: ssh + GNU win32 = !!! 
There's a first stab at that Win32 port of ssh that I've been promising
up for FTP at: It's not pretty, but it does just about work - though cf. the list of
caveats in the README.  I'll have a go at making this more of a clean
port and less of a quick hack after the New Year :-)
In the meantime, consider this: the Cygnus port of the GNU developers
tools will let you build DLLs.  And it's free, of course...  Should
make building PGP as a DLL a reasonable proposition, methinks -
 for more info. Merry Xmas!

@_date: 1996-11-21 00:37:14
@_author: Martin Hamilton 
@_subject: anonymous proxy server in 100 lines of Perl (fwd) 
I'm sure this could be squeezed onto one line.  Sheesh - comments even! :-)
------- Forwarded Message
No cookies.  No referer.  No From.  All we need is a dozen of these
around the planet. :-)
Gisle, thanks.  You truly are "the wizard of aas". :-)
And yes, this is the code for the next Web Techniques magazine column.
 -Tw
use strict;
$ENV{PATH} = join ":", qw(/usr/ucb /bin /usr/bin);
 Copyright (c) 1996 by Randal L. Schwartz
 This program is free software; you can redistribute it
 and/or modify it under the same terms as Perl itself.
 Anonymous HTTP proxy (handles http:, gopher:, ftp:)
 requires LWP 5.04 or later
my $HOST = "localhost";
my $PORT = "8008";
sub prefix {
  my $now = localtime;
  join "", map { "[$now] [${$}] $_\n" } split /\n/, join "", $SIG{__WARN__} = sub { warn prefix  };
$SIG{__DIE__} = sub { die prefix  };
$SIG{CLD} = $SIG{CHLD} = sub { wait; };
my $AGENT;			# global user agent (for efficiency)
BEGIN {
  use LWP::UserAgent;
   = qw(LWP::UserAgent); # set inheritance
  $AGENT = MyAgent->new;
  $AGENT->agent("anon/0.07");
  $AGENT->env_proxy;
sub MyAgent::redirect_ok { 0 } # redirects should pass through
{				 MAIN   use HTTP::Daemon;
  my $master = new HTTP::Daemon
    LocalAddr => $HOST, LocalPort => $PORT;
  warn "set your proxy to url, ">";
  my $slave;
  &handle_connection($slave) while $slave = $master->accept;
  exit 0;
}				 END MAIN sub handle_connection {
  my $connection = shift;	# HTTP::Daemon::ClientConn
  my $pid = fork;
  if ($pid) {			# spawn OK, and I'm the parent
    close $connection;
    return;
  }
   spawn failed, or I'm a good child
  my $request = $connection->get_request;
  if (defined($request)) {
    my $response = &fetch_request($request);
    $connection->send_response($response);
    close $connection;
  }
  exit 0 if defined $pid;	# exit if I'm a good child with a good parent
sub fetch_request {
  my $request = shift;		# HTTP::Request
  use HTTP::Response;
  my $url = $request->url;
  warn "fetching $url";
  if ($url->scheme !~ /^(http|gopher|ftp)$/) {
    my $res = HTTP::Response->new(403, "Forbidden");
    $res->content("bad scheme:     $res;
  } elsif (not $url->rel->netloc) {
    my $res = HTTP::Response->new(403, "Forbidden");
    $res->content("relative URL not permitted\n");
    $res;
  } else {
    &fetch_validated_request($request);
  }
sub fetch_validated_request {
  my $request = shift;	# HTTP::Request
   uses global $AGENT
   warn "orig request: <<<", $request->headers_as_string, ">>>";
  $request->remove_header(qw(User-Agent From Referer Cookie));
   warn "anon request: <<<", $request->headers_as_string, ">>>";
  my $response = $AGENT->request($request);
   warn "orig response: <<<", $response->headers_as_string, ">>>";
  $response->remove_header(qw(Set-Cookie));
   warn "anon response: <<<", $response->headers_as_string, ">>>";
  $response;
------- End of Forwarded Message
