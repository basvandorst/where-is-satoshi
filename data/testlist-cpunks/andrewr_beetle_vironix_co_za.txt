
@_date: 1995-09-19 15:45:31
@_author: Andrew Roos 
@_subject: A Netscape Server implementation error 
Hi Sameer
Thanks in advance for the T-shirt, and I like the Web site. On the   subject of Netscape implementation errors, I note that the SSL protocol   specification states in section 5.6.1 (CLIENT-MASTER-KEY) that "It is   also an error if CLEAR-KEY-LENGTH is non-zero and the the CIPHER-KIND is   not an export cipher".
However, I note that Netscape Commerce Server 1.1 will happily accept a   "secure" connection using the non-export cipher SSL_CK_RC4_128_WITH_MD5,   even if the CLEAR-KEY-LENGTH is set to 16 and the *entire* master key is   sent unencrypted.
Here is an extract from an SSL session with  which   illustrates the oversight:
 ------------------------------- Start of Session    ---------------------------
(1) The session was initialised as normal, and the following values were   exchanged in the SERVER-HELLO and CLIENT-HELLO:
a2 ff 2e 94 8d f9 f4 e2 2c f6 bd ae 7f 47 db 6c
Connection id:
ef 47 3b 44 db d9 8d 1a f0 da 3e 14 73 97 a3 1f
(2) I then sent the following CLIENT-MASTER-KEY message, which is   reproduced in full:
SSL Record Header:
80 9a
Message type: SSL_MT_CLIENT_MASTER_KEY
Cipher kind: SSL_CK_RC4_128_WITH_MD5
01 00 80
Clear key length: 16
00 10
Encypted key length: 128 bytes
00 80
Key arg length: 0
00 00
Clear key data: the *entire* master key sent in the clear
af 24 2e e8 2b b1 75 d1 27 a2 b8 76 8b 49 c3 f3
Encrypted key: this is a zero-length block formatted using PKCS block   type 2 and encrypted under Netscape's public key. Since it contains no   data, an eavesdropper would not need to decrypt it in order to decrypt   the rest of the session.
af 24 2e e8 2b b1 75 d1 27 a2 b8 76 8b 49 c3 f3
9b 9b 0b ff cd e8 2f 2c 0d 16 4e 90 73 26 4e e7
e0 3f 45 8a ce 9a 21 d6 2a 6b b8 9a 20 4e bc cf
d0 01 36 86 1c db e0 8b a8 e3 4c 9b 15 11 ea 95
b1 50 3f c9 42 9a 97 77 0f 9d 29 97 7e 87 1b 8f
77 b6 c9 c6 53 90 5b 74 4c 92 99 62 ad 8b bf 4c
28 ac 1b 11 32 64 56 c9 f0 d5 6f c9 89 6b 55 3f
b9 42 aa 7b 7c f0 a1 89 93 22 13 46 e2 58 63 23
b2 51 83 92 76 46 05 65 87 86 5b 52 5a d1 02 ee
(3) I calculated the session keys in the normal manner, using the master   key which was sent entirely in the clear. The result was:
Client read key:
14 3e 84 a6 54 57 d6 51 94 cf 54 f5 5a 29 4a ef
Client write key:
9d e1 16 77 92 ee 89 f2 2d 30 c2 a2 e1 77 9f 5d
(4) Instead of disconnecting, the Netscape server sent the following   reply (the header has been removed):
28 40 00 75 b8 d6 60 68 f5 cf ba 65 78 49 35 83
d3 3a b5 d3 81 23 2d f8 7d c6 f8 47 4d 0c 62 c3
This was decrypted using the client read key to give the following   SERVER_VERIFY message:
Message Authentication Code:
7b 95 2a 84 a1 55 fc 59 32 6b 53 ec e0 1d 80 4a
Message type: SSL_MT_SERVER_VERIFY
Challenge data (which agrees with the challenge sent in the   a2 ff 2e 94 8d f9 f4 e2 2c f6 bd ae 7f 47 db 6c
(5) The negotiation phase of the protocol was concluded with encrypted   CLIENT-FINISHED and SERVER_FINISHED messages as per normal.
(6) I sent the encrypted HTTP command "GET / HTTP/1.0" and received the   following text (after decryption, stripping MAC and header, etc:
HTTP/1.0 200 OK
Server: Netscape-Commerce/1.1
Last-modified: Tuesday, 19-Sep-95 21:14:09 GMT
Content-length: 5278
Content-type: text/html
Followed by the Netscape home page, which included the following   Find out how   Netscape is responding immediately to upgrade customers and minimize risk   of future threats.
(7) Having obtained the warm, fuzzy feeling I so desired, I closed the   connection secure in the knowledge that my secrets were safe with    -------------------------------- End of Session    -----------------------------
This shows that Commerce Server 1.1 is prepared to accept a "secure"   connection which is completely insecure as the entire master key has been   sent in the clear and an eavesdropper could decrypt the session without   any cryptanalysis.
This does not mean that sessions between "well-behaved" browsers and   Netscape servers are insecure, since the browser will send all 16 bytes   of the key encrypted. Neither could it be used for an active attack,   since if a new master was substituted for the one sent by the client,   this would be detected during authentication of the SERVER-VERIFY   However, it would provide an opportunity for a malicious browser supplier   to "doctor" secure browsers so that they sent all (or part) of the master   key in the clear, even when using non-export ciphers. (Of course there   are better ways to do this; the "random padding" of PKCS block type 2   comes to mind).
Although this is not nearly as important a result as Ian and Davids, it   is the first server hack, so can I have another T shirt?  :-)
Andrew Roos PGP Fingerprint: F6 D4 04 6E 4E 16 80 59 3A F2 27 94 8B 9F 40 26
Full key at ftp://ftp.vironix.co.za/PGP-keys/AndrewRoos

@_date: 1995-09-22 03:01:07
@_author: Andrew Roos 
@_subject: Weak Keys in RC4 
-----BEGIN PGP SIGNED MESSAGE-----
                  A CLASS OF WEAK KEYS IN THE RC4 STREAM CIPHER
                                PRELIMINARY DRAFT
                                   ANDREW ROOS
                          VIRONIX SOFTWARE LABORATORIES
1.  INTRODUCTION
This paper discusses a class of weak keys in RSA's RC4 stream cipher. It   that for at least 1 out of every 256 possible keys the initial byte of   pseudo-random stream generated by RC4 is strongly correlated with only a   bytes of the key, which effecitively reduces the work required to   search RC4 key spaces.
2.  STATE TABLE INITIALIZATION IN RC4
Although the RC4 algorithm has not been published by RSA Data Security,   code to implement the algorithm was anonymously posted to the Cypherpunks   mailing list several months ago. The success of the Cypherpunks'   attack on SSL with a 40-bit key indicates that the source code published   accurately implement RC4.
RC4 uses a variable length key from 1 to 256 bytes to initialize a   state table which is used for the subsequent generation of pseudo-random   The state table is first initialized to the sequence {0,1,2,...,255}.   1    index1 = 0;
2    index2 = 0;
4    for(counter = 0; counter < 256; counter++)
5    {
6        index2 = (key_data_ptr[index1] + state[counter] + index2) % 256;   7        swap_byte(&state[counter], &state[index2]);
8        index1 = (index1 + 1) % key_data_len;
9    }
Note that the only line which directly affects the state table is line 7,   two bytes in the table are exchanged. The first byte is indexed by   which is incremented for each iteration of the loop. The second byte is
indexed by "index2" which is a function of the key. Hence each element of   state table will be swapped at least once (although possibly with   when it is indexed by "counter". It may also be swapped zero, one or more   times when it is indexed by "index2". If we assume for the moment that
"index2" is a uniformly distributed pseudo-random number, then the   that a particular single element of the state table will be indexed by
"index2" at some time during the initialization routine is:
     P = 1 - (255/256) ^ 255
       = 0.631
(The exponent is 255 because we can disregard the case when "index2" and
"counter" both index the same element, since this will not affect its   Conversely, there is a 37% probability that a particular element will   _not_ be
indexed by "index2" during initialization, so its final value in the   table will only be affected by a single swap, when it is indexed by   Since key bytes are used sequentially (starting again at the beginning   when the
key is exhausted), this implies:
A.   Given a key length of K bytes, and E < K, there is a 37% probability        element E of the state table depends only on elements 0..E   (inclusive) of
     the key.
(This is approximate since "index2" is unlikely to be uniformly   In order to make use of this, we need to determine the most likely values   elements of the state table. Since each element is swapped at least once   it is indexed by "counter"), it is necessary to take into account the   effect of this swap. Swapping is a nasty non-linear process which is hard   analyze. However, when dealing with the first few elements of the state   there is a high probability that the byte with which the element is   has not itself been involved in any previous exchanges, and therefore   its initial value {0,1,2,...,255}. Similarly, when dealing with the first   elements of the state table, there is also a significant probability that   of the state elements added to index2 in line 6 of the algorithm has been   swapped either.
This means that the most likely value of an element in the state table   can be
estimated by assuming that state[x] == x in the algorithm above. In this   the algorithm becomes:
1    index1 = 0;
2    index2 = 0;
4    for(counter = 0; counter < 256; counter++)
5    {
6        index2 = (key_data_ptr[index1] + counter + index2) % 256;   7        state[counter] = index2;
8        index1 = (index1 + 1) % key_data_len;
9    }
Which can be reduced to:
B.   The most likely value for element E of the state table is:
     S[E] = X(E) + E(E+1)/2
     where X(E) is the sum of bytes 0..E (inclusive) of the key.
(when calculating the sum of key elements, the key is considered to "wrap   around" on itself).
Given this analysis, we can calculate the probability for each element of   state table that it's value is the "most likely value" of B above. The   way to do this is to evaluate the state tables produced from a number of
pseudo-randomly generated RC4 keys. The following table shows the results   the first 47 elements from a trial of 100 000 eighty-bit RC4 keys:
          Probability (%)
0-7       37.0  36.8  36.2  35.8  34.9  34.0  33.0  32.2
8-15      30.9  29.8  28.5  27.5  26.0  24.5  22.9  21.6
16-23     20.3  18.9  17.3  16.1  14.7  13.5  12.4  11.2
24-31     10.1   9.0   8.2   7.4   6.4   5.7   5.1   4.4
32-39      3.9   3.5   3.0   2.6   2.3   2.0   1.7   1.4
40-47      1.3   1.2   1.0   0.9   0.8   0.7   0.6   0.6
The table confirms that there is a significant correlation between the   few values in the state table and the "likely value" predicted by B.
3.  WEAK KEYS
The RC4 state table is used to generate a pseudo-random stream which is   with the plaintext to give the ciphertext. The algorithm used to generate   stream is as follows:
     x and y are initialized to 0.
     To generate each byte:
1    x = (x + 1) % 256;
2    y = (state[x] + y) % 256;
3    swap_byte(&state[x], &state[y]);   4    xorIndex = (state[x] + state[y]) % 256;   5    GeneratedByte = state[xorIndex];
One way to exploit our analysis of the state table is to find   under which one or more generated bytes are strongly correlated with a   subset of the key bytes.
Consider what happens when generating the first byte if state[1] == 1.
1    x = (0 + 1) % 256;                  /* x == 1 */
2    y = (state[1] + 0) % 256;           /* y == 1 */
3    swap_byte(&state[1], &state[1]);    /* no effect */
4    xorIndex = (state[1] + state[1]);   /* xorIndex = 2 */
5    GeneratedByte = state[2]
And we know that state[2] is has a high probability of being
     S[2] = K[0] + K[1] + K[2] + 2 (2+1) / 2
     S[1] = K[0] + K[1] + 1 (1+1) / 2
So to make it probable that S[1] == 1, we have:
     K[0] + K[1] == 0 (mod 256)
In which case the most likely value for S[2] is:
     S[2] = K[2] + 3
This allows us to identify a class of weak keys:
C.   Given an RC4 key K[0]..K[N] with K[0] + K[1] == 0 (mod 256), there   is a
     significant probability that the first byte generated by RC4 will be        K[2] + 3 (mod 256).
Note that there are two special cases, caused by "unexpected" swapping   key generation. When K[0]==1, the "expected" output byte is k[2] + 2, and   k[0]==2, the expected value is k[2] + 1.
There are a number of similar classes of "weak keys" which only affect a   keys out of every 65536. However the particular symmetry in this class   that it affects one key in 256, making it the most interesting instance.
Once again I took the easy way out and used simulation to determine the
approximate probability that result C holds for any given key.   ranged between 12% and 16% depending on the values of K[0] and K[1], with   mean of about 13.8%. All these figures are significantly greater than the   0.39% which would be expected from an uncorrelated generator. The key   used was again 80 bits. This works the other way around as well: given   first byte B[0] generated by a weak key, the probability that   (mod 256) is 13.8%.
4.  EXPLOITING WEAK KEYS IN RC4
Having found a class of weak keys, we need a practical way to attack RC4   cryptosystems using them. The most obvious way would be to search   weak keys first during an exhaustive attack. However since only one in   256 keys is weak, the effective reduction in search space is not   The usefulness of weak keys does increase if the opponent is satisfied   recovering only a percentage of the keys subjected to analysis. Given a   generator output which includes the first generated byte, one could   that the key was weak and search only the weak keys which would generate   known initial byte. Since 1 in 256 keys is weak, and there is a 13.8%   that the assumed value of K[2] will be correct, there is only a 0.054%   of finding the key this way. However, you have reduced the search space   by 16
bits due to the assumed relationship between K[0] and K[1] and the   value of K[2], so the work factor per key recovered is reduced by a   factor of
35, which is equivalent reducing the effective key length by 5.1 bits.
However in particular circumstances, the known relationships between weak   may provide a much more significant reduction in workload. The remainder   this section describes an attack which, although requiring very specific
conditions, illustrates the potential threat.
As a stream cipher, a particular RC4 key can only be used once. When   communications sessions are required, some mechanism must be provided for   generating a new session key each time. Let us suppose that an   chose the simple method of incrementing the previous session key to get   new session key, and that the session key was treated as a "little   (least significant byte first) integer for this purpose.
We now have the interesting situation that the session keys will "cycle
through" weak keys in a pattern which repeats every 2^16 keys:
00 00 00 ...    Weak
(510 non-weak keys)
FF 01 00 ...    Weak
(254 non-weak keys)
FE 02 00 ...    Weak
(254 non-weak keys)
FD 03 00 ...    Weak
01 FF 00 ...    Weak
(254 non-weak keys)
00 00 01 ...    Weak
(510 non-weak keys)
FF 01 01 ...    Weak
(Least significant byte on the left)
Now while an isolated weak key cannot be identified simply from a known
generator output, this cycle of weak keys at known intervals can be   using statistical techniques since each of the weak keys has a higher   expected probability of generating the _same_ initial byte. This means   that an
opponent who knew the initial generated bytes of about 2^16 session keys   identify the weak keys, and would also be able to locate the 510-key gap
between successive cycles of weak keys (although not precisely). Since   510-key gap occurs immediately following a key which begins with 00 00,   opponent not only knows that the keys are weak, but also knows the first   bytes of each key. The third byte of each key can be guessed from the   output byte generated by the key, with a 13.8% chance of a correct guess.   Assuming that the "510-key gap" is narrowed down to 1 of 8 weak keys, the   attacker can search a key space which is 24 bits less than the size of   session keys, with a 13.8%/8 chance of success, effectively reducing the   space by approximately 18 bits.
Although this particular attack depends on a very specific set of
circumstances, it is likely that other RC4 based cryptosystems in which   are linear relationships between successive session keys could be   to similar attacks.
5.  RECOMMENDATIONS
The attacks described in this algorithm result from inadequate "mixing"   of key
bytes during the generation of the RC4 state table. The following   could be taken to strengthen cryptosystems based on the RC4 algorithm:
(a) After initializing the algorithm, generate and discard a number of       Since the algorithm used to generate bytes also introduces additional       non-linear dependencies into the state table, this would make       more difficult.
(b) In systems which require multiple session keys, ensure that session       are not linearly related to each other.
(c) Avoid using the weak keys described.
6.  CONCLUSION
This preliminary analysis of RC4 shows that the algorithm is vulnerable   analytic attacks based on statistical analysis of its state table. It is
likely that a more detailed analysis of the algorithm will reveal more
effective ways to exploit the weaknesses described.
Andrew Roos  -----BEGIN PGP SIGNATURE-----
Version: 2.6.2i
 -----END PGP SIGNATURE-----

@_date: 1995-09-29 04:02:31
@_author: Andrew Roos 
@_subject: Cryptanalysis of RC4 - Preliminary Results (Repeat) 
(This is a repeat because I posted the original 36 hours ago and it still   hasn't bounced back to me.)
 -----BEGIN PGP SIGNED MESSAGE-----
Hi c'punks & sci.cryptites
About a week ago I posted a message about weak keys in RC4. This is
an update on the results of my continued 4am sessions with RC4 and
shows that certain weak keys lead to an almost-feasible known
plaintext attack on the cipher (well, about as feasible as the
differential attack on DES, shall we say).
The attack is based on two particularly interesting three-byte key
prefixes which have a high probability of producing PRNG sequences
which start with a known two-byte sequence. The prefixes are:
1.  Keys starting with "00 00 FD" which have a 14% probability of
    generating sequences which start "00 00".
2.  Keys starting with "03 FD FC" which have a 5% probability of
    generating sequences which start "FF 03".
Note that the expected frequency of any two-byte output sequence is
1 in 65536 or about 0.0015%, so these key prefixes are highly
unusual. I won't go into the reasons why in this post, since it
follows the same reasoning as my last post, but these prefixes are
special in that they have a high probability of initializing the RC4
state table in such a way that the first two generated bytes depend
only on the first three entries in the state table.
This observation is the basis for a simple known-plaintext attack
which reduces the effective key space which you need to search to
have a 50% probability of discovering a key by about 11.2 bits. The
down side is that you need "quite a few" known plaintexts to make the
attack feasible.
It works as follows:
1.  Collect a large number of known plaintexts (and hence known
    generator sequences).
2.  Discard generator sequences which do not start with "00 00" or
    "FF 03".
3.  For generator streams starting "00 00", search all keys which
    begin with "00 00 FD".
4.  For generator streams staring "FF 03", search all keys which
    begin with "03 FD FC".
5.  Keep going until you find a key :-)
Clearly this attack will only discover a small fraction of the keys.
However since most generator sequences are discarded without being
searched, and for those which are searched the search is 2^24 smaller
than would be required to search the entire keyspace, the number of
trials required to determine a key is significantly lower than for
brute force alone.
Enough of an intro, here are the relevant results. Forgive my
simplistic approach to maths, I'm a philosopher-come-software
developer, not a mathematician. I've run the relevant simulations
with 40-bit, 64-bit, 80-bit and 128-bit key lengths, and with two
different PRNGs. For the sake of consistency with my earlier paper
I'll use the figures gathered for 80-bit keys (this seems to be RSA's
preferred key length for RC4), but there are no significant
differences for other key lengths. The PRNG used for these tests was
L'Ecuyer's 32-bit combined linear congruential generator as described
in "Applied Cryptography" p. 349.
(a) Out of one million trials, keys starting with "00 00 FD"
    generated sequences starting "00 00" 138217 times, and keys
    starting with "03 FD FC" generated output sequences starting "FF
    03" 50490 times.
(b) Out of ten million trials, arbitrary pseudo-random keys generated
    sequences starting with "00 00" 446 times, and sequences starting
    with "FF 03" 146 times. (Note the abnormally high incidence of
    "00 00"; the expected mean is 152.8).
Suppose we have the output stream generated by a randomly chosen key.
The chance that it will start with either "00 00" or "FF 03", and
that we will therefore search it, is:
    (446 + 146) / 1e7 = 5.92e-5
The chance that it starts with "00 00" and was generated by a key
starting with "00 00 FD", or that it starts with "FF 03" and was
generated by a key starting "03 FD FC" - i.e. the chance that we will
search it and be rewarded for our efforts - is:
    (138217 + 50490)/(1e6 * 2^24) = 1.12e-8
The total number of plaintexts required for a 50% chance that we will
discover one of the keys is:
    log(0.5)/log(1 - 1.12e-8) = 61 900 000
Well I did say "quite a few" plaintexts would be necessary :-)
And the number of plaintexts which you expect to search in order to
find the "right" one is:
    61 900 000 * 5.92e-5 = 3665
Since the total key length is 80 bits, and we are "guessing" 24 of
these, each search requires 2^56 trials. Hence the total number of
trials for a 50% chance of discovering a key is:
    3665 * 2^56 = 2.64e20 = 2 ^ 67.8
Since brute search alone would require 2^79 trials for a 50% chance
of determining the key, this reduces the number of trials by 2^11.2.
The results are essentially identical for all the key lengths I have
tried, and in each case reduce effective key length by about 11.2
bits. So, for example, a 64-bit key would normally require 2^63
trials for 50% chance of solution; this attack reduces the number of
trials to 2^51.8 at the cost of requiring 62 million known plaintexts.
I'm still running simulations to check my maths, and although initial
results are encouraging, I don't have enough data for it to be
statistically relevant yet (generating all these sets of 62 million
known streams takes time...) So consider this preliminary (again),
and I'll post the results of my simulations when I have enough
Andrew Roos PGP Fingerprint: F6 D4 04 6E 4E 16 80 59 3A F2 27 94 8B 9F 40 26
Full key at ftp://ftp.vironix.co.za/PGP-keys/AndrewRoos
 -----BEGIN PGP SIGNATURE-----
Version: 2.6.2i
 -----END PGP SIGNATURE-----

@_date: 1995-09-29 12:00:13
@_author: Andrew Roos 
@_subject: Cryptanalysis of RC4 - Preliminary Results (Repeat) 
Hi Bill
You could check for the full three-byte prefix, which further reduces the   number of keys you have to discard. Although all keys beginning "00 00"   are weak in the sense of my original post, they do not appear to be as   exploitable as the prefixes which generate two-byte probable sequences.
I also recommend generating and discarding some initial sequence bytes,   since the generation process mixes up the state table further. An extra   "round" through the state table (i.e. generating 256 bytes) _appears_ to   confuse things significantly, since by the time you've generated the   initial state table from the key, Index Y is a function of all bytes of   the key, so the second time around it's hard to figure out the impact of   the byte swaps. But I wouldn't trust this without a significant amount of   analysis: as always in this field, appearances can be dangerously   Of course, this defense is not possible with protocols like SSL where you   have to follow the spec - or better still, PCT which conveniently moves   the MAC to the *end* of the record, exposing the initial stream...
 ----------
Sent:  29 September 1995 10:16
It sounds like any application using RC4 with random session keys
should start by testing session keys and rejecting any that
start with 00 00 or 03 FD; it means doing 2**-15 more random key
generations, and reducing the brute-force space by 2**-15,
but it's a pretty small reduction.
Andrew Roos PGP Fingerprint: F6 D4 04 6E 4E 16 80 59 3A F2 27 94 8B 9F 40 26
Full key at ftp://ftp.vironix.co.za/PGP-keys/AndrewRoos
