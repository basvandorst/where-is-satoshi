
@_date: 2012-11-24 22:06:10
@_author: Caleb James DeLisle 
@_subject: OT: cheap colo space in Southern Germany/Munich 
Oh hi..
Interesting criticism.
It's incumbent on me to prove that it scales but if there are obvious theoretical
scaling inadequacies then maybe you would care to bring them up?
Grandma doesn't use it.
I'd love for it to be more deterministic but I don't see how to make the design do that.
Yeap, DoS is a serious issue with this design.
It's also a serious issue (although less serious) with the Internet as it is today.
My plan is to introduce a market based flood management system integrated with congestion control logic.
What's your plan?
Just hoping that that botnets never reach terrabit capacity isn't an answer.
Grandma doesn't use it.
bEncoding sucks. But it sucks less than the alternatives which I saw at the time.
What's necessary is simplicity and ability to add keys to a message without breaking old nodes.
It's probably not the best design but it's an asthetic issue, cjdns weeds the control packets
out of the stream en route, it doesn't "bind to port 0".
Good to hear that cjdns isn't missing a feature.
If you mean what I think you mean, that's already done ("cjdns weeds the packets out of
the stream").
Throwing out the book is always valid, at best you invent the next big thing, at worst
you have a great learning experience. In the middle, the good ideas are integrated into
existing technologies and the bad ideas serve as a case study.
If I was in charge of a major AS, I wouldn't implement *anything* which was developed
with an R&D budget of 0. There are some potentially interesting components but as a whole,
cjdns is not intended to work on large networks.
In places like where I live, it's not cost effective for cable and phone companies to
provide fast internet.
I believe that people are willing to spend money on a pole and a few directional radio
links if they can install the equipment and it will just work. I also think they'll be willing
to share the data downstream if they can get a discount on their bill for the data they shared.
What I need is a way to separate infrastructure, billing, and IP4 gateway provision.
I want to put up a pole, make a directional radio link to my neighbor, sign up with a billing
provider that takes major credit cards, and be online. I don't want to worry about my neighbor
spying on my traffic and if someone links to my pole, I want a discount for carrying their bits.
IMO the most important role of cjdns is not in offering an answer but in introducing a question.

@_date: 2012-11-26 22:53:38
@_author: Caleb James DeLisle 
@_subject: [HacDC:Byzantium] cjdns review 
Not sure if I need to be on that list so I just sent it to you.
This is true for now, I'm working on a patch to connect nodes on the same
LAN by beaconing out a key/passwd. The UDP/IP4 connector needs security
because otherwise you let the whole internet in.
The switch layer will carry whatever you like with 52 bytes of overhead.
IPv4 tunneling over the switch layer is written but unfinished/untested.
Randomness is really weird.
For example I can brute force a key by taking one random number then
incrementing it by 1 every time after, if the original number is safe
every number thereafter is also safe.
Cjdns gets it's numbers from the libevent arc4 PRNG which is cloned
from the BSD code. I understand this PRNG is also used by TOR.
BTW the libevent arc4 PRNG does seed using dev/urandom, I've never heard
of any solid research on the whole "less random" thing, as long as the
kernel PRNG isn't completely broken, I see no reason why urandom should
be measurably less safe. There seems to be an urban myth about these
"less random" random sources probably perpetuated by the people selling
hardware random generators.
The prime thing is not needed because we're not generating RSA keys,
these are Curve25519 ECC keys which are only good for Diffie Hellman key
agreement and I'm just following the API as specified here:
Nothing in the protocol prevents it, it's just an implementation limit
because nobody has written a number encoding scheme for numbers >255.
Other nodes do not care about your encoding method so this is strictly
an implementation detail.
I think this is valid for the moment. Lots of unfinished work.
The 64k$ question is, does it make more sense to hack on current tech
because cjdns isn't there yet or to hack on cjdns because in 3 years, current
tech is going to be outdated.
My answer to that question is obvious but it's a personal decision for everyone.
I appreciate the complements, I hope you don't pull punches for my sake.
"Throw it out, it all sucks" is kind of the cjdns motto so when something
in cjdns is broke ass, I want to know so we can decide if we want to change
it and whether that's a protocol break or just an implementation detail
which we can punt off till later.

@_date: 2012-11-26 23:26:32
@_author: Caleb James DeLisle 
@_subject: OT: cheap colo space in Southern Germany/Munich 
I really appreciate your expert opinion.
It's helpful to know what I should be concentrating on.
Definitely valid.
Code wise, it's pretty trivial to modify the protocol to stack headers ala MPLS.
IMO we're still in an experimental stage and we need to be able to break the
protocol for things just like this.
Routers identify each other by internal ip6 (hash of key).
It's a fair critique that that the switch layer for not offering anything remotely
similar to the interface provided by Ethernet. That said, I think there's a risk
in trying to analyze it in terms of Ethernet.
Valid point, there is no math backing up any of this. Fortunately a router can
forward to anyone it wants as long their address is numerically closer to the
destination than it's own so routers in a network can experiment with different
forwarding algorithms without fear of loops.
Not the underlying protocol, the overlay protocol. Cjdns control messages
are basically a bastardized form of an ipv6 packet. On the outside anything
that carries frames is ok.
There's an module which links nodes over raw Ethernet and I'm told it works well.
My mistake, indeed 64 is not a lot but as I said, we can expand by stacking with
minimal protocol changes.
LISP ;)
Sending a DHT query and waiting a roundtrip to decide where to forward
would be insane. Instead of sending a DHT query to a node, cjdns sends
them the packet. Obviously it favors nodes which are physically nearby.
What concerns me is if you had 1 billion nodes and the average node had a
routing table with 500 physically close nodes and 500 numerically close..
You would need 2 million "nearby" nodes, otherwise your packets are going
to travel a long way before reaching a node which knows a full route to
the destination.
However, if you only have 200k prefixes to forward to, this same
partitioning trick might come in handy for forwarding ip4 on multicore
commodity processors.
Time will tell.
The switch layer will happily carry any kind of traffic you like, including
IPv4 packets so natting is unnecessary, you just pop the switch header and
Ever since the end of dialup I haven't seen a single new local ISP and I
would never try it myself. The only way I see telephone/cable losing their
control is if we can provide people with a kit ISP that anyone can setup.
The problem is if someone wants to compromise you, it's hard for them to
infiltrate your IPv4 gateway provider but it's easy for them to set up a
node in the network and begin carrying your traffic.
This is my solution, I realize it's not the only one and I'd love to see some
competition in the field.
My 3 main requirements are:
* No single point of failure.
* Anyone can start a node with little to no technical skill.
* It must not be fruitful to start a node with the intention of committing
Espionage/Forgery against a given target. Of course DoS should difficult.
Again I appreciate your comments and right now I'm adding to my TODO list:
- Stacking of switch headers.
- Provable algorithms or at least simulations.

@_date: 2013-08-05 14:55:22
@_author: Caleb James DeLisle 
@_subject: [liberationtech] CJDNS hype 
Hash: SHA1
Infecting existing nodes is cheaper than knocking on doors asking people
to connect to your evil nodes because your reputation doesn't suffer when
the trick is discovered.
It doesn't cover whether adversarial nodes are geographically
dispersed or not. If they are then the the attack is significantly
more expensive.
This is good from a capabilities standpoint but it doesn't cover
motive which is hugely important to threat modeling. If someone has
significant resources and their motive is "to cause mayhem", securing
infrastructure against them is not really possible which is why
traditional antiterrorism efforts seem incoherent.
Causing localized network disruption is trivial in any ethernet,
you simply answer ARP or DHCP packets. This is done by some malware
but the motive is to carry out a MiTM attack and trick the victim
into installing the malware binary which is disguised as an update.
With cjdns you would not have the ability to MiTM so the same style
attack would just cause a localized network outage.
Another motive for localized DoS is to force users to an unencrypted
channel. If every time the police use encrypted radio you jam it,
they may be tricked into using unencrypted channels. The main defense
against this is not to have an insecure backup.
Also note that localized network outages can be caused by wire cutters
and/or wifi jammers so a protocol attack may never be the most effective
cat-and-mouse games which is why I don't like this approach.
You could send forwarded packets to nodes to whom you know a direct
path and then send them a direct packet asking if they got the
forwarded packet. You have to try it a few times to be sure the
endpoint is not fooling you and there are still more ways to detect
and work around it.
It's not something I'm interested in ever implementing so it's not
really worth further discussion.
I suppose it is because the same information can be derived, albeit
with some complexity. In cjdns the path through the social network
which is represented by any given node is expressed in the label so
you get it for free.
It's all true but it's worth noting that in order to maintain the same
proportion of evil nodes in a growing network, the evil net must grow
as well  which brings us back to motive. If somebody is willing and able
to invest a significant amount of money into setting up evil nodes then
he must want something.
It seems more realistic that the evil nodes would be compromised good
nodes, an attack which which scales better.
With cjdns there are multiple ways to reach a node but only one best
way so that's mostly a solved problem.
A non-adversarial way to look at this proposal is it attempts to avoid
over-reliance on a single network link. Each edge would just appear as
a link with a disproportionate number of nodes relying on it.
You should check out the network, I think you'd find some interesting
discussions in the dark irc network (irc.hypeirc.net)  and
 you might also find some people interested in helping with briar ;)
Liberationtech list is public and archives are searchable on Google. Too many emails? Unsubscribe, change to digest, or change password by emailing moderator at companys at stanford.edu or changing your settings at

@_date: 2013-07-25 23:58:34
@_author: Caleb James DeLisle 
@_subject: [liberationtech] CJDNS hype 
Hash: SHA1
Hi Michael,
Sorry for the wait on my part as well, I was very busy last week.
Exactly. There is no real concept of "neighbors" at the DHT layer but
there is address space distance so some nodes are "close".
Yes, the destination of the ping does know that it's a ping since it
needs to respond to it. If it dropped non-pings it would be unreachable
and if it dropped layer3 "forward me" messages then it would break the
Only by guessing based on size and timing.
Never ever. That's critical to the model that when you are told about
a node that you don't trust that it's real until you're sure that
you've talked to it.
Other than short paths (labels) being preferred, there are only a few
tricks aimed specifically at accidental problems. If I discover route
then I discover
I will replace the first with the second since I can prove that the
first is an indirect representation of the second.
There are no specific defenses against sybil attacks but I don't think
any are needed given the fact that it's inherently different from a
traditional overlay network.
That's a valid point. We tried to avoid trapping bad behavior and
dropping a node because in my opinion it is too brittle and is more
likely to introduce a vulnerability.
Rather than trust early and detect known bad behavior, cjdns is slow to
trust. If you tell me about a new node I will generally not use it until
the node I'm currently using fails. This hurts performance but helps
stability once the network is functional.
I'm on very unstable ground here, possibly bullshitting...
None of this has been simulated so I have to tread carefully.
Basically each route has a "value", when a node is inserted, the route
to that node has a value of 0, valid ping responses increment the number
and timeouts halve it. High numbers and short paths are favored but even
a long path is favored over a "0 value route".
When you ask a node for routes, it will give you routes which are either:
1. A perfect match to the ip address you queries (even if 0 reach)
2. The highest reach node which is closet to the query target than them.
(them == the node to whom you sent the query)
Since cjdns populates it's table by periodically querying randomly generated
ip addresses, nodes share their best paths causing a sort of "wisdom of the
crowd" effect and making it difficult for a sybil attack to gain traction.
We would have to make some small protocol changes to make this work
but what immediately comes to mind is A sending a forward request to
B to forward to C then sending a switch level packet to C asking if
he got the message.
Only A and C need to have the protocol patch and there is already a
protocol versioning system in place so this would be trivial to
You have to trust C not to lie to you though. This kind of complexity
is why I have tried to avoid explicit detection and why I say "cat and
mouse game".
Basically correct, the switch can read the label and likely use it's
routing table to determine the address of the next hop but cannot determine
the destination.
For performance and scalability this feature may be removed.
When you do a DHT query, you get the keys (and protocol version numbers)
along with the paths.
Your technical analysis is spot on.
There is no code which relies on the packets originating from someone
else so your attack building block this is not much of an issue for me.
Anyway signing packets for all the world to see not only performs poorly
but is problematic in other ways. I'm not sure people would want their
packets to be linked to their identity forever, they can be decrypted
after all, by the destination if no one else.
Too many emails? Unsubscribe, change to digest, or change password by emailing moderator at companys at stanford.edu or changing your settings at
