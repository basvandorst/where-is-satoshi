
@_date: 1996-06-06 16:04:25
@_author: Bodo Moeller 
@_subject: Fate of Ecash if RSA is cracked? 
"Perry E. Metzger" :
[... est.:]
When discussing the estimated time needed for factoring integers, it
is usually assumed that an "algorithm" is something that is
deterministic or probabilistic.  Quantum computing should also be
mentioned.  Efficient algorithms for logarithms (the Diffie-Hellmann-
problem) and factoring (the RSA-problem) on a quantum computer were
found by Peter Shor [1].
Of course, no quantum computing device that you could run those
"programs" on does exist. But as Gilles Brassard puts it, "In my
opinion, the theoretical notion of feasible computation should be
modelled on our understanding of the physical world, not on our
technological abilities. After all, the classical Turing machine
itself is an idealization that cannot be built in practice even not
taking account of the unbounded tape: any real implmentation of a
Turing machine would have nonzero probability of making a mistake.
Does this discredit the model? I think not." [2]
An other article by Brassard might still be availabe at
There, he writes quite optimistically: "I like to think that I shall
see a special-purpose quantum factorization device in my lifetime."
[1] Peter W. Shor, Algorithms for Quantum Computation: Discrete
    Logarithms and Factoring (in: Proceedings of the 35th Annual IEEE
    Symposium on Foundations of Computer Science, 1994, pp. 116-134)
[2] Gilles Brassard, A Quantum Jump in Computer Science (in: Computer
    Science Today (Springer-Verlag LNCS 1000), 1995, pp. 1-14)

@_date: 1997-08-13 03:21:21
@_author: Bodo Moeller 
@_subject: RSA - the song 
Kent Crispin <kent at songbird.com>:
For encoding numerical data as music, I usually use the following
The digits 0 ... 9 are mapped to the C major scale:
  0 becomes B,   1 becomes c,  2 becomes d,  3 becomes e, ...,
  8 becomes c',  9 becomes d'.
(Of course, this can be transposed to any other key.)
The next step is to find appropriate rhythms, harmonies etc. that make
at least some sense, musically, in order to construct a melody out of
that sequence of notes.  As an example, I scribbled down the first
digits of pi = 3.141592653589793238462643383279502884197169...
The score can be found in the uuencoded GIF below (and soon also at
That version (in D major) is for harpsichord or piano.  I did not mark
which notes I think should be played legato, legatissimo or portato;
that is left as an exercise.
It would be quite cumbersome, of course, to use this method for
exporting software.  However, it is very convenient for memorizing
numbers: Melodies are much easier to remember than boring numbers
(unless you happen to be a computer in which case you'd prefer the
raw numbers because they contain less data, technically). This works good for decimal numbers (no large jumps, no difficult
harmonies: B d f g b d' can all be used as G 7 notes if all else
fails).  Hex numbers are not that easy to handle.  In addition to
0 ... 9 == B c ... c' d', then there are A ... F == e' ... c''
(i.e., the digits/notes are spread over slightly more than two
octaves).  Because of that, my PGP fingerprint is somewhat
avant-gardistic: C7AC7EAD  566A65 ECF  61666 83 7E 8668 28
(See what I mean? :-)
In addition to memorizing one's PGP fingerprint, there are other
possible cryptographic applications: Under certain circumstances, one
might need to implement crypto-software from scratch without having
access to any written documents and without having access to computer
networks.  For such situations, it would be good to have some kind of
"memorizable encryption standard".  Writing RSA routines is easy (at
least if you are lucky enough to have some bignum library or if the
programming language supports bignums), but often you will need more:
E.g., a key generator for RSA that will find your 1024 bits RSA key
(which is really 2048 bits long if you count both N and D) given a 128
bits secret as seed.  It might make sense to use some cryptographic
hash function as the core of the "memorizable encryption standard":
The hash function can be used by the key generator (similar to the DSA
"kosherizer"), and it can be used to build a symmetric cipher
(Luby-Rackoff style).
Musically, the "memorizable encryption standard" could be a suite
consisting of a Prelude that somehow defines the hash function and of
some other movements that give test data for the hash function, for
the derived encryption function, for the RSA (or DH/DSA) key generator
Bodo Moeller
<Bodo_Moeller at public.uni-hamburg.de>
The first four bars of pi:
begin 644 pi.gif
M.6FU%V>]>?<? at D7C$9E,
M<FGUR)24,T9P[Q5WEI87 at N<P5P%TT398Y[%8ZM8W5KFUU\F8]7?X=)=8K!H:
M at .'*N[=H80.2T5AIZZ:LIV3"KCS;-VZD
M!Q-NUI6JX,.DZ at Z2FHOGR;:*?[Y\ZR*0N\":C^1=_D8
MDB6K-*M8<GLK+3 at L'HN[V*V3K%X?6=6TZ<R>FNOP[SROW\_M]]8?G^`
M42%AT5S^+ at +Q,76Y_1T`1T(S0[6;]R;!,/0TCRG-!$M-E%LWEYWIVKYQ2S[A
MI&K2;M9B%3V/+%K^ at 2!86?7F$T7/P9:1XKIO`D,&9=LW;LJ0
M8S/I,R4Z]OV.R2=^ at 6OV"%$].J+"K))X!(/"6T/4WC4+
M^,. at E&4*1=^_9FH?&U&F$B.X*"FPB,:*L
M<^S,IX at +*74FJ*XCZ[YPDKI6;)\P%]=W/^.77P\C).J&.:22<AP52SS;9Q)%
M+1U,*_&J?'(A7)G/&PZ20^=*F::JEM;!;&1 at AC0>!0[1W%)S>GEE162'
M>TF)>4U?8XLK at U^2+W:6EYB9FIN<G(QT`7.AG7=LD(&`C)%]781_.T!O6[.G
MR\N3?>)US(%[*<1 at 4QFA3'85XZJWE;;YO=)0K.
M$]C"3S.?.4,%$V=*CIF`Y at R&I8VV1P&+>FMXBE_29D_-5/OH\N4HH='B>'CH
M)F-*)DHE05XN,F-4 at 9/4Y?"[(;>V%=9:<Q:/:7'1DWZ_XL=V
MDV_FA:,;"12*"OSRT at M3;.-C!('*6>QP8]M[E-NJ+)3$%/14<RR*G$K$?"*<
MK$-"[`1]>WU+_>02+:G< at I*
M:4 at G_T`"/%:/IT:D06%MI>(38Y6I)4D:*MNLJYFU3&']JCJE&:"A8\%$M>JA
M;:/&W%9YWLQH=)S2D$R[E3GSV)V_!\6 at SK>:V>1&IT(K3>R)+EF at J7</_R$0
M22 at 3K)%Q$E02!$3% at W?T!K$VJ
M<_DD*)'USQ2K>\=F(>+5S at TF0.
M'Y`KR[U at 21(
MO:<2647YZ5$ at V7MLM4H
MP04CC at HO1?$P1
MVY=L39W;[C=<DV9 at 3V)8/*_?&^9>"QB?X""AD%_8W6'A(J-17=8:7>,D9:7/
M;; at VW.UM=UE\_7V9W31-
M!];BI-5>G/7FW7\P% at V*YK&8ZUW>^]V-;)/
MUE93K%*%4U=:U\]:W,?;R]FFW5Q at Q]] at 2"^)BZ"L[FP4FKO3CKS;O_
MIVC at GUOX$.9BE+`=0Q0.QT&TD;!?/DD6=W%]H1=06[1R'+M(G`>2HL
M*?AQ&<D+;GR%E,=,W[J5)U/:S(ES)Z2> at TY*.
MRJN0D$NU;DV<S?D7,+?"?&G^$(B/J:O at P"";R<U'C\V\ZR=Y`2AJY=F at H\JV
MGN7K<:2N at C+55
M5.<YI$SAE21*!JO6K6&,0IMIC6M3CS>!5CDA,L at 2LV65K60K-NY0KYZHTO5Y
MW(8&6>)BXV/D4S2Q8+S>,K7!WVGJ:NO"3*GD[>--1\ZK9<F.Y at RC<CKT.?7K
M=O=W(';OX at C/V\5'Z:E1G,\I?T$FY/EP-Q
MYT\:-*%P:[FB9KR=0)4N9;JZ at 4!\3%UN?QCEG(`N>S'
M8.%AXKVB8EX%V6+F9N=GLQ%G6!1 at Z&ML=UR"^)BZW/XPRCF!I3CK3:W_8/AQ
M at BVD\PF-2E/-J?6Z46:9U23)".%B:=H+>(Q.J]?4'_NM_KFWWJXW<':(X1SB
M\RXH'!*+QB,R&$LZ>AV at 4-=:PC0V*3-'[6!PDFW%FQ
M at O[7)NZ^
M at C$Q]3E]H=13 at BLI5E?K/T'
M9K&]JB?+272A8W+9?$8'M6GD%6;[TK at B>L`M
MT:RXE"/+1?WE4 at 4F%<L9<D5^V?J+7;G:JWWPG?K<O2CC&];&M=EFG
M5,C/%$"*D\*TJ\C$1TM"C!$1?LSHCN$&69 at XTMM7,.1*=!=!48')4MZDDZ!F
MWO28$9P]CGYP! at XAO:4."QGN-`AMRI%(<QE.=2WJM)_HI`?$Q=
M5S?.IN9':Z+CXNRHX<!.Z7'L at _=?US<ROZ0S/<GNPS
M;`EO+%F%2_?5M1NL)3<(C4H2QD<%9%'(0>,VSKMD;UF4?P'G88P7_ at F!^)BZ
M`:".21C-DZ[.S?NY7B at BX*B-6XDFZOIE[M2&LW?&)`:[M=GUMAL/QR+ZC$A(
M9 at C?PSTEP<G;M+(ES%O'8,:\F*NF3X at HS]G<R21EDGDNC_[TV%`F)Z*FC/$,
MDK(CFYY+\V3M,I7?":N!+/ at 6ED=[:[5
M1?;J3Z0.T<;-M at XCQ+L9R[(<S!AGK1)
M at Y15GA]9]?C+QR;
MRVUU*KIS2).E'I at Y=4[<&=%5SVZ
M at DU9WES"7]W?75VB5%=CX&.,6>=E5&*_3DUF:V7G:
ML\_(M)JNW\_C_ at DMV$7XI67F"B(E3AHN,CR^""I-FA1B-DIJ;A9J>G"*6/
MYFGJ:FO(9_P3 at OB8BM"P
M[WQ,]\" at L%
MM>BX?'XKT^]X at _JQ-MN=;S5Y at X2%<(:(?H$,;5F-
MQ^'Z^]>\\.D`Y>%3!D at 507>N`G(PI1"/+UL-(R;9P)`*O at W^!.)CZD'W,J
MZC at K?[Y<GZI%CY_C(*'
MK7P$,>0N(>LP:G0BS at K-C\8JBO3F<J6/HCA_<)R0LR1)ID?!7+QY+ZDJJD
M3VVJ.;56RI%]--!=71H<DI$8HMCA at UFBH^(
M%Z at GIYWI*=&?)F/H"REIG>MC"VP3;-DHC==KG*P)ZX=O%K$J[S&E<81:;,4N
M<1%3K=U\8 at O)6MNSN.02IHRU*Y1Q4[_.
M4`CY at 5Q*SU.OA(=.
M.+`CR9,TSA at D^*9BJ(W2IC6J!"<9BXDF4Y8*&!/62)^V&
M at ML[/_8_,,B:Z(:_HE`A22*33D,G!YM2JU3-!=B*6
MS6X+^RT7-N/MGIV>W^SGJ8Q27]0 at SQ*=7Q9?(I2*6Y_2G"%
MSFWR9F[:<2-O6)<Q*33-=0FL[ZMP9C%>]E\QLS at F\+/R=O=;^7ED:.
MCZ,7'1I5C21)"J!%;I8<NB+X*Z6ID at E1B9/9K*(VE33`P+1ILA],=NAF"67R
MM2_`MC? at H>X85,Z22Z=/
M"\W3C_ at 8&8F7DT).%6&L-YFHB
MJZ<CL%L<$] at 63
M7( at 5(
M at 0L9-FRBSV$[B%\XH%B51(FOB!(;.79DHM at 1A*\Y4I3R`2*!.)CZG+[
MPR at GK?;BK
MY+0X2^UC/(6-E9T-<MQLN(5 at S<2TF_,EB(^IR^T/HYRTVHNSWKS[
MV^]R](V8G%WQ"8T6 at R^4*,J^;=MO&^
M"'HLV(:CM%HMSZT;B4DCL" at O.
MV;`^_/KM!('XF+K<_ at T`2*NE\B[)I_Y']DT>"'7BE2*<B9&K6\7RAKKT7
M^A491]A]TG at 9')X[^G;571R/O%\V at 0,)%C3HZQV[53F2O(,&+!,_9A+1'1-T
MSD at 2I4K68:1R.VB*G^]U
MY-5KI4>%)D[2-=0FH+);$^GYIQ4ON at 5*N
M_!ARY!]])5>V?!ES9LVD+ at C$Q]3E]H=13EKMQ5EOWOT'0W$D2_-$4W5E6_>%

@_date: 1997-01-15 13:22:44
@_author: Bodo Moeller 
@_subject: The Upcoming DES Challenge 
On cryptography at c2.net, cypherpunks at toad.com, and coderpunks at toad.com,
These "offsets" on (German) eurocheque ATM cards can be regarded as
the PIN encrypted with some variant of DES CFB[*], using the account
number (including the five trailing digits of the "Bankleitzahl", an
eight-digit code that identifies the bank that hosts the account, and
a single digit card number) as IV.  The same encryption key ("pool
key") is used for all cards from all banks.
  [*] (It's an extremely stupid variant of CFB and introduces
       additional weaknesses, but that is irrelevant in the context
       of key search.)
In fact, the system allows for three pool keys.  They correspond to
three "offsets" on each ATM card: Offset number 1 is the PIN encrypted
under pool key number 1, and so on.  I guess this design was chosen to
allow changing the pool keys: While pool key number 2 is in use, the
other two keys can be replaced by new ones.  If there were just one
pool key, changing it would immediately invalidate all PINs currently
in use.  I don't know how many pool keys are used today, and I also
don't know whether one of them has have ever been changed.
(PIN generation is similar to PIN encryption, but the bank uses its
own encryption key.  The PIN is computed directly from the DES result,
i.e. DES is used in ECB mode.)
For a key search, the attackers would need about four or five
Eurocheque cards (that is, the data stored on their magnetic stripes)
and their PINs.  Each attempted PIN decryption results in only four
decimal digits, so the attackers would obtain lots of plausible DES
keys if they just checked with a single card.  When a DES key seems to
work for the first card, one must doublecheck if it also works for the
second one (usually it won't), etc., which costs some time.  One the
other hand, because there are several pool keys, the attackers can
save a significant amout of time if they just want to find any one of
the pool keys.  Note that once they know one of the keys, they can
easily compute the PIN to any stolen ATM card, which might allow them
to buy faster hardware for the rest of the search.  (Their bank
probably wouldn't lend them money for such a project.)
All that is illegal, of course, but it is suspected by some that there
are already organizations that have somehow obtained the pool keys (or
some of them) -- either by key search, or the keys somehow leaked out.
(Not so long ago these pool keys were stored in every ATM, thus there
are many possible points of failure.)  Each year, there are thousands
of cases in Germany where someone claims that his ATM card was stolen
and immediately used for large withdrawals.  The banks usually claim
that either the client is lying (and did the withdrawals himself),
or he wrote his PIN down (e.g., on his ATM card).
Bodo Moeller

@_date: 1998-10-14 07:41:20
@_author: Bodo Moeller 
@_subject: DESX 
Dave Emery :
You might want to read "The Security of DESX" by Phillip Rogaway in
CryptoBytes Vol. 2 Number 2 (Summer 1996) pp 8-11, which is available
somewhere on RSADSI's web site  (possibly
 might be a good starting point) or the
underlying research paper "How to protect DES against exhaustive key
search" by Kilian and Rogaway in CRYPTO '96:
     [The] results don't say that it's impossible to build a machine
     which would break DESX in a reasonable amount of time.  But they
     do imply that such a machine would have to employ some radically
     new idea: it couldn't be a machine implementing a key-search
     attack, in the general sense which we've described.
(Quoted from the CryptoBytes article.)
Maybe not at all; see above.
