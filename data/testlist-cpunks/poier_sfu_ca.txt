
@_date: 1993-08-20 13:36:37
@_author: Skye Merlin Poier 
@_subject: Anonymous IRC 
And verily Panzer Boy doth spake unto thee:
Obviously you have not used IRC much... I think this idea would be exceptionally
bad. On IRC, for those that have not used it, there are channel operators (chops) on each channel. They have the power to kick and ban people from the
channel, if they are being abusive or exremely irritating (eg flooding everyone)
. By removing the client information, you remove the efficiency of a ban (usu
it applys the the person's userid from any machine on the same domain)... This
would make it very easy for one person in a bad mood to ruin a channel for everyone. And believe me, there are usually serveral people of that kind on
the net.
Perhaps you could set up your own IRC net (similar to the undernet) and have it
anonymous, but I would highly recommend against trying this on the standard IRC
                                                        -- S.

@_date: 1993-06-02 08:57:49
@_author: Skye Merlin Poier 
@_subject: Security in a VR world 
For anyone interested, there is a discussion on the multiverse maillist at
multiverse at medg.lcs.mit.edu about "portal security", that is, the ability /
inability for certain users passing through certain "portals", as well as
verification of user identity... Unfortunately, the developer is in Europe,
and as we all know, PGP is export-controlled... :(

@_date: 1993-06-02 18:39:16
@_author: Skye Merlin Poier 
@_subject: heh heh.. whoops 
heh  ... sorry about the PGP export thing... I was a bit
flaked out this morning what with midterms and all. Musta been thinking of something else.
Sorry all
-----====> Skye Merlin Poier <====----- Undergrad in CMPT/MATH (Virtual Reality)       ||||      ||||
          email: poier at sfu.ca                  p-OO <--> OO-q   THINK
   PGP Public Key available on finger           \==      ==/

@_date: 1993-06-04 00:23:02
@_author: Skye Merlin Poier 
@_subject: Procomm and encryption 
This discussion of integrating encryption with a comm package made me remember:
Procomm Plus 2.0 allows "hooks" to be assigned to meta-keys. I have the exact
interface hook.c around here somewhere, if someone wants me to post it.
-----====> Skye Merlin Poier <====----- Undergrad in CMPT/MATH (Virtual Reality)       ||||      ||||
          email: poier at sfu.ca                  p-OO <--> OO-q   THINK
   PGP Public Key available on finger           \==      ==/
ivel' or some such.
I would like to make it clear that the 'tiring drivel' that I was
referring to was MY post and not the letter from Hugh and I merely
intended the note to serve as a warning to people not interested in the
I see now that it is, indeed possible that this informal not may have been
misunderstood and I hope that you will understand my real intent now and
not hold it against me.
I am truly greatful for the help that I have received on this effort and
hope that we will have another product of guerilla programming soon.
Again, sorry for the misunderstanding, especially to Hugh, and keep those
suggestions coming, there is work to be done...
the Bit Wallah

@_date: 1993-06-05 03:18:43
@_author: Skye Merlin Poier 
@_subject: here ya go 
heres the procomm+ 2.0 hook prog...
-----snip snip-----
22                                                                   22
22 HOOK.C - Programmer's interface for PROCOMM PLUS 2.0              22
22 COPYRIGHT  (C) 1990 DATASTORM TECHNOLOGIES, INC.                  22
22                                                                   22
22 PROCOMM PLUS passes the "hook" program the address in memory of   22
22 the PCPLUS.PRM file structure, and the ASPECT N0-N9 and S0-S9     22
22 arrays.  This sample code makes local copies of these so it can   22
22 use the small memory model and not have access those locations    22
22 directly (look at the movedata() function calls.)                 22
22                                                                   22
22 This file also contains other PROCOMM PLUS information that       22
22 programmers may wish to make use of.                              22
22                                                                   22
22 NOTE: This code example is written for Microsoft C, which         22
22 defaults to "word alignment" of integer size items and causes     22
22 extra bytes to be inserted in structures to insure field          22
22 alignment.  Turbo C, Zortech C, and other compilers that default  22
22 to "packed" or byte alignment must be explicitly set to word      22
22 alignment (usually the -a compiler option).                       22
22                                                                   22
22                                                                   22
22 IMPORTANT NOTICE:  The concepts and the text contained in this    22
22 file are hereby released into the Public Domain for use by        22
22 programmers in developing PROCOMM PLUS-compatible code.           22
22 Programs developed using this file may be distributed freely by   22
22 programmers without any financial or legal obligation to          22
22 Datastorm Technologies, Inc.  However, this in no way implies     22
22 that any other material in the PROCOMM PLUS package may be        22
22 distributed in such manner, or that PROCOMM PLUS or any other     22
22 Datastorm product may be bundled for distribution with programs   22
22 developed using this file.                                        22
22                                                                   22
 "stdio.h"
 "stdlib.h"
 "dos.h"
22                                                                   22
22 Structure for PROCOMM PLUS PCPLUS.PRM information                 22
22                                                                   22
struct PARMLIST
   {
   int port;              /* com port, 0=COM1 etc */
   unsigned int baud;     /* index into baud_rate[] array */
   int parity;            /* parity: NOEMS = 01234 */
   int sbits;             /* stop bits as int */
   int dbits;             /* data bits as int */
   int mdm_timeout;       /* secs to wait for connect */
   int mdm_pause;         /* secs to pause between calls */
   int abdetect;          /* autobaud for dialing: FALSE/TRUE */
   int ddtrflg;           /* 1=drop dtr in dial dir */
   char redialc;          /* character to send in redial */
   int cdover;            /* override CD and send init string ? */
   int maxcalls;          /* max retries for dial dir */
   char mdminit[47];      /* modem init string */
   char mdmcmd[25];       /* modem dialing command */
   char mdmsuf[25];       /* modem dial command suffix */
   char hu_str[25];       /* modem hangup string */
   char ans_str[25];      /* modem auto anser string */
   char no_ans_str[25];   /* modem no auto answer string */
   char mdm_msg[11][16];  /* modem messages, 0-6 = connect */
   int baseaddr[8];       /* com port base addresses */
   int irqnumbr[8];       /* com port irq selection */
   int termtype;          /* terminal type */
   int echo_flag;         /* duplex: 0=FULL, 1=HALF */
   int use_xon;           /* use flow control: FALSE/TRUE */
   int hardflow;          /* use hasrware flow ctrl: FALSE/TRUE */
   int wrap;              /* use line wrap FALSE/TRUE */
   int scrlflag;          /* scroll page FALSE/TRUE */
   int lfflag;            /* add LF to CR coming in: FALSE/TRUE */
   char dest_bs;          /* use destructive BS: FALSE/TRUE */
   int brklen;            /* BREAK length in ms */
   int enq_on;            /* respond to ENQ: NONE/ANSWERBACK/CIS B */
   int use_uline;                      /* 1=EGA/VGA true underlining */
   int col132mode;        /* 0=80 col, 1=132 col */
   int ansi8bit;          /* 1=ANSI 8 bit mode, 0=ANSI 7 bit mode */
   int tcnorm;            /* Terminal normal attribute */
   int tcbold;            /* Terminal bold attribute */
   int tchalf;            /* Terminal wrt prt/half intense attribute */
   int tcrev;             /* Terminal reverse attribute */
   int tculine;           /* Terminal underscore attribute */
   int explode;           /* use exploding windows: FALSE/TRUE */
   int soundon;           /* use sound: FALSE/TRUE */
   int alarmon;           /* use alarm: FALSE/TRUE */
   int attenlen;          /* seconds for alarm sound */
   int snow;              /* flag for using fast display updates */
   int sline_off;         /* 0=use status line, 1=use 25 lines of data */
   int bigcur;            /* 0=line, 1=block */
   unsigned int rfarsize; /* far mem for redisplay buffer */
   int startextralines;   /* startup in extraline mode? */
   int extralines;        /* 25, 28, 43 or 50 line mode */
   char prtfilename[13];  /* name of PRN device */
   int cd_at_exit;        /* 0=ignore, 1=hangup, 2=ask */
   int fastkbd;           /* AT keyboard speedup */
   int remcmd;            /* flag for using remote script commands */
   int xlatflag;          /* use xlate: FALSE/TRUE */
   char xlatps;           /* pause character */
   int keypause;          /* pause between chars in ms */
   int nophonelog;        /* flag for using phone log */
   int filelu;            /* flag for using auto filename lookup */
   int use123;            /* use lotus menus ? */
   char key123;           /* lotus menu key */
   int dtrflag;           /* drop DTR in hangup: FALSE/TRUE */
   int page_is_xfer;      /* 1=PgUp/Dn xfer, 0=Ctrl-PgUp/Dn xfer */
   char chat_blk_mode;    /* flag for char/block mode in "chat" */
   int hardwire;          /* host connection type: MODEM/DIRECT */
   int autobaud;          /* use autobaud in host mode */
   char host_id[51];      /* host welcome string */
   int opensys;           /* host is open system: FALSE/TRUE */
   char hostup[51];       /* host mode upload default dir */
   char hostdn[51];       /* host mode download default dir */
   int hosttimeout;       /* host inactivity timeout (in minutes) */
   int hostbyemode;       /* what to do after end of call */
   int hostnewuserdl;     /* can new user xfer files? */
   char log_name[65];     /* default log file name */
   char scr_name[65];     /* default screen dump fiel name */
   char dl_path[65];      /* default d/l path */
   char viewname[65];     /* view prog name */
   char ed_name[65];      /* editor name */
   int hmclr;             /* colors */
   int hmhi;
   int pdclr;
   int pdhi;
   int slclr;
   int slhi;
   int tcclr;
   int tchi;
   int xclr;
   int xhi;
   int ddclr;
   int ddhi;
   int kmclr;
   int kmhi;
   int pmclr;             /* colors for pulldown menus */
   int pmhi;              /* colors for pulldown menus */
   int pmrev;             /* colors for pulldown menus */
   int ascii_echo;        /* echo ascii uploads: FALSE/TRUE */
   int blankx;            /* expand blank lines in ASCII uploads */
   int tabx;              /* expand tabs in ASCII uploads */
   int cpace;             /* char pace time for ASCII uploads */
   int pchar;             /* pace character for ASCII uploads */
   int pace;              /* line pace for ascii u/l */
   int up_cr;             /* CR define for ascii u/l:      */
   int up_lf;             /* LF define for ascii u/l:      */
   int dn_cr;             /* CR define for ascii d/l:      */
   int dn_lf;             /* LF define for ascii d/l:      */
   int strip8;            /* strip 8th bit in ASCII xfers */
   int ascii_dl_to;                    /* auto timeout value for ascii dloads */
   int srpsiz;            /* kermit stuff */
   char spadchar;         /* kermit stuff */
   int ksoh;
   int spad;
   char squote;
   char sqt8bitchar;
   char sseol;
   int sbctr;             /* kermit stuff */
   int sbinary;
   int turnch;            /* kermit stuff */
   int zadl;              /* ZMODEM auto download flag */
   int zds;               /* ZMODEM time/date stamp flag */
   int zcr;               /* ZMODEM crash recovery flag (0, 1, 2, 3) */
   int zscr;              /* ZMODEM send crash recovery flag (0, 1 */
   int ztw;               /* ZMODEM tx window size (0, 2048, 4096) */
   int zcrc;              /* ZMODEM crc type (0 = 32 bit, 1 = 16 bit) */
   char epname[3][9];     /* display name */
   char epupload[3][16];  /* upload command */
   char epdnload[3][16];  /* download command */
   int epmode[3];         /* 0,1,2=ASPECT,Program,Hook */
   int relax;             /* XMODEM relaxed mode: FALSE/TRUE */
   int trash;             /* garbage placeholder */
   unsigned char textmode;             /* input mode 0:Aspect 1:word */
   unsigned char omiteof;              /* don't write EOF flag */
   unsigned char exptabs;              /* expand tab characters */
   unsigned char wordwrap;             /* word wrap enable flag */
   unsigned char justify;              /* right margin justify flag */
   unsigned tabsize;                   /* tab-stop constant */
   unsigned pindent;                   /* programming indent level */
   unsigned windent;                   /* indent level (zero-based) */
   unsigned lmargin;                   /* left margin (zero-based) */
   unsigned rmargin;                   /* right margin (zero-based) */
   unsigned es0;                       /* status line headers */
   unsigned es1;                       /* status line file information */
   unsigned es2;                       /* status line message area */
   unsigned et0;                       /* normal text display */
   unsigned et1;                       /* reverse video text display */
   unsigned et2;                       /* highlighted text display */
   unsigned ep0;                       /* prompt window display */
   unsigned ep1;                       /* prompt input field */
   unsigned em0;                       /* default message attribute */
   unsigned em1;                       /* message MSG attribute */
   unsigned em2;                       /* message EMSG attribute */
    defined(ACSI)
   char acsi_callname[17];/* ACSI server name */
      int mouse_x_sensitivity;            /* x mickey sensitivity */
   int mouse_y_sensitivity;            /* y mickey sensitivity */
   int xfer_cd;                        /* flag for testing CD in Xfers */
   int clip_separator;                 /* char sent between clipboard entries */
   int ax132;                          /* Value for AL for forced video mode */
   int hcmdrte;                        /* TRUE if using HCOMMAND.RTE */
   } ;                                 /* End of parmlist */
22                                                                   22
22 Structure for PROCOMM PLUS dialing directory entry.               22
22                                                                   22
struct DDREC
   {
   char ddname[25];                    /* name */
   char ddphone[21];                   /* phone number */
   int  ddbaud;                        /* baud rate as int */
   char ddparity;                      /* parity as short int */
   char dddata;                        /* data bits as short int */
   char ddstop;                        /* stop bits as short int */
   char dddup;                         /* duplex as short int: 0 = full */
   char ddscript[9];                   /* ASPECT file w/o ext */
   char ddlast[9];                     /* last call: mm/dd/yy */
   int  ddtotal;                       /* total connects */
   char ddproto;                       /* default protocol as short int */
   char ddterm;                        /* terminal type as short int */
   char ddmode;                        /* 0 = mode, 1 = direct */
   char ddpassword[11];                /* like it says */
   char ddmacfile[9];                  /* keyboard macro file */
   char ddkbdfile[9];                  /* keyboard mapping file */
   char ddport;                        /* com port to use */
   char ddnotefile[9];                 /* note file */
   };
22                                                                   22
22 Structure for PROCOMM PLUS .KBD file terminal entry:              22
22                                                                   22
22 struct TERMTABLE                                                  22
22    {                                                              22
22    char def[79][12];                                              22
22    };                                                             22
22                                                                   22
22 All fields are fixed length and are padded with NULLs.            22
22                                                                   22
22 The file is built in the terminal order in the term_desc array    22
22 below.  Each terminal entry has the keys stored in the following  22
22 order:                                                            22
22                                                                   22
22 KEYPAD ASTERISK (*)                                               22
22 KEYPAD MINUS (-)                                                  22
22 KEYPAD PLUS (+)                                                   22
22 KEYPAD PERIOD (.)                                                 22
22 KEYPAD SLASH (//)                                                 22
22 KEYPAD ENTER (CR)                                                 22
22                                                                   22
22 TAB                                                               22
22 BACKTAB                                                           22
22 INSERT                                                            22
22 DELETE                                                            22
22 BACKSPACE                                                         22
22                                                                   22
22 CTRL-HOME                                                         22
22 CTRL-END                                                          22
22 CTRL-PGUP                                                         22
22 CTRL-PGDN                                                         22
22 CTRL-BACKSPACE                                                    22
22                                                                   22
22 F1                                                                22
22 F2                                                                22
22 F3                                                                22
22 F4                                                                22
22 F5                                                                22
22 F6                                                                22
22 F7                                                                22
22 F8                                                                22
22 F9                                                                22
22 F10                                                               22
22 F11                                                               22
22 F12                                                               22
22                                                                   22
22 KEYPAD 0                                                          22
22 KEYPAD 1                                                          22
22 KEYPAD 2                                                          22
22 KEYPAD 3                                                          22
22 KEYPAD 4                                                          22
22 KEYPAD 5                                                          22
22 KEYPAD 6                                                          22
22 KEYPAD 7                                                          22
22 KEYPAD 8                                                          22
22 KEYPAD 9                                                          22
22                                                                   22
22 SHIFT-F1                                                          22
22 SHIFT-F2                                                          22
22 SHIFT-F3                                                          22
22 SHIFT-F4                                                          22
22 SHIFT-F5                                                          22
22 SHIFT-F6                                                          22
22 SHIFT-F7                                                          22
22 SHIFT-F8                                                          22
22 SHIFT-F9                                                          22
22 SHIFT-F10                                                         22
22 SHIFT-F11                                                         22
22 SHIFT-F12                                                         22
22                                                                   22
22 GREY CURSOR UP                                                    22
22 GREY CURSOR DOWN                                                  22
22 GREY CURSOR LEFT                                                  22
22 GREY CURSOR RIGHT                                                 22
22 GREY INSERT                                                       22
22 GREY DELETE                                                       22
22 GREY HOME                                                         22
22 GREY END                                                          22
22 GREY PGUP                                                         22
22 GREY PGDN                                                         22
22                                                                   22
22 CTRL-F1                                                           22
22 CTRL-F2                                                           22
22 CTRL-F3                                                           22
22 CTRL-F4                                                           22
22 CTRL-F5                                                           22
22 CTRL-F6                                                           22
22 CTRL-F7                                                           22
22 CTRL-F8                                                           22
22 CTRL-F9                                                           22
22 CTRL-F10                                                          22
22 CTRL-F11                                                          22
22 CTRL-F12                                                          22
22                                                                   22
22 CURSOR UP                                                         22
22 CURSOR DOWN                                                       22
22 CURSOR LEFT                                                       22
22 CURSOR RIGHT                                                      22
22                                                                   22
22 HOME KEY                                                          22
22 END KEY                                                           22
22 ENTER KEY (CR)"                                                   22
22                                                                   22
unsigned char *termdesc[] =
   "TTY     ",    /* TTY     0                   */
   "VT52    ",    /* VT52    1                   */
   "VT100   ",    /* VT100   2                   */
   "VT102   ",    /* VT102   3                   */
   "VT220   ",    /* VT220   4                   */
   "VT320   ",    /* VT320   5                   */
   "ANSI    ",    /* BBS     6                   */
   "IBM PC  ",    /* IBMPC   7                   */
   "WYSE 75 ",    /* WYSE75  8  (ANSI terminal)  */
   "ATT 605 ",    /* ATT605  9  (ANSI terminal)  */
   "ATT 4410",    /* ATT4410 10 (ANSI terminal)  */
   "TVI 922 ",    /* TV922   11 (ANSI terminal)  */
   "HEATH 19",    /* H19     12                  */
   "IBM 3101",    /* IBM3101 13                  */
   "IBM 3161",    /* IBM3161 14                  */
   "DG D100 ",    /* DGD100  15                  */
   "DG D200 ",    /* DGD200  16                  */
   "DG D210 ",    /* DGD210  17                  */
   "ADDS 60 ",    /* ADDS60  18                  */
   "ADDS 90 ",    /* ADDS90  19                  */
   "ADM 3A  ",    /* ADM3    20                  */
   "ADM 5   ",    /* ADM5    21                  */
   "ADM 31  ",    /* ADM31   22                  */
   "ESPRIT 3",    /* ESPRIT3 23                  */
   "3270/950",    /* IBM3270 24                  */
   "TVI 910 ",    /* TV910   25                  */
   "TVI 912 ",    /* TV912   26                  */
   "TVI 920 ",    /* TV920   27                  */
   "TVI 925 ",    /* TV925   28                  */
   "TVI 950 ",    /* TV950   29                  */
   "TVI 955 ",    /* TV955   30                  */
   "WYSE 50 ",    /* WYSE50  31                  */
   "WYSE 100"     /* WYSE100 32                  */
22                                                                   22
22 p.baud from the "parmlist" structure above is an index into the   22
22 following 2 arrays.                                               22
22                                                                   22
22 i.e. the current baud rate for PROCOMM PLUS is baud_rate[p.baud]. 22
22                                                                   22
char *baud_desc[] =                    /* baud rates as strings       */
long baud_rate[] =                     /* baud rates as longs         */
22                                                                   22
22 HOOK.C declarations and defines                                   22
22                                                                   22
 PARMSIZE sizeof(struct PARMLIST)
 VMAX 10
 SLEN 81
 NSIZE VMAX * 2
 SSIZE VMAX * SLEN
struct PARMLIST near p;                /* PCPLUS.PRM structure        */
int asp_nums[VMAX];                    /* ASPECT N0-N9 array          */
unsigned char asp_strings[VMAX][SLEN]; /* ASPECT S0-S9 array          */
unsigned int ptr_seg1;                 /* segment addr                */
unsigned int ptr_off1;                 /* offset addr                 */
unsigned int ptr_seg2;                 /* segment addr                */
unsigned int ptr_off2;                 /* offset addr                 */
unsigned int ptr_seg3;                 /* segment addr                */
unsigned int ptr_off3;                 /* offset addr                 */
char far *suptr;                       /* ptr to far storage          */
int type;                              /* flag from PROCOMM PLUS      */
struct SREGS seg;                      /* structure for DS value      */
22                                                                   22
22 main() program routine                                            22
22                                                                   22
22 Hook programs receive the following arguments:                    22
22                                                                   22
22 ARG 1: The string "PCPLUS".                                       22
22 ARG 2: Far pointer in ASCII to the ASPECT N0-N9 array.            22
22 ARG 3: Far pointer in ASCII to the ASPECT S0-S9 array.            22
22 ARG 4: Far pointer in ASCII to the PCPLUS.PRM structure.          22
22 ARG 5: Integer in ASCII indicating where hook was called from.    22
22                                                                   22
void main(argc,argv)
int argc;
char *argv[];
   /*
   22222222222222222222222222222222222222222222222222222222222222222222222
   22                                                                   22
   22 get value of segment registers into structure (we need DS value). 22
   22                                                                   22
   22222222222222222222222222222222222222222222222222222222222222222222222
   */
   segread(&seg);                      /* get value of DS register    */
   /*
   22222222222222222222222222222222222222222222222222222222222222222222222
   22                                                                   22
   22 get segment and offset of ASPECT N0-N9 array...                   22
   22                                                                   22
   22222222222222222222222222222222222222222222222222222222222222222222222
   */
   suptr = (char far *) atol(argv[2]); /* convert str to ptr          */
   ptr_seg1 = FP_SEG(suptr);           /* get segment addr            */
   ptr_off1 = FP_OFF(suptr);           /* get offset addr             */
   /*
   22222222222222222222222222222222222222222222222222222222222222222222222
   22                                                                   22
   22 copy ASPECT array into local array                                22
   22                                                                   22
   22222222222222222222222222222222222222222222222222222222222222222222222
   */
   movedata(ptr_seg1,ptr_off1,seg.ds,(unsigned int)&asp_nums[0],NSIZE);
   /*
   22222222222222222222222222222222222222222222222222222222222222222222222
   22                                                                   22
   22 get segment and offset of ASPECT S0-S9 array...                   22
   22                                                                   22
   22222222222222222222222222222222222222222222222222222222222222222222222
   */
   suptr = (char far *) atol(argv[3]); /* convert str to ptr          */
   ptr_seg2 = FP_SEG(suptr);           /* get segment addr            */
   ptr_off2 = FP_OFF(suptr);           /* get offset addr             */
   /*
   22222222222222222222222222222222222222222222222222222222222222222222222
   22                                                                   22
   22 copy ASPECT array into local array                                22
   22                                                                   22
   22222222222222222222222222222222222222222222222222222222222222222222222
   */
   movedata(ptr_seg2,ptr_off2,seg.ds,(unsigned int)&asp_strings[0][0],SSIZE);
   /*
   22222222222222222222222222222222222222222222222222222222222222222222222
   22                                                                   22
   22 get segment and offset of PCPLUS.PRM structure from PROCOMM PLUS  22
   22                                                                   22
   22222222222222222222222222222222222222222222222222222222222222222222222
   */
   suptr = (char far *) atol(argv[4]); /* convert str to ptr          */
   ptr_seg3 = FP_SEG(suptr);           /* get segment addr            */
   ptr_off3 = FP_OFF(suptr);           /* get offset addr             */
   /*
   22222222222222222222222222222222222222222222222222222222222222222222222
   22                                                                   22
   22 copy PROCOMM PLUS' structure into local structure                 22
   22                                                                   22
   22222222222222222222222222222222222222222222222222222222222222222222222
   */
   movedata(ptr_seg3,ptr_off3,seg.ds,(unsigned int)&p.port,PARMSIZE);
   /*
   22222222222222222222222222222222222222222222222222222222222222222222222
   22                                                                   22
   22 "TYPE" lets you know where the hook program was called from in    22
   22 PROCOMM PLUS:                                                     22
   22                                                                   22
   22 TYPE VALUE       CALLING LOCATION                                 22
   22 ---------------------------------                                 22
   22     0            Upload Protocol                                  22
   22     1            Download Protocol                                22
   22     2            Aspect Script                                    22
   22     3            Meta Key Hook                                    22
   22                                                                   22
   22222222222222222222222222222222222222222222222222222222222222222222222
   */
   type = atoi(argv[5]);
   /*
   22222222222222222222222222222222222222222222222222222222222222222222222
   22                                                                   22
   22 The following code is a simple example of what you can do with    22
   22 a "hook" program.  It assumes it was called fram an ASPECT script 22
   22 and was passed some information in ASPECT variables N7 and S7.    22
   22 It displays that information, then displays some information      22
   22 about current settings in PROCOMM PLUS.  It then puts new data    22
   22 into N7 and S7 and passes it back to PROCOMM PLUS.                22
   22                                                                   22
   22 This is a sample ASPECT program that you can use with this hook   22
   22 program to show how things get passed back and forth:             22
   22                                                                   22
   22 proc main                                                         22
   22    locate 0 0                                                     22
   22    n7 = 777                                                       22
   22    strcpy s7 "This message is from the ASPECT file."              22
   22    hook "hook.exe"                                                22
   22    fatsay 10 0 31 "ASPECT variable N7 passed from hook: %d" n7    22
   22    fatsay 11 0 31 "ASPECT variable S7 passed from hook: %s" s7    22
   22 endproc                                                           22
   22                                                                   22
   22222222222222222222222222222222222222222222222222222222222222222222222
   */
   /* sample: */
   printf("\nASPECT variable N7 passed to hook: %d",asp_nums[7]);
   printf("\nASPECT variable S7 passed to hook: %s",asp_strings[7]);
   printf("\n\n\nPROCOMM PLUS INFO:\n");
   printf("\nBaud Rate: %s, Terminal: %s",baud_desc[p.baud],termdesc[p.termtype]);
   printf("\nPort: COM%d, Modem Init String: %s",p.port+1,p.mdminit);
   /* put some info into variables for return to ASPECT... */
   asp_nums[7] = 99;
   strcpy(asp_strings[7],"This message is from the hook program.");
   /* copy local variables back into ASPECT variables... */
   movedata(seg.ds,(unsigned int)&asp_nums[0],ptr_seg1,ptr_off1,NSIZE);
   movedata(seg.ds,(unsigned int)&asp_strings[0][0],ptr_seg2,ptr_off2,SSIZE);
   /* signal normal exit (can be tested for with ASPECT "if success" command) */
   /* 0 signal sucess, 1 signals failure.                                     */
   exit(0);
-----====> Skye Merlin Poier <====----- Undergrad in CMPT/MATH (Virtual Reality)       ||||      ||||
          email: poier at sfu.ca                  p-OO <--> OO-q   THINK
   PGP Public Key available on finger           \==      ==/

@_date: 1993-06-08 16:56:17
@_author: Skye Merlin Poier 
@_subject: ALERT / My email address is... 
:) I suggest that we try to create an encrypted cypherpunks list?  Comments?
Sounds good to me.

@_date: 1993-06-09 09:24:49
@_author: Skye Merlin Poier 
@_subject: InfoWorld 
The FBI expects organized crime and terrorists to begin encoding
        information.
Begin? Huh? Give me a break....
-----====> Skye Merlin Poier <====----- Undergrad in CMPT/MATH (Virtual Reality)       ||||      ||||
          email: poier at sfu.ca                  p-OO <--> OO-q   THINK
   PGP Public Key available on finger           \==      ==/

@_date: 1993-05-16 22:37:55
@_author: na-Baron Feyd-Rautha Harkonnen 
@_subject: Double encryption 
Being the security freak that I am, even with military grade encryption (for
whatever THATS worth) I feel a little insecure, as most routines are, as far
as I can tell, still succeptable to at the least brute force attacks. I was
wondering: how to cracking programs determine that they have successfully
decrypted a file? Does it simply look for english text (or file headers etc)?
If so, how about double-encrypting a file with two completely different and
very complex programs? Then, even if it did get the first, it couldn't tell
because the resulting data would still be largely gobbledegook.
Probably a stupid question, but I was curious.
"Thppt bwach oop ack" - Bill the Cat | -----====> Skye Merlin Poier <====-----
PGP Public Key available on request  | Undergrad in CMPT/MATH (Virtual Reality)
!!!!!!! FIGHT CLIPPER / LEEF !!!!!!! |          email: poier at sfu.ca

@_date: 1993-05-17 18:24:11
@_author: na-Baron Feyd-Rautha Harkonnen 
@_subject: The Clipper (clip on <clap clap> clip off <clap clap>) 
One question regarding the proposed Clipper chip:
What exactly is the key escrow facility? From what I can tell, it seems to be
the bit that allows the LEEF...
"Thppt bwach oop ack" - Bill the Cat | -----====> Skye Merlin Poier <====-----
PGP Public Key available on request  | Undergrad in CMPT/MATH (Virtual Reality)

@_date: 1993-05-17 23:15:50
@_author: na-Baron Feyd-Rautha Harkonnen 
@_subject: Request for requests 
Please email me (or post directly) as to any companies in the Vancouver/Seattle
area doing encryption research for any governmental agency. I wish to keep tabs
on such companies, and I'd be more than willing to share any findings.
Feyd Eli
-----====> Skye Merlin Poier <====----- Undergrad in CMPT/MATH (Virtual Reality)       ||||      ||||
          email: poier at sfu.ca                  o-OO <--> OO-o   THINK
  PGP Public Key available on request           \==      ==/

@_date: 1993-05-18 02:12:15
@_author: na-Baron Feyd-Rautha Harkonnen 
@_subject: Question 
Hi... What does GCHQ stand for, and what does it do? Is it similar to the NSA?
Feyd Eli
-----====> Skye Merlin Poier <====----- Undergrad in CMPT/MATH (Virtual Reality)       ||||      ||||
          email: poier at sfu.ca                  p-OO <--> OO-q   THINK
   PGP Public Key available on finger           \==      ==/

@_date: 1993-05-19 17:58:23
@_author: Skye Merlin Poier 
@_subject: Where are the key servers? 
What are the address(es) of the worldwide key server(s)? I thought I had them
around here somewhere....

@_date: 1993-05-20 17:44:20
@_author: Skye Merlin Poier 
@_subject: Crypto constitution 
One suggestions for improving the constitution: change all occurances of
"Men" or "man" to "the people" and make all pronouns gender-neutral.
If this is going to be a constitution for the new age, lets have the wording
reflect the ideals we hold.

@_date: 1993-05-20 23:20:59
@_author: Skye Merlin Poier 
@_subject: Crypto constitution 
[reality check on]
Excuse me, but it seems that you are being very defensive. I was not picking
a fight. It is evident that you cling to "It used to be that" ideals. Just because something "used to be" is not justification for its perpetuation. Is
it such a drastic step to replace a couple words that you feel necessary to
ridicule something that I consider important? As far as I am concerned, Mr.Diehl
it is YOU who are being childish. Wake up, will you? And please refrain from
using the word "we". I do not enjoy being patronized.
Obviously. You are indeed a man of tremendous wit and satire. Also plainly obvious. Skye Poier
-----====> Skye Merlin Poier <====----- Undergrad in CMPT/MATH (Virtual Reality)       ||||      ||||
          email: poier at sfu.ca                  p-OO <--> OO-q   THINK
   PGP Public Key available on finger           \==      ==/

@_date: 1993-05-25 13:55:34
@_author: Skye Merlin Poier 
@_subject: your mail 
:)   The proposal specifically is to extend PGP beyond file encryption
:)   to generalized stream handling.  Such streams can be consoles &
:)   keyboards, real-time file transfers, and digitized voice; indeed,
:)   anything that will pass over a modem or other serial transfer medium.
This is already being attempted: Ytalk version 2.1 has both a single key
stream encryption feature and a PGP encryption feature ( I haven't been able
to get the PGP encryption feature to work, however.). It is still in beta
testing, but it looks like it will be out soon...

@_date: 1993-05-25 16:20:04
@_author: Skye Merlin Poier 
@_subject: Anonymity on the net 
I know of several anonymous remailers: would it not be a good idea to "link up"
several of these hosts so that one mails the first remailer, which mails another
and so on and so on.... This would be a real pain in the butt to retrace, as
surely the owner info wont be rubber hosed out of all of the host bosses....

@_date: 1993-05-28 21:31:16
@_author: Skye Merlin Poier 
@_subject: Modified Vigenere encryption? 
I was just thinking... What if one were to use Vigenere encryption with a key
at least as long as the message (therefore making the incidence of coincidences
irrelevant)? A key made of, for instance, words strung together from a dictonary
selected pseudorandomly? Are there other weaknesses in the Vigenere system that are escaping me? Perhaps
one could use (in the pseudorand words example) distribution / transition / equilibrium proabilities in the english language? If so, are there any other
options for generating a long key without the need for a truly random key (which
would make using the Vigenere table pointless because it would just be an one-
Also, what are the weaknesses of the Playfair cypher? My texts mention it, but
don't say much of anything other than how it works...
Just pondering at odd hours...

@_date: 1993-05-31 15:06:43
@_author: Skye Merlin Poier 
@_subject: Crypto anarchy in a VW? (not the bug) 
Has there been any discussion of anonimity / crypto anarchy in a virtual world
such as the ones described in _Snow Crash_ or _Neuromancer_? When the nets to
support these technologies come into place (and I have no doubt that they will),
perhaps a form of anonimity could be written into the architechture, instead of
having to add it on later as is the case now.... I would certainly be very interesting, especially with the work being done on creating alternate personas
(or avatars, whatever).
Also, a while back someone mentioned in passing buried cables.. this stirred up
an old idea I had about server anonimity, that is that the actual physical location of a server would be very difficult to pin down... the only way to do
this with any real degree of security would be to bounce signals off a satellite
but this would be rather costly...
-----====> Skye Merlin Poier <====----- Undergrad in CMPT/MATH (Virtual Reality)       ||||      ||||
          email: poier at sfu.ca                  p-OO <--> OO-q   THINK
   PGP Public Key available on finger           \==      ==/
