
@_date: 2003-04-21 19:55:33
@_author: Patrick Chkoreff 
@_subject: Three Cheers for the State - RAH RAH RAH 
You're on a roll, Mr. Bob Hettinga:
To summarize:
- Opposing any war is treason.
- Every human activity should be taxed.
- Failure to tax is equivalent to subsidy.
And from the above I conclude that you like it that way.
Three cheers for the state, rah rah rah!
Digital bearer settlement is treason.

@_date: 2003-04-24 11:09:00
@_author: Patrick Chkoreff 
@_subject: [Lucrative-L] lucrative accounts revisited 
Hash: SHA1
I am taking a different approach, where the server stores RIPEMD-160 hashes of all the redeemable coins "out there."  It completely forgets redeemed coins.
Because the server only stores hashes, the entire contents of the server database could literally be published on the web in streaming live form without seriously reducing the security of the system.  Of course, this would be stupid because it would needlessly invite collision attacks, but in principle the idea of avoiding security through obscurity could be applied to the database itself.  But then, why not hide the hash file behind a Unix password, and behind an AES-256 key while we're at it?  :-)
So a coin consists of an lseek position in the server data file, 256 bits of random gibberish, and 64 bits representing the amount.  When you present the coin to the server, the server hashes it and looks at the given lseek position.  If it matches, it manufactures a new coin at some other lseek place and sends it to you.  You store the coin, compute the RIPEMD-160 hash yourself, and send that to the server, at which point it kills the old coin and enlivens the new coin.
Obviously all the smart folks who talk about storing only the redeemed notes and even using probabilistic double-spend detection methods have reasons for doing so.  I expect my scheme will be slapped down forthwith.  :-)
You're preaching to the choir here.  I haven't seen any snake oil proposals lately (unless I just gave one above.  :-)
Good C libraries for existing crypto protocols are always welcome.  I'm just getting Rijndael, RSA, RIPEMD, BBS, etc. into a shape I like.  Mostly, I don't like routines that declare *anything* on the stack -- all of my working space is allocated on a single 4k mlocked page up front and Mersenne-twisted before munlock and free.
Ah, Marvin for "medium" considered non-standard.  :-)  OK, Trent it is.

@_date: 2003-04-24 15:35:46
@_author: Patrick Chkoreff 
@_subject: [Lucrative-L] lucrative accounts revisited 
I can see your point, but let me think about it a bit.  Alice is at a craft fair with digital coins loaded into a PDA that costs at least $100.  So she's already somewhat of a geek to begin with.  But she is glad that her general-purpose PDA is capable of handling coins in addition to her date and address book.  No need to pony up more money for a specialized crypto-wallet.
But for every geeky Alice, there are at least one hundred non-geeky Alyssas out there.  Alyssa is not likely to purchase a relatively expensive and difficult to use general purpose device.  She might, however, pony up for an inexpensive, easy to use, specialized crypto-wallet.  She would not consider anything that has icons and a stylus, but she would readily adopt a sleek little black-box crypto-wallet.  Maybe it even comes in her favorite colors.
So even if the network is as reliable and ubiquitous as the atmosphere itself, in this new digital coin economy both Alice and Alyssa are going to be carrying around SOMETHING.  Which is easier, persuading geeky Alice to purchase a cheap specialized device, or persuading non-geeky Alyssa to purchase an expensive clunky general purpose device?
Of course, the network will NOT be as reliable as the atmosphere itself, and there is at least one alternative.  Physical cash is the obvious choice -- after all, these digital coins are ultimately redeemable for valuable physical objects like gold and silver coins or notes for same, so I expect people to carry around a combination of valuable atoms and valuable bits as they shop.
But in the case of inexpensive crypto-cards, there is a second option.  Direct offline beaming of digital coins from one device to another.  Assuming it can be done simply, inexpensively, and securely.  So when the network is inaccessible and Alyssa is out of cash, she's still in luck.  Whip out the candy-red colored crypto-wallet and snag the Definitely.  At the very least, the issuer stores that in the vault to back up the digital coins.  :-)  But seriously, people are going to want to hold and trade valuable physical stuff because it is a form of wealth independent of the server, ubiquitous networks, or even crypto-wallets.  It's the real deal, the final deliverable upon which all bit-bashing is based.
This is a very good question.  Obviously if you are an ISSUER I can see how it might be profitable -- you simply charge transaction fees whenever coins are swapped, split, merged, etc. at the server.  You can assess storage fees to cover your base costs or even try to nick a small profit there.  All of this would be implemented as tunable parameters in the server software, perhaps even DYNAMICALLY self-tuning based on market conditions, changing constraints on bandwidth and disk usage, etc.
If you are a mere CODER like Lucrative-Patrick and Fexl-Patrick, well sorry, we're just slaves in it for the fun.  :-)  Work for tips, become an issuer, hold a day job, whatever it takes to get your next fix.

@_date: 2003-04-24 15:52:28
@_author: Patrick Chkoreff 
@_subject: [Lucrative-L] lucrative accounts revisited 
Alternatively, I think a copy of the non-spent coins will do the trick So in your scenario, the predicate valuable(x) = valid_crypto_stamp(x) & not element(x, spent_coins).
In my scenario, valuable(x) = element(x, unspent_coins).
Why store the large set of spent coins when you can store the much smaller set of unspent coins?
There's no security issue I don't think.  In my scheme the bad guys can torture you and get access to the hash file, yes, but what's the point?   They still have to mount a multi-million dollar collision attack.  It's much easier just to seize the gold in the vaults than fiddle around with some pathetic bits on a server.  Or if the digital coins are backed by something like e-bullion they can just torture you for the e-bullion password.
I don't understand your point here.  Why are my transaction costs greater than yours?  They might even be less.  The disk usage might be less, too.

@_date: 2003-04-24 16:51:05
@_author: Patrick Chkoreff 
@_subject: Double spending, i.e. X in S == not X not in S 
No, which indicates there is one huge unshared premise at work here.  I assert that I can prevent double spending without keeping the spent coins, even for a limited time period.
It's simple.  Alice gives Bob a coin X.  Bob immediately swaps coin X for a brand new coin Y.  The server deletes coin X completely, forgetting the bits with extreme prejudice.
Now Alice tries to give Charles the same coin X.  Charles immediately attempts to swap coin X for a new one.  The server tries to look up X in the set of valid coins and does not find it.  The server says "Sorry, Charlie, that is not a valid coin."
The whole thing depends on the recipient doing an immediate swap.  But that's no big requirement, because the recipient must contact the server to see if it's a valid coin anyway.  So you just go ahead and do a swap at that point.

@_date: 2003-04-24 18:12:34
@_author: Patrick Chkoreff 
@_subject: double-spending prevention w. spent coins (Re: 
Hash: SHA1
Although I have read some material on blinding etc., I do not see a need for it in my system.
At Tim May's suggestion I shall avoid using the word "coin" and use the more accurate financial term "note" instead.
Although technically a note in my system is <32-bit file position><256-bit random gibberish><64-bit amount>, I'll use a simpler and abbreviated decimal notation with dashes in the quick example that Alice has a note "0247-223235898-00032" that entitles her to 32 grams of e-bullion.  She decides to take delivery.  She presents the coin to the server and the server computes the RIPEMD-160 hash.  It looks at record number 247 in the data file and sees if the hash stored there matches the computed hash.  If so, the server extinguishes the coin (randomizing the record and chaining it to the free list) and spends 32 grams of e-bullion to the account that Alice designates, no questions asked.  (Obviously you have to handle any errors in the e-bullion spend

@_date: 2003-04-24 21:22:14
@_author: Patrick Chkoreff 
@_subject: [Lucrative-L] lucrative accounts revisited 
Strictly speaking, my server stores neither the valid nor the invalid coins.  It stores the hashes of the valid coins.  Therefore, the server has no way of discerning the details of any coin stored in its database.  All it can do is recognize a valid coin when it sees one, and immediately extinguish it and issue a new one.
So, can somebody give me a concrete example of a "linkage" problem here?  I'll tip you a couple of grams in the DGC of your choice if you can do a good job of it.
One person suggested that Citibank might issue a coin X to Alice, who then spends it at Bob's Kinky Sex Emporium, who then deposits that coin at Citibank.  Citibank begins building a profile of Alice's kinky tastes because it remembers issuing X.
But that is simply not how it works.  Citibank issues coin X to Alice.  Alice immediately swaps X with the server and obtains a new coin Y.  Alice gives coin Y to Bob in return for kinky porn.  Bob immediately swaps Y with the server and obtains a new coin Z.  Bob gives coin Z to Citibank.  Citibank immediately swaps coin Z with the server and obtains a new coin A.  I do not see "linkage" here.  Citibank never sees X again.
To be clear, I am NOT trying to solve the problem of having a coin circulate several times out in the wild without any contact with a server, and somehow prevent a double spend in that scenario.  I do not see how that is even remotely possible.  Alice has a fancy string of bits on her computer.  She transmits that string of bits to Bob and gets a sweater.  Then she transmits the same string of bits to Charles and gets a beer.  You cannot prevent this without consulting a server.

@_date: 2003-04-24 23:10:20
@_author: Patrick Chkoreff 
@_subject: double-spending prevention w. spent coins 
This is helpful, Adam, thanks.
This is good too, Bill.
All right, I can generally understand the purpose here, to make it impossible to correlate an old coin with a new one issued in its place.   That I can see.  I was starting to get the impression that somehow the Chaumian techniques were attempting to address the problem of preventing double spends even when doing a long chain of spends without contact with a server.  In fact they are trying to address a more modest goal than that, and double spends are still something that must be detected by contact with the server.
With the Chaumian techniques, the random coin bits are generated on the user side:
So naturally the server cannot keep a list of the valid coins because their specific bits appear to be invented out there in the wild.  Hence keeping the list of spent coins, since keeping a list of unspent coins is clearly impossible.
Well hell, that wasn't so hard.

@_date: 2003-04-25 14:20:37
@_author: Patrick Chkoreff 
@_subject: Thanks for the living hell, and question about OpenSSL 
Hash: SHA1
Sincere thanks to everyone for the living hell I went through yesterday.
I do understand the rationale for blinding now.  The math was never the problem.  I was mistakenly thinking that because my sacred code did not in fact record any IP-based transmission logs, users were safe as far as anonymity and privacy were concerned.  What I missed was that if someone put a gun to my head and said "Put in some code to keep transmission logs and don't tell anybody or I'll kill your family," I would in fact obey and the security of the system would be compromised without anyone knowing.  As RAH says, force monopolies are a bitch.
So I'm taking blinding under my wing and working out some example scenarios of exactly how a system might work.  I want to be able to describe it to novices.  For example, you go to the post office and ship 10 gold coins to such-and-such bank.  After they receive the coins, you fire up this program on your computer and do this-and-that.  Then to transmit value to your friend in Helsinki, you do this other thing over here.  Then your friend in Helsinki fires up a program and does such-and-such, and three days later 7 gold coins appear on his doorstep.  That kind of thing.  Something that makes a roomful of people who know nothing about modular arithmetic brighten up and think "Hey, I really think I could *use* that."
On a technical note, I really like what I see at  and I'm mucking around with it as a possible platform.  Does anybody have any comments or concerns regarding the suitability of OpenSSL for the purposes we are discussing here?

@_date: 2003-04-25 18:01:24
@_author: Patrick Chkoreff 
@_subject: Thanks for the living hell, and question about OpenSSL 
Hash: SHA1
(-:  The sig is valid for the key at True.  From the thrashing I took yesterday, I conclude that subpoenas and other forceful means of system compromise are very cheap indeed.  That assumes the system is big enough to matter to the bad guys, which is definitely false at initial rollout but from the looks of this crowd is likely to remain false forever if the system cannot guarantee protection against that threat.  Everybody here wants an improvement over book-entry systems, but nobody will settle for anything less than fully blinded digital notes.
The question of whether digital notes can circulate in the wild without server contact but with the ability to identify double-spenders later is up for grabs.  Hettinga likes that feature for intrinsic reasons having nothing to do with network reliability or ubiquity.  I find it a bit appealing myself because it can help support small social nets of accountability.  I have not reviewed the math in detail, but am I to understand that under this protocol ONLY double-spenders can be identified?  That is, if you do not double-spend can you be guaranteed anonymity from other recipients down the spend chain?
Obviously those in the know share a common threat model that demands blinding.  Certainly that has serious implications for the server.  In a non-blinded system you can just store a small number of unspent coins and the server can do tricks like include an lseek number in the coin data to make lookup extremely fast.  But nobody wants an non-blinded system.  Consequently, the server must store a large number of spent coins and because coin identifiers are created randomly out in the wild there is no convenient embedded lseek number.  But yes, it is extremely cool that you can get the bank's signature on X without actually revealing X to the bank.
Certainly there are more detailed threats than forced compromise to consider.  Some precautions you take just because you can -- lock and randomize memory for example.  But whether you turn on internal churning mechanisms to prevent timing attacks, put ceramic caps on memory components, put boxes in Faraday cages, etc. is another story

@_date: 2003-04-25 18:30:58
@_author: Patrick Chkoreff 
@_subject: Thanks for the living hell, and question about OpenSSL 
Hash: SHA1
I'm writing "(unblind (sign (blind X))) = (sign x)" on the board one hundred times.

@_date: 2003-04-25 19:49:23
@_author: Patrick Chkoreff 
@_subject: Correction 
Waste of bandwidth I know, but it's bugging the hell out of me.  Please upper-case that 'x'.

@_date: 2003-04-25 21:54:33
@_author: Patrick Chkoreff 
@_subject: Thanks for the living hell, and question about OpenSSL 
Hash: SHA1
No no, I'm not writing it out of blind obeisance.  I actually see how and why blinding achieves anonymity and avoids the trust issue.  When someone presents a note for redemption, the server literally has no way of knowing to whom that note was originally issued.  All it knows, and all it can *possibly* know, is that it is a valid note that has not been redeemed.
In the previous scheme I was simply not aware of this design goal.  I did not even view my system as implying a promise not to look.  I simply viewed it as a system that does not in fact look.  But I see now why that's a problem, because (1) a system that does not look now can start looking tomorrow and (2) users have no way of knowing either way.   So the promise of which you speak is in fact implied, as I know today after my cypher-hangover this morning.  Nothing a four mile walk with the dog couldn't cure.
That's funny, it was a 1989 CACM article by J. Steensgaard-Madsen that triggered my ideas about purely function languages like Fexl.  Classic stuff from the 80's.  Thanks for the intriguing reference.
Right, actually I'm scribbling out a system overview in terms of functions with specific properties independent of their implementation in modular arithmetic or anything else.  Basic relationships like (encrypt (decrypt X)) = X,  (unblind (sign (blind X))) = (sign X),  (sign X) = (decrypt (hash X)).  Definitions like a 'note' is .  Identifying which functions are secret to whom and which are public.  Generation procedures such as:  given a public 'encrypt' function, generate a random pair of functions  with specific desirable properties.  All without reference to any specific number-theoretic + padding implementations.
This helps me get a feel for the whole flow of the system and all it implies.  That plus a strong platform like OpenSSL (I presume) should yield good application code.  I'm not much of a GUI guy, so I may just do a reasonably substantial API layer, a tight set of user-side command line primitives, and a socket-based server program.  Or I may just throw in the towel and burrow around in the Lucrative code, but I'm not much of a Java guy either.
Again, I must stress that I was never *knowingly* advocating that users must "trust me."  I was not aware until yesterday that "trust me" was, in fact, an implied premise in my system.  Certainly if there was some meta-certain way for users to know that my system was not keeping records, it could work just fine.  But there isn't, so it couldn't.
Sounds great.  Thanks again.

@_date: 2003-04-25 23:22:41
@_author: Patrick Chkoreff 
@_subject: Authenticating Meat 
Hash: SHA1
Let me know when you're in the Jasper, Georgia area and we'll have a few beers.  :-)
That about sums up my digital identity, yes.  The real Patrick is tied up in the cellar and I forced him to tell me his password.  As the de Vere and Marlowe scholars might say, the works of Shakespeare were not written by Shakespeare, but by somebody else using that name.  Not to compare myself with Shakespeare.  All too often my words are full of sound and fury, signifying nothing.  Like now.
Will do, thanks.  I have plenty of reading ahead of me.
Well said.  I find it utterly amazing that mere sequences of bits can accomplish this.
Oh God, so it's that obvious?  I'm devastated.
All this talk about meatspace suggests we should have some spare ribs with those beers.
Of course, writing style and personality can help expose private key hijacking and impersonation somewhat, though even that can be counterfeited.  I can recognize a post by JP May with my eyes squinted, just looking at the shapes of the letters and paragraphs.  But I bet I could do an utterly, mind-bogglingly good impersonation if I tried.
BE the bits.

@_date: 2003-04-27 11:35:25
@_author: Patrick Chkoreff 
@_subject: Anonymous Transport Layer 
Hash: SHA1
(Regarding my non-blinded scheme)
I have sometimes wondered if it might be possible to use non-blinded digital notes on top of an anonymous transport layer and thereby achieve the same untraceability as that provided by blinded digital So, I considered the possibility that a coder might be lazy and write a system that over normal IP would have undesirable traceability characteristics, and simply wave his hands and say "Ah, no problem, I'm letting the transport layer (Tarzan, ANON, etc.) take care of that."
If such a division of labor were possible, it would be analogous to using a Secure Socket Layer in an application, knowing only how to set up and tear down the protocol but nothing in particular about One might even assume the worst case, that the server records every bit of information it ever receives for all time.  The main events recorded would be of the form "At time T, the server received note P[i] for redemption and sent out note P[i+1] in return."  So there would in fact (worst case) be a traceable chain P[1]-> ... ->P[n].  However, there would be no IP address information because of the anonymous transport Yes, I see, the P[1]->...->P[n] chain.
Yes, but the 20 rounds of thrashing occur within a specific short time period, so that won't fool ANY spook worth his salt, right?
Alice deposits a gold Maple at the bank and receives P[1].  The next day she thrashes P[1]-> ... -> P[20] in a period of one second.  Four days later she spends P[20] with Bob's Kinky Sex Emporium.  Bob swaps P[20] for P[21].  The next day he redeems P[21] for a gold Maple (ignoring fees of course).
I guess the problem here is that the bank receiving and issuing gold Maples knows that P[1] belongs to Alice and P[21] belongs to Bob at Kinky.   The time stamps on the chain of swaps P[1] ...  P[20] look suspiciously like obscurity-thrashing, although the bank cannot be absolutely sure, of course.  Instead, Alice might have spent P[1] for a gardening book at Amazon and some kinky employee there did the thrashing P[2] ... P[20].
Such a scheme might provide a certain level of plausible deniability, but I am not sure one could capitalize on it enough to build a solid system.  It does sound a bit crufty compared to blinding, although the possibility of a more efficient implementation (storing unspent coins only for low disk usage and hyper-fast lookup) might compensate -- although there might be a cost in bandwidth, but that might be proportional to paranoia level and charged accordingly.
The idea of implementing a relatively unsafe digital note protocol on top of an anonymous transport layer is appealing, but I am not sure such a division of labor is possible.  Can anyone provide a bit of guidance on this point?  I know Google is my friend, but this is a pretty subtle question and just a hint will suffice.
The problem at the endpoints described above might be mitigated considerably if we had a world-wide network of gold kiosks providing bidirectional swapping of physical gold and digital notes -- a true e-hawala.  Alice could don a ski mask and deposit a gold Maple in Jasper, Georgia, and five days later Bob at Kinky could don a ski mask and receive a gold Maple in Helsinki.  There would be no "bank" where Alice or Bob would have to identify themselves.
There's an ideal world scenario for you -- gold kiosks, cheap disposable smart card note purses, and wireless network everywhere.  In an interesting twist, this would not in fact be a "cashless society," but an even more "cashful society" with one brand new feature:  the ability to teleport fungible gold atoms from Jasper to Helsinki in a fraction of a second.  The ultimate hawala, where oil-powered shipment of gold would only occasionally be necessary to balance out the kiosk inventories.  Perhaps eventually the need for giant central stores of gold could be nearly eliminated.  Gold would just be laying around in kiosks everywhere on the planet, just waiting for someone with the right bits (or tools :-) to pick it up.  I'm sure many of you have discussed such starry-eyed visions at length, but please forgive this newbie for indulging a bit as this cappuccino-inspired vision possesses

@_date: 2003-04-28 13:47:37
@_author: Patrick Chkoreff 
@_subject: [Lucrative-L] Anonymous Transport Layer 
Hash: SHA1
Perhaps because the system would be easier to implement and much more efficient in both space and time.
The idea is to have a division of labor, where the anonymous transport layer takes care of the nasty stuff and the application writer has it relatively easy.
Consider that even in a blinded note system, the black hats will be able to detect that you are making a habit of contacting the note server, even if they cannot tell which specific notes you are generating.  An anonymous transport layer would help to conceal that as It's just a thought.  In programming, laziness is sometimes, but not always, a virtue.
By the way, does a working Tarzan library and network even exist right

@_date: 2003-12-18 00:24:48
@_author: Patrick Chkoreff 
@_subject: [dgc.chat] Fwd: [NEC] #2.12: The RIAA Succeeds Where the 
Right, a fair point.  I've heard cypherpunks say that and I do think Clay was being a bit hard on them.  To place the cypherpunks in the best possible light, perhaps better than they deserve, we might say it's sort of like criticizing Nikola Tesla for not routing an AC power grid through rural Tennessee.
Yes, I have seen statements to that effect.
Mind you, I only had occasional exposure to the cypherpunks list via Hettinga's feed.  Which is probably fine because I have heard that receiving the cypherpunks list is like drinking from a fire hose, and Hettinga seems to forward the really informative and entertaining stuff from Tim May, Adam Back, et al anyway.
Right, on the one hand it's cool that hordes of otherwise ordinary computer users can become interested in "darknets," but on the other hand it's a bit scary that the sheer scale of it is orders of magnitude beyond getting a whiskey in a speakeasy.  This could either thoroughly discourage the government or motivate them to do really draconian things like requiring computers and chips to meet a specific government specification which severely limits how they function.  They're working on it.
Yes, a good observation from the time of the first big "War on Drugs," that is, the demon alcohol, wrecker of homes and corrupter of public morals, as anyone who has watched "Cops" can attest.  Now I need a drink -- a glass of port sounds good.

@_date: 2003-06-20 16:28:13
@_author: Patrick Chkoreff 
@_subject: Quoting Anne Coulter is like... 
Yesterday I caught Keith Olberman's show on MSNBC when he was announcing that Fox News will be hiring Dennis Miller for occasional guest commentaries.  Keith Olberman is known for his funny quips, but yesterday he did a drop-dead hilarious impression of an extended Dennis Miller rant.  Only this time, it was Keith Olberman ranting against Fox's "We decide, you obey" reporting style.  The writing and delivery were perfect, and he really hit his target.
I've nearly boycotted TV news lately, so that was the first time I've seen his show.  I'll Tivo it for entertainment value if nothing else.

@_date: 2007-06-03 09:51:07
@_author: Patrick Chkoreff 
@_subject: [gsc] Does anyone out exchange loom? 
I am getting two very different classes of reaction from users:
1. I cannot believe how easy this interface is!
   It's amazing!
2. I have no idea how to use this user interface!
   It sucks!
I believe the problem is primarily conceptual.  Here's a little
background on how Loom works.
Consider buying a shirt at a retail clothing store.  You walk up to the
counter with the shirt, the cashier rings it up, and says that will be
37 euros please.  You take the 37 euros out of your wallet and put it on
the counter.  The cashier then picks up the 37 euros and puts it in the
cash register.  You are now the proud owner of a new shirt.
Loom works in a similar way.  When Alice wants to pay Bob some euros,
she does *not* stuff the euros directly into Bob's wallet or cash
register.  Instead, Alice puts the euros in a place where Bob can reach
them.  Then Bob *himself* picks up the euros and puts them into his
wallet or cash register.
That place on the counter-top where Alice puts the euros is called the
"drop point."  It is a location where the ownership of the euros is up
for grabs.  If Bob refuses the payment, Alice can take the euros right
back from the drop point and put them back in her wallet.
So a payment in Loom is a two-step process.  Note that I am using
"euros" in this example simply to make it more familiar to readers.
Loom itself knows nothing about specific asset types like "euros" or
even "gold" -- Loom is basically just an online spreadsheet of sorts.
So again, a payment in Loom is a two-step process.
1.  Alice moves the euros from her personal stash to
    a drop point X.
2.  Bob moves the euros from the drop point X to his
    personal stash.
Now before Alice can pay Bob, they need to *establish* that shared drop
point X, and add it to their own respective folders.  It doesn't matter
who dreams up the drop point first, but let's say Alice does it.
In her folder, Alice clicks Locations, then clicks to add a new
location, presses Random to generate a new random drop point, types
"Bob" as her nickname for that location, and presses Save.
Now when Alice wants to give something to Bob, she can easily select
"Bob" from the drop-down menu in her folder.
But at this point only half of the picture is complete.  Bob has not yet
added the drop point to his *own* folder.  First, Alice obviously needs
to tell Bob the new drop point she generated.  Ideally she could copy
and paste the location into a PGP-encrypted email, but alternatively she
could send it via Skype, or read it to Bob over the phone, or even send
it in a plain unencrypted email.  (Most of the time the drop point will
be empty, so anyone intercepting the email and looking at the drop point
will not typically see any assets.  Let the user beware.)
That part, the *communication* of the shared drop point, is where people
have to be the most careful.  Once the drop point is established in both
folders, then payments are extremely easy and secure.
So now let's say that Bob gets a Skype chat from Alice saying "Hey Bob,
let's use this as our drop point:  0f6f31b8eeeb795a7885ac670a344de1".
Bob replies "OK Alice, hold on just a sec!"
Bob logs into his folder, clicks Locations, clicks to add a new
location, and pastes that big number into the box labeled "Location".
He types in a nickname for this location, which in this case will be
"Alice".  He presses Save.
Now, when Bob wants to give something to Alice, he can easily select
"Alice" from the drop-down menu in his folder.
Note that the SAME drop point 0f6f31b8eeeb795a7885ac670a344de1 is now
installed in both Alice's and Bob's folder.  But also note that Alice
has nicknamed that location as "Bob," while Bob has nicknamed that same
location as "Alice."  It makes complete sense when viewed from the
perspective of Alice's and Bob's folders.
At that point, everything is configured and Alice and Bob now have a
shared drop point.  They have established an "economic relationship" if
you will.
And now payments between Alice and Bob are amazingly easy and fast.
When I showed this to my wife, she could not believe how easy it was.
I just tested making a payment last night, and it took me TEN SECONDS
FLAT, *including* logging into my folder to begin with.
So let's say Alice wants to pay Bob 5.6 grams of loom gold.  Here's the
process.  Click the stopwatch.
1. Alice visits loom.cc, enters her folder passphrase, and
   presses Login.
2. She types the number 5.6 into the quantity field.
   (Note that when she logs in, her cursor is already sitting
   there conveniently in the Qty field, so she doesn't even
   have to bother clicking into it.)
3. She selects "grams loom gold" from the drop-down menu
   labeled "choose asset."
4. She selects "Bob" from the drop-down menu labeled
   "choose location."
5. She presses the button labeled "Give".
I don't know about Alice, but I can do that in about 10 seconds, if I
don't mistype my passphrase.
But now here's where things get even easier.  Let's say Alice wants to
make another payment, this time paying 3.25 grams to Carol.  Here's the
1. Type 3.25 in the Qty field.
2. Click "Carol" in the drop-down location menu.
3. Press Give.
Note that this time, Alice didn't even have to select the asset type,
since she had already selected "grams loom gold" before.
But wait!, you may ask.  That's too easy, and Alice might make a
mistake.  Let's say Alice entered 32.5 instead of 3.25.  No problem.
When Alice notices the mistake, she can just quickly press the Take
button to take the assets right back.  Then she can fix the number and
press Give.
(Now if Bob somehow managed to be in his folder RIGHT AFTER Alice made
her mistake, and he saw the 32.5 grams sitting there, and he did a Take
to grab all those 32.5 grams before Alice had a chance to take them back
herself, then there's a problem.  But that's unlikely.  And if it
happens, then Alice should (1) chide herself for being so careless and
(2) tell Bob to give the money back.)
That's it.  Payments done in seconds flat, and no fumbling around for
drop points stored in a notepad file or written on slips of paper, and
no account numbers (just handy nicknames for drop points, completely at
your discretion).
Now at some point I'll put all that background information up on the
Loom site under the Help link, for those who actually bother to click
Help links and read what's there.  Personally, I generally loathe Help
screens, but I really do have some helpful information there.
Mind you, I have been BUSY ENOUGH just writing and testing this code, so
please bear with me as I improve the help and educational process here.
Realistically, the background information I just gave you will best
circulate by word of mouth.  This is basic conceptual background here.
It's like knowing what the steering wheel and accelerator are for in an
automobile.  Nobody ever reads that stuff in a manual:  they learn it
from their father.
It's probably somewhat akin to creating a MySpace page.  If I signed up
at MySpace, I'd probably fumble around for quite a while before I became
adept at editing and placing content.  Meanwhile, long-time MySpace
users have established a deep tradition and understanding of the site,
and are even using advanced editing tools.
The Loom model is a *conceptual* shift away from ordinary payment
systems -- it is a totally different paradigm of how ownership of
arbitrary "units" may be transferred.
Now if you think the Location (drop point) feature is mind-bending, just
wait till you realize that even ASSET TYPES themselves can be added to
folders.  Right now when you create a new folder, the system
automatically adds a few known asset types for you.  If I hadn't done
that, people would be ESPECIALLY baffled about Loom right now, arriving
at my door with torches and pitchforks.
That's right folks, the basic Loom system itself KNOWS NOTHING about
specific asset types or what they mean.  With the exception of the
predefined asset types automatically added to newly created folders, you
must "introduce" a new asset type into your folder.
For example, let's say your friend Joe creates a new asset type which
you and your friends will use to settle up lunch money debts.  He'll
choose some random asset identifier such as
857ca0317f031689f6782c8b2c09bbda, add it to his folder under a nickname
such as "Sandwich Credits," and become the issuer of that type.
Now, before Joe can pay Bob any of these new "Sandwich Credits," Bob
will have to be informed about this new asset type.  Joe tells Bob all
about it, and how they'll use it to settle up lunch debts.
Bob says OK sounds good.  Bob logs into his folder, clicks the "Types"
link (which I'm working on now), clicks to add a new type, pastes in the
new asset type 857ca0317f031689f6782c8b2c09bbda, and nicknames it
"Sandwich Credits".  Bob could actually choose a different nickname if
he preferred, perhaps "Sandwich from Joe!".  (Maybe other people Bob
knows have issued sandwich credits as well and Bob wants to keep them
all straight in his mind.)
Now when Joe slides some Sandwich Credits over to Bob's drop point, Bob
will see them and he can then Take them up into his personal stash.
This example underscores the fact that the Loom code itself is *totally
generic*, and knows ABSOLUTELY NOTHING about specific asset types except
for usage tokens.
Consequently, the biggest hurdle users have to overcome is
CONFIGURATION, e.g. adding nicknamed locations and asset types to their
folders.  Once that is done, the payment process is unbelievably easy.
And even the configuration is not so bad, once you understand the basic
concept of payment through shared drop points.

@_date: 2007-06-22 15:18:59
@_author: Patrick Chkoreff 
@_subject: [gsc] Loom folder interface now supports arbitrary asset types 
The Loom folder interface now supports arbitrary asset types.  Just
click the "Types" link in your folder to add, edit, and delete asset
types at will.
Issue digital doughnuts if you like.  I did this as a fun exercise.
This is by far the most important milestone in Loom to date.  It makes
Loom a powerful and completely generic accounting utility.
