
@_date: 1993-11-29 20:37:17
@_author: Matthew J Ghio 
@_subject: really hiding encrypted data 
Not a stupid question at all.  I would suspect that altho the least
significant bits of a picture file are not very orderly, they are
probably not quite a random distribution.  I would suspect that in many
pictures, they would form curved contour lines, outlining subtle
differences in color across a picture image.  Of course, some pictures
are more random than others, so the best someone scanning data packets
could do would be to pick out "suspicious" images to analyze further.
Well, since you mentioned the f-word, I guess I'll entertain the
possibility.  A fractal would probably be one way to hide data while
producing an orderly looking picture.  Suppose you wrote a program to
calculate the Mandelbrot set (fairly common example that most people
should be familiar with; if not, ask and I will clarify the math) to 256
iterations, and plot the number of iterations required for the magnitude
of the complex number pair to exceed 2.0 as the intensity of the pixel
(or zero for points in the set).  The result is a image that many people
have seen before.  Now, suppose that you modify your fractal generator
program slightly.  For points which required more than 32 iterations,
you would not plot the exact value, but instead change it +/- 1. Because the points which require a high number of iterations are in the
naturally most chaotic part of the fractal, it would probably defeat
"scanning" attempts to look for steg-data.  In fact, the only way to
discover the message would be to actually plot the fractal and compare
it to the file you had - a time consuming process, especially if the
cracker didn't know the exact coordinate boundries of the image, and the
number of significant figures used in your calculations.  Or maybe
instead of accepting divergance at 2.0, you choose 2.1, or even 2.01? Lots of possibilities...
If defeating a gummint traffic sniffer is your objective, consider what
kind of sniffer the gummint might use.  If they were just checking for
randomness, they might apply a data compression technique to look for
patterns (since cryptodata can't be compressed).  In such a case, you
could design a compression program which would "uncompress" data - that
is, run a data compression in reverse; adding random repitition that a
data compression program would notice.  Basically, what you need to do
is to design a data (un)compression system such that every possible
input file maps exactly to some "uncompressed" text.  You then steg the
uncompressed data, and then the recipient "compresses" the data to
reveal the original ciphertext, and then decrypts.
