
@_date: 1996-01-30 05:50:15
@_author: Thomas Roessler 
@_subject: [FACTS] Germany, or "Oh no not again" 
I had the prosecutor's spokesman on phone today.  The result is
that someone gave a hint to the prosecutors which explicitly
mentioned Zundel, T-Online and Compuserve.  Consequently, the
prosecutors *had* to start investigations against Zundel,
T-Online and Compuserve.  In particular, they are right now
*checking* whether providing internet access is a criminal
offence due to the possibility to gain access to `inciting
material' (the German word is `Volksverhetzung') via the Net.
This means that it is not even clear whether the investigations
against internet providers will be dropped or not; in fact many
people believe that these investigatinos *will* be dropped.
My personal guess about all this is that some net.citizens are
trying to have the prosecutors engaged in absolutely absurd
investigations (or, even better, achieve a court room clash on
this subject) to get some clarification of the legal situation of
the Net in Germany.  Quite similar to the RSA T-Shirt story in
the States. ,-)

@_date: 1997-02-13 10:16:34
@_author: Thomas Roessler 
@_subject: distributed mailing list architecture 
Maybe you have some use for the appended perl script.  I created it for a
list setup quite similar to what is currently being discussed on
cypherpunks.  It has never ever been used in production; you'll notice
yourself that the code is not too nice.
The script currently tries to handle majordomo and SmartList exploders; at
least SmartList needs to be hacked a little bit to avoid daily subscription
approvals to people being moved between different sub-lists.
Distribute and use this script freely; credit is appreciated.
# $Id: distlist.pl,v 1.2 1997/01/24 17:20:38 roessler Exp $
# Handle distributed mailing lists.
require 'getopts.pl';
$c_sublists='lists';		# Data about the sublists
$c_distfile='dist';		# A list of mail addresses
$c_datafile='dist.data';	# _Our_ list of addresses
$c_contact='roessler at sobolev.rhein.de';
$sendmail="| /usr/sbin/sendmail -t -odq";
$debug=0;			# Debugging output.  Can also be
$signature="-- \nThis mail has been generated automatically by the distlist\n".
    "program. Please contact $c_contact in case of problems.\n";
# Command line processing
&dprint (1, 'Processing the command line...\n');
$c_sublists=$opt_s if $opt_s;
$c_distfile=$opt_d if $opt_d;
$c_datafile=$opt_D if $opt_D;
$c_contact=$opt_c  if $opt_c;
$debug=$opt_x	   if $opt_x;
# Read the data and config files, perform various checks.
# sublists
&dprint(1, "Reading $c_sublists...");
# format: addr:maxsubscr:listtype:password:adminrequest:maintainer
open(SUBLISTS, $c_sublists) || die("Can't open $c_sublists");
SUBLIST: while() {
    next SUBLIST if /^ || /^$/;
    chop;
    ($addr, $maxsubscr, $listtype, $password, $admin, $maintainer) = split(/:/, $_);
    $s_maxsubscr{$addr}=$maxsubscr;
    $s_listtype{$addr}=$listtype;
    $s_password{$addr}=$password;
    $s_admin{$addr}=$admin;
    $s_maintainer{$addr}=$maintainer;
    $s_onlist{$addr}=0;
    $s_addem{$addr}="";
    $s_delem{$addr}="";
    &dprint(3,"Parsed list $addr: maximum $maxsubscr people; listtype $listtype; password $password.; administrative address $admin; maintainer $maintainer");
     $addr);
# In addition, we define a special list for people to be redistributed later.
$s_maxsubscr{'later'}=100000;		# Very big. ;)
# Read our dist file
# format: user:list
if(open(DATAFILE, $c_datafile)) {
    &dprint(1, "Reading $c_datafile...");
  USERLINE: while() {
      next USERLINE if /^ || /^$/;
      chop;
      ($user, $list) = split(/:/, $_);
      # Check if the list exists; handle user.
      if(! $s_maxsubscr{$list}) {
      } elsif( $s_onlist{$list} >= $s_maxsubscr{$list} ) {
      }       $s_onlist{$list}++;
      $u_list{$user}=$list;
      $deletem{$user}=$user;
  }
    close(DATAFILE);
    &dprint(1,"$c_datafile finished.");
} else {
    &dprint(1, "Warning:  Can't read $c_datafile.");
# Now, read the real distribution file.
&dprint(1, "Reading $c_distfile...");
open(DISTFILE, $c_distfile) || die("Can't open $c_distfile");
 DISTLINE: while() {
     next DISTLINE if /^ || /^$/ || /^\(/;
     chop;
     if(!$u_list{$_}) {			# A new member.
     } else {				# We know him.
     }
 }
# Handle deletions.
foreach $user (keys %deletem) {
    $list=$u_list{$user};
    delete $u_list{$user};
    $s_onlist{$list}--;
    $s_delem{$list}=join(':', $s_delem{$list}, $user);
    &dprint(3, "Removing $user from sublist $list.");
# Handle postponed subscriptions:  The later list.
foreach (keys %u_list) {
    next unless $u_list{$_} eq "later";
         delete $u_list{$_};
    &dprint(3, "Adding $_ to the list of new subscriptions.  Was postponed.");
&dprint(1, "Distributing new subscriptions...");
 NEWSUBS: foreach $user ( {
     $avg=0.0;
     foreach $l ( {
     }
     $avg = $avg / ($ + 1.0);
     if ($avg >= 1) {
     }
     undef $possible;
     foreach $l ( {
     }
     if($possible) {
     }
     $s_addem{$l}=join(':', $s_addem{$l}, $user);
     $s_onlist{$l}++;
     $u_list{$user}=$l;
 }
# Write our own data file.
if(open(DATAFILE, ">$c_datafile")) {
    foreach (keys %u_list) {
    }
    close(DATAFILE);
} else {
    &dprint(1, "Warning: Can't write $c_datafile.");
# The lists have been put together.  Commit the changes.
&dprint(1, "Committing the changes...");
foreach $l ( {
    if($s_listtype{$l} eq "majordomo") {
    } elsif ($s_listtype{$l} eq "smartlist") {
    } else {
    }
# To be done:  Print out some statistics.
print "Distlist results:\n";
print "-----------------\n";
print "\n";
printf "There are currently %d subscribers on %d sublists.\n\n", scalar(keys %u_list), $
printf "%-40s     on  max\n", "Name";
printf "----------------------------------------------------\n";
foreach $l ( {
    printf "%-40s   %4d %4d", $l, $s_onlist{$l}, $s_maxsubscr{$l};
    if($s_onlist{$l} >= $s_maxsubscr{$l}) {
    }
    print "\n";
if($full_lists) {
    print "\n$full_lists of the sublists are *full*.  Please get in touch\n";
    print "with the maintainers.\n";
print "\n\n";
print $signature;
# Some helper functions.
# Print out diagnostics.
sub dprint
    if($_[0] <= $debug) {
    }
sub commit_majordomo
    my $list=$_[0];
    my     my $ll;
    my $user;
    &dprint(2, "Committing changes to majordomo list $list");
    &dprint(3, "to be added: $s_addem{$list}");
    &dprint(3, "to be deleted: $s_delem{$list}");
    ($ll,  $list);
    if(!open(SENDMAIL, $sendmail)) {
    }
    print SENDMAIL "To: $s_admin{$list}\n";
    print SENDMAIL "From: $c_contact\n";
    print SENDMAIL "\n\n";
    foreach $user ( $s_addem{$list})) {
    }
    foreach $user ( $s_delem{$list})) {
    }
    print SENDMAIL $signature;
    close(SENDMAIL);
sub smartlist_xcommand
    my ($list, $to, $passwd, $command, $maintainer) =     if(!open(SENDMAIL, $sendmail)) {
    }
    print SENDMAIL "To: $to\n";
    print SENDMAIL "From: $c_contact\n";
    print SENDMAIL "X-Command: $maintainer $passwd $command\n";
    print SENDMAIL "\n\n";
    print SENDMAIL $signature;
    close SENDMAIL;
}	
sub commit_smartlist
    my $list=$_[0];
    my     my $user;
    &dprint(2, "Committing changes to smartlist list $list");
    foreach $user ( $s_addem{$list})) {
    }
    foreach $user ( $s_delem{$list})) {
    }

@_date: 1997-02-13 11:58:56
@_author: Thomas Roessler 
@_subject: distributed mailing list architecture 
Maybe you have some use for the appended perl script.  I created it for a
list setup quite similar to what is currently being discussed on
cypherpunks.  It has never ever been used in production; you'll notice
yourself that the code is not too nice.
The script currently tries to handle majordomo and SmartList exploders; at
least SmartList needs to be hacked a little bit to avoid daily subscription
approvals to people being moved between different sub-lists.
Distribute and use this script freely; credit is appreciated.
# $Id: distlist.pl,v 1.2 1997/01/24 17:20:38 roessler Exp $
# Handle distributed mailing lists.
require 'getopts.pl';
$c_sublists='lists';		# Data about the sublists
$c_distfile='dist';		# A list of mail addresses
$c_datafile='dist.data';	# _Our_ list of addresses
$c_contact='roessler at sobolev.rhein.de';
$sendmail="| /usr/sbin/sendmail -t -odq";
$debug=0;			# Debugging output.  Can also be
$signature="-- \nThis mail has been generated automatically by the distlist\n".
    "program. Please contact $c_contact in case of problems.\n";
# Command line processing
&dprint (1, 'Processing the command line...\n');
$c_sublists=$opt_s if $opt_s;
$c_distfile=$opt_d if $opt_d;
$c_datafile=$opt_D if $opt_D;
$c_contact=$opt_c  if $opt_c;
$debug=$opt_x	   if $opt_x;
# Read the data and config files, perform various checks.
# sublists
&dprint(1, "Reading $c_sublists...");
# format: addr:maxsubscr:listtype:password:adminrequest:maintainer
open(SUBLISTS, $c_sublists) || die("Can't open $c_sublists");
SUBLIST: while() {
    next SUBLIST if /^ || /^$/;
    chop;
    ($addr, $maxsubscr, $listtype, $password, $admin, $maintainer) = split(/:/, $_);
    $s_maxsubscr{$addr}=$maxsubscr;
    $s_listtype{$addr}=$listtype;
    $s_password{$addr}=$password;
    $s_admin{$addr}=$admin;
    $s_maintainer{$addr}=$maintainer;
    $s_onlist{$addr}=0;
    $s_addem{$addr}="";
    $s_delem{$addr}="";
    &dprint(3,"Parsed list $addr: maximum $maxsubscr people; listtype $listtype; password $password.; administrative address $admin; maintainer $maintainer");
     $addr);
# In addition, we define a special list for people to be redistributed later.
$s_maxsubscr{'later'}=100000;		# Very big. ;)
# Read our dist file
# format: user:list
if(open(DATAFILE, $c_datafile)) {
    &dprint(1, "Reading $c_datafile...");
  USERLINE: while() {
      next USERLINE if /^ || /^$/;
      chop;
      ($user, $list) = split(/:/, $_);
      # Check if the list exists; handle user.
      if(! $s_maxsubscr{$list}) {
      } elsif( $s_onlist{$list} >= $s_maxsubscr{$list} ) {
      }       $s_onlist{$list}++;
      $u_list{$user}=$list;
      $deletem{$user}=$user;
  }
    close(DATAFILE);
    &dprint(1,"$c_datafile finished.");
} else {
    &dprint(1, "Warning:  Can't read $c_datafile.");
# Now, read the real distribution file.
&dprint(1, "Reading $c_distfile...");
open(DISTFILE, $c_distfile) || die("Can't open $c_distfile");
 DISTLINE: while() {
     next DISTLINE if /^ || /^$/ || /^\(/;
     chop;
     if(!$u_list{$_}) {			# A new member.
     } else {				# We know him.
     }
 }
# Handle deletions.
foreach $user (keys %deletem) {
    $list=$u_list{$user};
    delete $u_list{$user};
    $s_onlist{$list}--;
    $s_delem{$list}=join(':', $s_delem{$list}, $user);
    &dprint(3, "Removing $user from sublist $list.");
# Handle postponed subscriptions:  The later list.
foreach (keys %u_list) {
    next unless $u_list{$_} eq "later";
         delete $u_list{$_};
    &dprint(3, "Adding $_ to the list of new subscriptions.  Was postponed.");
&dprint(1, "Distributing new subscriptions...");
 NEWSUBS: foreach $user ( {
     $avg=0.0;
     foreach $l ( {
     }
     $avg = $avg / ($ + 1.0);
     if ($avg >= 1) {
     }
     undef $possible;
     foreach $l ( {
     }
     if($possible) {
     }
     $s_addem{$l}=join(':', $s_addem{$l}, $user);
     $s_onlist{$l}++;
     $u_list{$user}=$l;
 }
# Write our own data file.
if(open(DATAFILE, ">$c_datafile")) {
    foreach (keys %u_list) {
    }
    close(DATAFILE);
} else {
    &dprint(1, "Warning: Can't write $c_datafile.");
# The lists have been put together.  Commit the changes.
&dprint(1, "Committing the changes...");
foreach $l ( {
    if($s_listtype{$l} eq "majordomo") {
    } elsif ($s_listtype{$l} eq "smartlist") {
    } else {
    }
# To be done:  Print out some statistics.
print "Distlist results:\n";
print "-----------------\n";
print "\n";
printf "There are currently %d subscribers on %d sublists.\n\n", scalar(keys %u_list), $
printf "%-40s     on  max\n", "Name";
printf "----------------------------------------------------\n";
foreach $l ( {
    printf "%-40s   %4d %4d", $l, $s_onlist{$l}, $s_maxsubscr{$l};
    if($s_onlist{$l} >= $s_maxsubscr{$l}) {
    }
    print "\n";
if($full_lists) {
    print "\n$full_lists of the sublists are *full*.  Please get in touch\n";
    print "with the maintainers.\n";
print "\n\n";
print $signature;
# Some helper functions.
# Print out diagnostics.
sub dprint
    if($_[0] <= $debug) {
    }
sub commit_majordomo
    my $list=$_[0];
    my     my $ll;
    my $user;
    &dprint(2, "Committing changes to majordomo list $list");
    &dprint(3, "to be added: $s_addem{$list}");
    &dprint(3, "to be deleted: $s_delem{$list}");
    ($ll,  $list);
    if(!open(SENDMAIL, $sendmail)) {
    }
    print SENDMAIL "To: $s_admin{$list}\n";
    print SENDMAIL "From: $c_contact\n";
    print SENDMAIL "\n\n";
    foreach $user ( $s_addem{$list})) {
    }
    foreach $user ( $s_delem{$list})) {
    }
    print SENDMAIL $signature;
    close(SENDMAIL);
sub smartlist_xcommand
    my ($list, $to, $passwd, $command, $maintainer) =     if(!open(SENDMAIL, $sendmail)) {
    }
    print SENDMAIL "To: $to\n";
    print SENDMAIL "From: $c_contact\n";
    print SENDMAIL "X-Command: $maintainer $passwd $command\n";
    print SENDMAIL "\n\n";
    print SENDMAIL $signature;
    close SENDMAIL;
}	
sub commit_smartlist
    my $list=$_[0];
    my     my $user;
    &dprint(2, "Committing changes to smartlist list $list");
    foreach $user ( $s_addem{$list})) {
    }
    foreach $user ( $s_delem{$list})) {
    }
