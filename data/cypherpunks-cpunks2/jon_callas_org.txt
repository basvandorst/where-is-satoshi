
@_date: 2013-10-17 14:39:01
@_author: Jon Callas 
@_subject: Curious RNG stalemate [was: use of cpunks] 
Be aware in all of this of the Heisenberg-Schödinger Credulity Effect. That effect is that the word "quantum" sucks people's brains out, and otherwise sensible people suffer from impaired reasoning.
It is certainly true that radioactivity is a random effect, and is quantum in nature. That does not mean that in order for a random sampling to be quantum, it must be based on radioactivity; there are other quantum sources of randomness. Noisy diodes, resister noise, CCD noise, etc. are all quantum. If you want to get picky, *all* physical effects are quantum, even ones that aren't usefully random. There is nothing magic about one physical source or other that makes it more suited for crypto. Thinking that a hardware source should be radioactive is affirming the consequence, as well.
Not does it mean that a radioactive (or other) source is suitable for cryptography without some sort of conditioning. Hardware sources are often biased in distribution, or have other numeric flaws that can be fixed with a whitening function.
In short, radioactivity is neither necessary nor sufficient for cryptographic use. If you want to use a source for crypto, you want to run it through a system like /dev/random or at the very least a DRBG to give clean outputs.
Furthermore, what we really want in crypto is what I call "unguessability." This is both weaker than true randomness and stronger. It's stronger in that the numbers have to remain secret. A completely random process that everyone knows is completely unsuitable for crypto, but a weakly entropic input can be jiggered into suitability.
To sum up -- don't get wrapped around the axle about radioactivity. It's not the only random process in the universe, and you have to do a lot of work once you have it. The sort of work that you need to do is precisely what a well-done OSRNG does.

@_date: 2013-10-18 10:11:15
@_author: Jon Callas 
@_subject: Curious RNG stalemate [was: use of cpunks] 
Because people think that over-the-top is necessary.
Perhaps more to the point, people start gilding the lily, and then worrying about how pure the gold is on the lily, and then deciding that the gilt on the lily needs to be mono-atomic and to form a single crystal.
Even more to the point, they start thinking in their heads that they will be criticized for not having a single-crystal structure on the gilt on their lily, and give up. After that, they criticize other people who grow lilies because -- heck, anyone can do that, and years ago, they gave up on lilies because of how hard it is to get mono-crystalline gilt. Go look it up in the cypherpunks archives, for pete's sake. Nicholas Bourbaki discussed it to death there back in '92.
Building a good RNG is both simpler than you think and harder. You need:
* An unguessability source. It doesn't have to be as good as you think it does. If it's crap, you just need more. It just has to be unguessable. The deterministic process going on on my LAN might be good enough. It might not. What matters is the work factor of guessing.
Here's an example of a source I have seen that is plenty good enough, but not what most people think:
- Take an array of unsigned ints; 16 or 32 in length is fine.
- On every interrupt, read the "cpu clock." Lots of CPUs have something good enough. Tick counters, high-speed uptime, etc. It almost doesn't matter.
- XOR that into the current array element. - Rotate that element by an odd number of bits. Mathematically, all that's required is that you pick an odd number that's relatively prime with the word size so you get maximum mixing over time intra-element. Most people can pick a suitable odd number.
- Increment/wrap your element pointer.
Poof, you're done. Incidentally, this is *also* a quantum process, it's just quantized fatter than other quantum processes. That's why you want to do it on every interrupt. When I first saw this, my jaw dropped at its elegance.
* A pool and distiller. Hash functions are great here, as are other things. The thing to remember is only that you might get a megabyte of input that has only a single bit of unguessability in it, and you need to cope. That's why hash functions are great. Entropy estimation is highly desirable, but not necessary. This is a long discussion. It's possible to build one with no estimator that works well, and one with an estimator that works poorly.
* An output function. Ciphers and hash functions are your friends. The SP 800-90 DRBGs are all designed by committee, but work (with the obvious exception). Far more important is to have your output function stir back into the pool. Something as simple as feeding back the length of the request is fine. Even better is to feed in something like a cpu tick counter. If you do something mildly reasonable here in stir-back, then you can completely forget about entropy depletion. This is another long discussion, and that's why I'm simply asserting it. There are gentlepersons who disagree with me. That's it. Yeah, the devil's in the details, and my sketch is kinda like saying oh, all you have to do to land on the moon is get some rockets and life support. But this is a lot easier than landing on the moon, despite many people thinking it's harder.
And yes, yes, there are other other considerations like rebooting, suspend, hibernate, restoring VMs, and of course initial boot.

@_date: 2013-10-17 14:39:01
@_author: Jon Callas 
@_subject: Curious RNG stalemate [was: use of cpunks] 
Be aware in all of this of the Heisenberg-Schödinger Credulity Effect. That effect is that the word "quantum" sucks people's brains out, and otherwise sensible people suffer from impaired reasoning.
It is certainly true that radioactivity is a random effect, and is quantum in nature. That does not mean that in order for a random sampling to be quantum, it must be based on radioactivity; there are other quantum sources of randomness. Noisy diodes, resister noise, CCD noise, etc. are all quantum. If you want to get picky, *all* physical effects are quantum, even ones that aren't usefully random. There is nothing magic about one physical source or other that makes it more suited for crypto. Thinking that a hardware source should be radioactive is affirming the consequence, as well.
Not does it mean that a radioactive (or other) source is suitable for cryptography without some sort of conditioning. Hardware sources are often biased in distribution, or have other numeric flaws that can be fixed with a whitening function.
In short, radioactivity is neither necessary nor sufficient for cryptographic use. If you want to use a source for crypto, you want to run it through a system like /dev/random or at the very least a DRBG to give clean outputs.
Furthermore, what we really want in crypto is what I call "unguessability." This is both weaker than true randomness and stronger. It's stronger in that the numbers have to remain secret. A completely random process that everyone knows is completely unsuitable for crypto, but a weakly entropic input can be jiggered into suitability.
To sum up -- don't get wrapped around the axle about radioactivity. It's not the only random process in the universe, and you have to do a lot of work once you have it. The sort of work that you need to do is precisely what a well-done OSRNG does.

@_date: 2013-10-18 10:11:15
@_author: Jon Callas 
@_subject: Curious RNG stalemate [was: use of cpunks] 
Because people think that over-the-top is necessary.
Perhaps more to the point, people start gilding the lily, and then worrying about how pure the gold is on the lily, and then deciding that the gilt on the lily needs to be mono-atomic and to form a single crystal.
Even more to the point, they start thinking in their heads that they will be criticized for not having a single-crystal structure on the gilt on their lily, and give up. After that, they criticize other people who grow lilies because -- heck, anyone can do that, and years ago, they gave up on lilies because of how hard it is to get mono-crystalline gilt. Go look it up in the cypherpunks archives, for pete's sake. Nicholas Bourbaki discussed it to death there back in '92.
Building a good RNG is both simpler than you think and harder. You need:
* An unguessability source. It doesn't have to be as good as you think it does. If it's crap, you just need more. It just has to be unguessable. The deterministic process going on on my LAN might be good enough. It might not. What matters is the work factor of guessing.
Here's an example of a source I have seen that is plenty good enough, but not what most people think:
- Take an array of unsigned ints; 16 or 32 in length is fine.
- On every interrupt, read the "cpu clock." Lots of CPUs have something good enough. Tick counters, high-speed uptime, etc. It almost doesn't matter.
- XOR that into the current array element. - Rotate that element by an odd number of bits. Mathematically, all that's required is that you pick an odd number that's relatively prime with the word size so you get maximum mixing over time intra-element. Most people can pick a suitable odd number.
- Increment/wrap your element pointer.
Poof, you're done. Incidentally, this is *also* a quantum process, it's just quantized fatter than other quantum processes. That's why you want to do it on every interrupt. When I first saw this, my jaw dropped at its elegance.
* A pool and distiller. Hash functions are great here, as are other things. The thing to remember is only that you might get a megabyte of input that has only a single bit of unguessability in it, and you need to cope. That's why hash functions are great. Entropy estimation is highly desirable, but not necessary. This is a long discussion. It's possible to build one with no estimator that works well, and one with an estimator that works poorly.
* An output function. Ciphers and hash functions are your friends. The SP 800-90 DRBGs are all designed by committee, but work (with the obvious exception). Far more important is to have your output function stir back into the pool. Something as simple as feeding back the length of the request is fine. Even better is to feed in something like a cpu tick counter. If you do something mildly reasonable here in stir-back, then you can completely forget about entropy depletion. This is another long discussion, and that's why I'm simply asserting it. There are gentlepersons who disagree with me. That's it. Yeah, the devil's in the details, and my sketch is kinda like saying oh, all you have to do to land on the moon is get some rockets and life support. But this is a lot easier than landing on the moon, despite many people thinking it's harder.
And yes, yes, there are other other considerations like rebooting, suspend, hibernate, restoring VMs, and of course initial boot.

@_date: 2013-10-17 14:39:01
@_author: Jon Callas 
@_subject: Curious RNG stalemate [was: use of cpunks] 
Be aware in all of this of the Heisenberg-Schödinger Credulity Effect. That effect is that the word "quantum" sucks people's brains out, and otherwise sensible people suffer from impaired reasoning.
It is certainly true that radioactivity is a random effect, and is quantum in nature. That does not mean that in order for a random sampling to be quantum, it must be based on radioactivity; there are other quantum sources of randomness. Noisy diodes, resister noise, CCD noise, etc. are all quantum. If you want to get picky, *all* physical effects are quantum, even ones that aren't usefully random. There is nothing magic about one physical source or other that makes it more suited for crypto. Thinking that a hardware source should be radioactive is affirming the consequence, as well.
Not does it mean that a radioactive (or other) source is suitable for cryptography without some sort of conditioning. Hardware sources are often biased in distribution, or have other numeric flaws that can be fixed with a whitening function.
In short, radioactivity is neither necessary nor sufficient for cryptographic use. If you want to use a source for crypto, you want to run it through a system like /dev/random or at the very least a DRBG to give clean outputs.
Furthermore, what we really want in crypto is what I call "unguessability." This is both weaker than true randomness and stronger. It's stronger in that the numbers have to remain secret. A completely random process that everyone knows is completely unsuitable for crypto, but a weakly entropic input can be jiggered into suitability.
To sum up -- don't get wrapped around the axle about radioactivity. It's not the only random process in the universe, and you have to do a lot of work once you have it. The sort of work that you need to do is precisely what a well-done OSRNG does.

@_date: 2013-10-18 10:11:15
@_author: Jon Callas 
@_subject: Curious RNG stalemate [was: use of cpunks] 
Because people think that over-the-top is necessary.
Perhaps more to the point, people start gilding the lily, and then worrying about how pure the gold is on the lily, and then deciding that the gilt on the lily needs to be mono-atomic and to form a single crystal.
Even more to the point, they start thinking in their heads that they will be criticized for not having a single-crystal structure on the gilt on their lily, and give up. After that, they criticize other people who grow lilies because -- heck, anyone can do that, and years ago, they gave up on lilies because of how hard it is to get mono-crystalline gilt. Go look it up in the cypherpunks archives, for pete's sake. Nicholas Bourbaki discussed it to death there back in '92.
Building a good RNG is both simpler than you think and harder. You need:
* An unguessability source. It doesn't have to be as good as you think it does. If it's crap, you just need more. It just has to be unguessable. The deterministic process going on on my LAN might be good enough. It might not. What matters is the work factor of guessing.
Here's an example of a source I have seen that is plenty good enough, but not what most people think:
- Take an array of unsigned ints; 16 or 32 in length is fine.
- On every interrupt, read the "cpu clock." Lots of CPUs have something good enough. Tick counters, high-speed uptime, etc. It almost doesn't matter.
- XOR that into the current array element. - Rotate that element by an odd number of bits. Mathematically, all that's required is that you pick an odd number that's relatively prime with the word size so you get maximum mixing over time intra-element. Most people can pick a suitable odd number.
- Increment/wrap your element pointer.
Poof, you're done. Incidentally, this is *also* a quantum process, it's just quantized fatter than other quantum processes. That's why you want to do it on every interrupt. When I first saw this, my jaw dropped at its elegance.
* A pool and distiller. Hash functions are great here, as are other things. The thing to remember is only that you might get a megabyte of input that has only a single bit of unguessability in it, and you need to cope. That's why hash functions are great. Entropy estimation is highly desirable, but not necessary. This is a long discussion. It's possible to build one with no estimator that works well, and one with an estimator that works poorly.
* An output function. Ciphers and hash functions are your friends. The SP 800-90 DRBGs are all designed by committee, but work (with the obvious exception). Far more important is to have your output function stir back into the pool. Something as simple as feeding back the length of the request is fine. Even better is to feed in something like a cpu tick counter. If you do something mildly reasonable here in stir-back, then you can completely forget about entropy depletion. This is another long discussion, and that's why I'm simply asserting it. There are gentlepersons who disagree with me. That's it. Yeah, the devil's in the details, and my sketch is kinda like saying oh, all you have to do to land on the moon is get some rockets and life support. But this is a lot easier than landing on the moon, despite many people thinking it's harder.
And yes, yes, there are other other considerations like rebooting, suspend, hibernate, restoring VMs, and of course initial boot.

@_date: 2013-09-11 08:17:28
@_author: Jon Callas 
@_subject: hardware RNG 
Yes. If you took noise off of a diode or even a resister and just threw it into Yarrow, you'd have a very nice thing.
The biggest problem with building good random number generators is that it's harder than you think on first glance and easier than you think on third glance.

@_date: 2013-09-11 08:19:02
@_author: Jon Callas 
@_subject: [guardian-dev] pgp, nsa, rsa 
LTC is my preferred place to start with a crypto library. It's just brilliant in design.

@_date: 2013-09-11 08:17:28
@_author: Jon Callas 
@_subject: hardware RNG 
Yes. If you took noise off of a diode or even a resister and just threw it into Yarrow, you'd have a very nice thing.
The biggest problem with building good random number generators is that it's harder than you think on first glance and easier than you think on third glance.

@_date: 2013-09-11 08:19:02
@_author: Jon Callas 
@_subject: [guardian-dev] pgp, nsa, rsa 
LTC is my preferred place to start with a crypto library. It's just brilliant in design.

@_date: 2013-09-11 08:17:28
@_author: Jon Callas 
@_subject: hardware RNG 
Yes. If you took noise off of a diode or even a resister and just threw it into Yarrow, you'd have a very nice thing.
The biggest problem with building good random number generators is that it's harder than you think on first glance and easier than you think on third glance.

@_date: 2013-09-11 08:19:02
@_author: Jon Callas 
@_subject: [guardian-dev] pgp, nsa, rsa 
LTC is my preferred place to start with a crypto library. It's just brilliant in design.

@_date: 2014-01-31 13:13:10
@_author: Jon Callas 
@_subject: [Cryptography] The crypto behind the blackphone 
We *are* using some of the Guardian Project's software. Also software that we're building for Blackphone will be available for other people to use on their own ROMs. And heck, you can go to Github, get the Silent Circle apps and put them on your own device. We're finally to the point that we've QA'ed people who aren't us building them and using them. (And if you can't, it's a bug.)
Let me answer your question with a question.
What's the difference between going to a restaurant as opposed to going to the grocery store and buying a bunch of ingredients and making the same meal? There are groups devoted to making food the way the Child or Keller might. You can't have a meal by Child because she's gone, but you could make a Keller meal as well as Keller's people can. Why go to the restaurant?
Now to comment on that line of both our questions, we all have a set time in this existence and some people might like to write their own compilers so they can write their own software, just as some people grow their own food so they can make their own meals. But some people don't want to do that, and every single one of us trades off the things we want to do against things we're happy to pay other people to do. No offense taken. I may be a smartass, but I like tough questions. If/when they do, I'd love to see it. I don't have time to make an open, secure baseband, but want to include one. The world needs one. Maybe we can arrange some sort of trade.

@_date: 2014-01-31 13:13:10
@_author: Jon Callas 
@_subject: [Cryptography] The crypto behind the blackphone 
We *are* using some of the Guardian Project's software. Also software that we're building for Blackphone will be available for other people to use on their own ROMs. And heck, you can go to Github, get the Silent Circle apps and put them on your own device. We're finally to the point that we've QA'ed people who aren't us building them and using them. (And if you can't, it's a bug.)
Let me answer your question with a question.
What's the difference between going to a restaurant as opposed to going to the grocery store and buying a bunch of ingredients and making the same meal? There are groups devoted to making food the way the Child or Keller might. You can't have a meal by Child because she's gone, but you could make a Keller meal as well as Keller's people can. Why go to the restaurant?
Now to comment on that line of both our questions, we all have a set time in this existence and some people might like to write their own compilers so they can write their own software, just as some people grow their own food so they can make their own meals. But some people don't want to do that, and every single one of us trades off the things we want to do against things we're happy to pay other people to do. No offense taken. I may be a smartass, but I like tough questions. If/when they do, I'd love to see it. I don't have time to make an open, secure baseband, but want to include one. The world needs one. Maybe we can arrange some sort of trade.

@_date: 2014-01-31 13:13:10
@_author: Jon Callas 
@_subject: [Cryptography] The crypto behind the blackphone 
============================== START ==============================
We *are* using some of the Guardian Project's software. Also software that we're building for Blackphone will be available for other people to use on their own ROMs. And heck, you can go to Github, get the Silent Circle apps and put them on your own device. We're finally to the point that we've QA'ed people who aren't us building them and using them. (And if you can't, it's a bug.)
Let me answer your question with a question.
What's the difference between going to a restaurant as opposed to going to the grocery store and buying a bunch of ingredients and making the same meal? There are groups devoted to making food the way the Child or Keller might. You can't have a meal by Child because she's gone, but you could make a Keller meal as well as Keller's people can. Why go to the restaurant?
Now to comment on that line of both our questions, we all have a set time in this existence and some people might like to write their own compilers so they can write their own software, just as some people grow their own food so they can make their own meals. But some people don't want to do that, and every single one of us trades off the things we want to do against things we're happy to pay other people to do. No offense taken. I may be a smartass, but I like tough questions. If/when they do, I'd love to see it. I don't have time to make an open, secure baseband, but want to include one. The world needs one. Maybe we can arrange some sort of trade.

@_date: 2014-11-12 14:07:36
@_author: Jon Callas 
@_subject: [Cryptography] "DarkHotel" APT routinely breaking RSA512 
One can factor RSA 512 with less than earthly resources. One friend of mine back in 2009 was factoring RSA 512 with a single tower machine in about two weeks. He upgraded the machine in 2011 and could do it in about ten days.

@_date: 2014-11-12 14:07:36
@_author: Jon Callas 
@_subject: [Cryptography] "DarkHotel" APT routinely breaking RSA512 
One can factor RSA 512 with less than earthly resources. One friend of mine back in 2009 was factoring RSA 512 with a single tower machine in about two weeks. He upgraded the machine in 2011 and could do it in about ten days.

@_date: 2014-11-12 14:07:36
@_author: Jon Callas 
@_subject: [Cryptography] "DarkHotel" APT routinely breaking RSA512 
One can factor RSA 512 with less than earthly resources. One friend of mine back in 2009 was factoring RSA 512 with a single tower machine in about two weeks. He upgraded the machine in 2011 and could do it in about ten days.

@_date: 2015-02-20 14:36:55
@_author: Jon Callas 
@_subject: [Cryptography] trojans in the firmware 
NAND memory runs faster when the hamming weight of the data is approximately even between zeroes and ones. You can speed up NAND flash by running the data through a suitable whitening function.
AES is a great whitening function. If you then go to the extra effort to do key management, you have security. It's a simple matter of architecture and programming. :)

@_date: 2015-02-20 14:36:55
@_author: Jon Callas 
@_subject: [Cryptography] trojans in the firmware 
NAND memory runs faster when the hamming weight of the data is approximately even between zeroes and ones. You can speed up NAND flash by running the data through a suitable whitening function.
AES is a great whitening function. If you then go to the extra effort to do key management, you have security. It's a simple matter of architecture and programming. :)

@_date: 2015-02-20 14:36:55
@_author: Jon Callas 
@_subject: [Cryptography] trojans in the firmware 
NAND memory runs faster when the hamming weight of the data is approximately even between zeroes and ones. You can speed up NAND flash by running the data through a suitable whitening function.
AES is a great whitening function. If you then go to the extra effort to do key management, you have security. It's a simple matter of architecture and programming. :)

@_date: 2015-05-27 22:01:13
@_author: Jon Callas 
@_subject: Apple At-Rest Encryption 
You should turn it on. The battery effect on the CPU is negligible; it’s using AES-NI in the processor and that’s running at less than one clock per byte. But if you’re on a computer that has flash – like any of the Air/Retina machines – the write time and power requirements of NAND flash are much better when you use a whitening function, of which AES makes a great one.
But in any event, it’s all going to be not worth worrying about in the costs. You might even benefit. You are also gaining in the security end. We can certainly debate whatever the operational security benefits are from encrypting your disk, but the real benefit comes from when you inevitably decommission that machine and storage. You are vastly, vastly better off with encrypted storage then, and better off for having encrypted it all along.

@_date: 2015-05-27 22:01:13
@_author: Jon Callas 
@_subject: Apple At-Rest Encryption 
You should turn it on. The battery effect on the CPU is negligible; it’s using AES-NI in the processor and that’s running at less than one clock per byte. But if you’re on a computer that has flash – like any of the Air/Retina machines – the write time and power requirements of NAND flash are much better when you use a whitening function, of which AES makes a great one.
But in any event, it’s all going to be not worth worrying about in the costs. You might even benefit. You are also gaining in the security end. We can certainly debate whatever the operational security benefits are from encrypting your disk, but the real benefit comes from when you inevitably decommission that machine and storage. You are vastly, vastly better off with encrypted storage then, and better off for having encrypted it all along.

@_date: 2015-05-27 22:01:13
@_author: Jon Callas 
@_subject: Apple At-Rest Encryption 
You should turn it on. The battery effect on the CPU is negligible; it’s using AES-NI in the processor and that’s running at less than one clock per byte. But if you’re on a computer that has flash – like any of the Air/Retina machines – the write time and power requirements of NAND flash are much better when you use a whitening function, of which AES makes a great one.
But in any event, it’s all going to be not worth worrying about in the costs. You might even benefit. You are also gaining in the security end. We can certainly debate whatever the operational security benefits are from encrypting your disk, but the real benefit comes from when you inevitably decommission that machine and storage. You are vastly, vastly better off with encrypted storage then, and better off for having encrypted it all along.
