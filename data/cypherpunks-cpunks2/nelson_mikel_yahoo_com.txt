
@_date: 2015-10-06 20:15:39
@_author: Michael Nelson 
@_subject: Introduce randommess in keypress timings 
Alternatively all keystrokes could be done with fixed timing.  The point is that no individual pattern should be discernable.  There are more subtle aspects, such as jitter from perfectly regular timing, which could identify the machine/browser being used.  With added randomness, such jitter would be harder to discern.  Also, you would ideally not want eavesdroppers to know that you are obfuscating your keystrokes, and obfuscating via randomness, as opposed to fixed timing, would help with that.
There are quite a few companies selling keystroke dynamics products as an authentication factor.  There are also various efforts, such as one started at Stanford a few years ago, to monitor all aspects of a person's input, for continuous background authentication.  Not sure how that one's going.  Keystroke dynamics normally works on a short chosen phrase.  The latter stuff is more ambitious and extends that to arbitrarily long text, along with grammatical patterns, etc.  There is nothing new here.
After evaluating several products for a company I worked for, I built a keystroke dynamics product myself -- it was less work than going through the pain of registering for a trial of their software!  It was never used, for the same reason that kd is not used much -- it's more trouble than it's worth. It worked as well as any of the products being sold.
Though a key down or key up event from the Windows operating system has a timestamp in it (the OS will not give you more than a certain accuracy, but it's adequate), that timestamp is discarded and not available in Javascript.  My Javascript solution calls for a new Date as soon as it captures a key event.  People selling this stuff say that as there is too much potential lag between the key event and the time thus associated, Javascript is not good.  The best thing is something like an ActiveX  plugin or a native client in C that can capture the timestamp from the OS.  The next best thing was touted as Flash.  However, mine worked very well.
If anyone is interested I will describe in simple terms how one tests the keystroke vectors, and some of the challenges.

@_date: 2015-10-07 16:48:49
@_author: Michael Nelson 
@_subject: Introduce randommess in keypress timings 
Well it does have an impact, but not enough to ruin things.  Of course it's not just js itself, but the browser, which swaps things in and out to do lots of things whenever it feels like it.
As requested, here are some details.  This is more technical than political, but may be of interest.  This concerns keystroke dynamics on a phrase known by the auth server, not the general background stuff. So we are not really talking about the passive spying/monitoring here, but rather a potential product. So after I wrote my keystroke dynamics proof-of-concept I discovered that the statistical technique had been patented 25 years before (the patent had expired), which validated my approach... Mine had some extra twizzlers though.
At Web browser-based initialization, the user sets a reference challenge word, say, "foobar". She must then enter some samples.  For each sample, a vector of 12 time values is created, one for each keyDown and keyUp event.  Some subtlety is needed in the programming, as keyUp on F might occur before keyDown on O on one sample, but after on the next.  We would like to compare apples to apples.
So we have a sample from the population of vectors as generated by the human.  When authentication is checked, we must measure the distance of our trial vector, from the population.  For this I used the Mahalanobis distance.  Mahalanobis was a well-known Indian statistician who in the 1930s designed a test in order to help anthropologists decide whether skull fragments found in caves matched each other.  This test measures the distance between each pair of entries in a vector.  So F-down and F-up are compared, and also F-down and A-down are compared.  Crucially, the distributions for each pair are normalized.  The vectors can have any numerical data in the components.  It can be used in botany with leaf area, weight, rainfall, etc.  It works beautifully for typing patterns.  Notice that we don't need to extract "dwell" times for keys, but all the same info is there in the more primitive array.
I set a configurable threshold of 20 for the distance triggering secondary authentication.  If I typed with proper focus, I would get distance of say around 4.  If someone else typed they would get say 70 or 150.  These are just typical examples.  It worked fine.  Here are some things I learned.
1. It's very hard to test objectively to make a business case.  Why?  Well if you go around the cubicles asking people to try it, you might get some people testing it on a laptop they don't normally use, or using some sort of random typing, on a string that they don't have an established pattern for.  I realized that KD is not magic.  Just as you would not expect to type a normal password "123456" by mashing the keys randomly, you have to consciously type in your official pattern for KD to work.  It is well-known that the best words for KD are things like your own name, for which you have a well-established pattern.  Now you see one of the reasons that this stuff has not taken off.  You might assiduously set the samples (or have passive background capturing working) on your usual desktop.  Then it will fail when you hunt-and-peck on your laptop.
2. I had a mobile developer add in touchscreen events for an iPhone test.  This uses character and time, and also x and y co-ordinates for both press and release (there is some drag).   The future will bring force.  The beauty of Mahalanobis is that these just go right in and work immediately.  Well, the stats does.  Dealing with these big fat vectors is not trivial.  I proved that it would work (actually it could not fail), but did not complete the mobile version.
3. I hacked the stats out in C.  Interestingly, for me it was harder getting the online demo going with the Web page, jQuery, PHP, and MySQL, than implementing the actual Mahalanobis test.  Maybe I should set the demo up for folks to try.
4. Twizzlers.  One is that I allowed arbitrary shifty characters in my phrase.  So in fact our user could simply tap her favorite rhythm on the Ctrl key, for her authentication factor.  Worked fine.
5. Hope the above was of interest...

@_date: 2015-10-08 18:48:21
@_author: Michael Nelson 
@_subject: Introduce randommess in keypress timings 
Five minutes of Swedish death metal should get you around 256 bits.

@_date: 2015-10-06 20:15:39
@_author: Michael Nelson 
@_subject: Introduce randommess in keypress timings 
Alternatively all keystrokes could be done with fixed timing.  The point is that no individual pattern should be discernable.  There are more subtle aspects, such as jitter from perfectly regular timing, which could identify the machine/browser being used.  With added randomness, such jitter would be harder to discern.  Also, you would ideally not want eavesdroppers to know that you are obfuscating your keystrokes, and obfuscating via randomness, as opposed to fixed timing, would help with that.
There are quite a few companies selling keystroke dynamics products as an authentication factor.  There are also various efforts, such as one started at Stanford a few years ago, to monitor all aspects of a person's input, for continuous background authentication.  Not sure how that one's going.  Keystroke dynamics normally works on a short chosen phrase.  The latter stuff is more ambitious and extends that to arbitrarily long text, along with grammatical patterns, etc.  There is nothing new here.
After evaluating several products for a company I worked for, I built a keystroke dynamics product myself -- it was less work than going through the pain of registering for a trial of their software!  It was never used, for the same reason that kd is not used much -- it's more trouble than it's worth. It worked as well as any of the products being sold.
Though a key down or key up event from the Windows operating system has a timestamp in it (the OS will not give you more than a certain accuracy, but it's adequate), that timestamp is discarded and not available in Javascript.  My Javascript solution calls for a new Date as soon as it captures a key event.  People selling this stuff say that as there is too much potential lag between the key event and the time thus associated, Javascript is not good.  The best thing is something like an ActiveX  plugin or a native client in C that can capture the timestamp from the OS.  The next best thing was touted as Flash.  However, mine worked very well.
If anyone is interested I will describe in simple terms how one tests the keystroke vectors, and some of the challenges.

@_date: 2015-10-07 16:48:49
@_author: Michael Nelson 
@_subject: Introduce randommess in keypress timings 
Well it does have an impact, but not enough to ruin things.  Of course it's not just js itself, but the browser, which swaps things in and out to do lots of things whenever it feels like it.
As requested, here are some details.  This is more technical than political, but may be of interest.  This concerns keystroke dynamics on a phrase known by the auth server, not the general background stuff. So we are not really talking about the passive spying/monitoring here, but rather a potential product. So after I wrote my keystroke dynamics proof-of-concept I discovered that the statistical technique had been patented 25 years before (the patent had expired), which validated my approach... Mine had some extra twizzlers though.
At Web browser-based initialization, the user sets a reference challenge word, say, "foobar". She must then enter some samples.  For each sample, a vector of 12 time values is created, one for each keyDown and keyUp event.  Some subtlety is needed in the programming, as keyUp on F might occur before keyDown on O on one sample, but after on the next.  We would like to compare apples to apples.
So we have a sample from the population of vectors as generated by the human.  When authentication is checked, we must measure the distance of our trial vector, from the population.  For this I used the Mahalanobis distance.  Mahalanobis was a well-known Indian statistician who in the 1930s designed a test in order to help anthropologists decide whether skull fragments found in caves matched each other.  This test measures the distance between each pair of entries in a vector.  So F-down and F-up are compared, and also F-down and A-down are compared.  Crucially, the distributions for each pair are normalized.  The vectors can have any numerical data in the components.  It can be used in botany with leaf area, weight, rainfall, etc.  It works beautifully for typing patterns.  Notice that we don't need to extract "dwell" times for keys, but all the same info is there in the more primitive array.
I set a configurable threshold of 20 for the distance triggering secondary authentication.  If I typed with proper focus, I would get distance of say around 4.  If someone else typed they would get say 70 or 150.  These are just typical examples.  It worked fine.  Here are some things I learned.
1. It's very hard to test objectively to make a business case.  Why?  Well if you go around the cubicles asking people to try it, you might get some people testing it on a laptop they don't normally use, or using some sort of random typing, on a string that they don't have an established pattern for.  I realized that KD is not magic.  Just as you would not expect to type a normal password "123456" by mashing the keys randomly, you have to consciously type in your official pattern for KD to work.  It is well-known that the best words for KD are things like your own name, for which you have a well-established pattern.  Now you see one of the reasons that this stuff has not taken off.  You might assiduously set the samples (or have passive background capturing working) on your usual desktop.  Then it will fail when you hunt-and-peck on your laptop.
2. I had a mobile developer add in touchscreen events for an iPhone test.  This uses character and time, and also x and y co-ordinates for both press and release (there is some drag).   The future will bring force.  The beauty of Mahalanobis is that these just go right in and work immediately.  Well, the stats does.  Dealing with these big fat vectors is not trivial.  I proved that it would work (actually it could not fail), but did not complete the mobile version.
3. I hacked the stats out in C.  Interestingly, for me it was harder getting the online demo going with the Web page, jQuery, PHP, and MySQL, than implementing the actual Mahalanobis test.  Maybe I should set the demo up for folks to try.
4. Twizzlers.  One is that I allowed arbitrary shifty characters in my phrase.  So in fact our user could simply tap her favorite rhythm on the Ctrl key, for her authentication factor.  Worked fine.
5. Hope the above was of interest...

@_date: 2015-10-08 18:48:21
@_author: Michael Nelson 
@_subject: Introduce randommess in keypress timings 
Five minutes of Swedish death metal should get you around 256 bits.

@_date: 2015-10-06 20:15:39
@_author: Michael Nelson 
@_subject: Introduce randommess in keypress timings 
Alternatively all keystrokes could be done with fixed timing.  The point is that no individual pattern should be discernable.  There are more subtle aspects, such as jitter from perfectly regular timing, which could identify the machine/browser being used.  With added randomness, such jitter would be harder to discern.  Also, you would ideally not want eavesdroppers to know that you are obfuscating your keystrokes, and obfuscating via randomness, as opposed to fixed timing, would help with that.
There are quite a few companies selling keystroke dynamics products as an authentication factor.  There are also various efforts, such as one started at Stanford a few years ago, to monitor all aspects of a person's input, for continuous background authentication.  Not sure how that one's going.  Keystroke dynamics normally works on a short chosen phrase.  The latter stuff is more ambitious and extends that to arbitrarily long text, along with grammatical patterns, etc.  There is nothing new here.
After evaluating several products for a company I worked for, I built a keystroke dynamics product myself -- it was less work than going through the pain of registering for a trial of their software!  It was never used, for the same reason that kd is not used much -- it's more trouble than it's worth. It worked as well as any of the products being sold.
Though a key down or key up event from the Windows operating system has a timestamp in it (the OS will not give you more than a certain accuracy, but it's adequate), that timestamp is discarded and not available in Javascript.  My Javascript solution calls for a new Date as soon as it captures a key event.  People selling this stuff say that as there is too much potential lag between the key event and the time thus associated, Javascript is not good.  The best thing is something like an ActiveX  plugin or a native client in C that can capture the timestamp from the OS.  The next best thing was touted as Flash.  However, mine worked very well.
If anyone is interested I will describe in simple terms how one tests the keystroke vectors, and some of the challenges.

@_date: 2015-10-07 16:48:49
@_author: Michael Nelson 
@_subject: Introduce randommess in keypress timings 
Well it does have an impact, but not enough to ruin things.  Of course it's not just js itself, but the browser, which swaps things in and out to do lots of things whenever it feels like it.
As requested, here are some details.  This is more technical than political, but may be of interest.  This concerns keystroke dynamics on a phrase known by the auth server, not the general background stuff. So we are not really talking about the passive spying/monitoring here, but rather a potential product. So after I wrote my keystroke dynamics proof-of-concept I discovered that the statistical technique had been patented 25 years before (the patent had expired), which validated my approach... Mine had some extra twizzlers though.
At Web browser-based initialization, the user sets a reference challenge word, say, "foobar". She must then enter some samples.  For each sample, a vector of 12 time values is created, one for each keyDown and keyUp event.  Some subtlety is needed in the programming, as keyUp on F might occur before keyDown on O on one sample, but after on the next.  We would like to compare apples to apples.
So we have a sample from the population of vectors as generated by the human.  When authentication is checked, we must measure the distance of our trial vector, from the population.  For this I used the Mahalanobis distance.  Mahalanobis was a well-known Indian statistician who in the 1930s designed a test in order to help anthropologists decide whether skull fragments found in caves matched each other.  This test measures the distance between each pair of entries in a vector.  So F-down and F-up are compared, and also F-down and A-down are compared.  Crucially, the distributions for each pair are normalized.  The vectors can have any numerical data in the components.  It can be used in botany with leaf area, weight, rainfall, etc.  It works beautifully for typing patterns.  Notice that we don't need to extract "dwell" times for keys, but all the same info is there in the more primitive array.
I set a configurable threshold of 20 for the distance triggering secondary authentication.  If I typed with proper focus, I would get distance of say around 4.  If someone else typed they would get say 70 or 150.  These are just typical examples.  It worked fine.  Here are some things I learned.
1. It's very hard to test objectively to make a business case.  Why?  Well if you go around the cubicles asking people to try it, you might get some people testing it on a laptop they don't normally use, or using some sort of random typing, on a string that they don't have an established pattern for.  I realized that KD is not magic.  Just as you would not expect to type a normal password "123456" by mashing the keys randomly, you have to consciously type in your official pattern for KD to work.  It is well-known that the best words for KD are things like your own name, for which you have a well-established pattern.  Now you see one of the reasons that this stuff has not taken off.  You might assiduously set the samples (or have passive background capturing working) on your usual desktop.  Then it will fail when you hunt-and-peck on your laptop.
2. I had a mobile developer add in touchscreen events for an iPhone test.  This uses character and time, and also x and y co-ordinates for both press and release (there is some drag).   The future will bring force.  The beauty of Mahalanobis is that these just go right in and work immediately.  Well, the stats does.  Dealing with these big fat vectors is not trivial.  I proved that it would work (actually it could not fail), but did not complete the mobile version.
3. I hacked the stats out in C.  Interestingly, for me it was harder getting the online demo going with the Web page, jQuery, PHP, and MySQL, than implementing the actual Mahalanobis test.  Maybe I should set the demo up for folks to try.
4. Twizzlers.  One is that I allowed arbitrary shifty characters in my phrase.  So in fact our user could simply tap her favorite rhythm on the Ctrl key, for her authentication factor.  Worked fine.
5. Hope the above was of interest...

@_date: 2015-10-08 18:48:21
@_author: Michael Nelson 
@_subject: Introduce randommess in keypress timings 
Five minutes of Swedish death metal should get you around 256 bits.

@_date: 2016-02-01 23:54:44
@_author: Michael Nelson 
@_subject: Daddy longlegs 
Last week I saw an announcement that they have discovered a new species of daddy longlegs named "Cryptomaster Behemoth". Actually I think there are a few on this mailing list.

@_date: 2016-02-01 23:54:44
@_author: Michael Nelson 
@_subject: Daddy longlegs 
Last week I saw an announcement that they have discovered a new species of daddy longlegs named "Cryptomaster Behemoth". Actually I think there are a few on this mailing list.

@_date: 2016-02-01 23:54:44
@_author: Michael Nelson 
@_subject: Daddy longlegs 
Last week I saw an announcement that they have discovered a new species of daddy longlegs named "Cryptomaster Behemoth". Actually I think there are a few on this mailing list.

@_date: 2017-12-09 02:22:28
@_author: Michael Nelson 
@_subject: Bitcoin... Destroying the planet 
The mapping between Bitcoin and energy is missing the point, from the point of view of understanding the system. The correct mapping is between Bitcoin and the *price* of energy.
If electricity were 10 times as expensive, Bitcoin mining use of electric power would drop by a factor of 10 (for a given BTC price). The point of spending money on mining is to be competitive. The absolute amount of power is irrelevant.
This means that if governments raised the price of electricity, or resources used for generating it, then BTC would never be a problem. Not trivial to do, admittedly, but the point here is to understand the system.
With things like automobiles and air-conditioners, raising electricity prices would improve the situation (regarding what economists call "externalities"), but degrade the user experience. Well, raising prices would improve the external impact of Bitcoin, but would have no effect on the correct functioning of the Bitcoin model. Whereas an automobile still uses the same amount of fuel to get you from A to B, when you raise the price of fuel, Bitcoin instantly drops the amount of fuel it uses, but continues to function just as well.
Interestingly, environmentalists do not so much blame the automobile and the drivers as much as governments for allowing the tolerance of them, and rightly so. They say that we need fuel prices and taxes that reflect the impact on the environment, and we need support for alternative energy sources, etc. So why blame poor old Bitcoin?

@_date: 2017-12-09 02:22:28
@_author: Michael Nelson 
@_subject: Bitcoin... Destroying the planet 
The mapping between Bitcoin and energy is missing the point, from the point of view of understanding the system. The correct mapping is between Bitcoin and the *price* of energy.
If electricity were 10 times as expensive, Bitcoin mining use of electric power would drop by a factor of 10 (for a given BTC price). The point of spending money on mining is to be competitive. The absolute amount of power is irrelevant.
This means that if governments raised the price of electricity, or resources used for generating it, then BTC would never be a problem. Not trivial to do, admittedly, but the point here is to understand the system.
With things like automobiles and air-conditioners, raising electricity prices would improve the situation (regarding what economists call "externalities"), but degrade the user experience. Well, raising prices would improve the external impact of Bitcoin, but would have no effect on the correct functioning of the Bitcoin model. Whereas an automobile still uses the same amount of fuel to get you from A to B, when you raise the price of fuel, Bitcoin instantly drops the amount of fuel it uses, but continues to function just as well.
Interestingly, environmentalists do not so much blame the automobile and the drivers as much as governments for allowing the tolerance of them, and rightly so. They say that we need fuel prices and taxes that reflect the impact on the environment, and we need support for alternative energy sources, etc. So why blame poor old Bitcoin?
