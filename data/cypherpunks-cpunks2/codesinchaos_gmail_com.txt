
@_date: 2013-11-11 17:42:54
@_author: CodesInChaos 
@_subject: NIST Randomness Beacon 
"cryptography This can be avoided by running a sequential computation based on that
hash. For example
by hashing it 2^40 times. Obvious downside is that verifying that the
computation was performed
correctly is just as expensive (but parallelizable).
Perhaps there is a function that's sequential and slow in one
direction and fast in the reverse direction.

@_date: 2013-11-11 21:45:33
@_author: CodesInChaos 
@_subject: [cryptography] NIST Randomness Beacon 
No this idea isn't about proof of work. The idea is delaying the
computation result, preventing a miner from picking a value.
If the computation takes an hour on the fastest available computer and
isn't parallelizable, then a miner can't influence
the unpredictable value (unless they have 51%).
With slightly weaker security requirements iterating only a few
million times would be decent as well, since attempting to
influence the value would result in a performance hit a competitive
miner can't afford.

@_date: 2013-11-11 17:42:54
@_author: CodesInChaos 
@_subject: NIST Randomness Beacon 
"cryptography This can be avoided by running a sequential computation based on that
hash. For example
by hashing it 2^40 times. Obvious downside is that verifying that the
computation was performed
correctly is just as expensive (but parallelizable).
Perhaps there is a function that's sequential and slow in one
direction and fast in the reverse direction.

@_date: 2013-11-11 21:45:33
@_author: CodesInChaos 
@_subject: [cryptography] NIST Randomness Beacon 
No this idea isn't about proof of work. The idea is delaying the
computation result, preventing a miner from picking a value.
If the computation takes an hour on the fastest available computer and
isn't parallelizable, then a miner can't influence
the unpredictable value (unless they have 51%).
With slightly weaker security requirements iterating only a few
million times would be decent as well, since attempting to
influence the value would result in a performance hit a competitive
miner can't afford.

@_date: 2013-11-11 17:42:54
@_author: CodesInChaos 
@_subject: NIST Randomness Beacon 
This can be avoided by running a sequential computation based on that
hash. For example
by hashing it 2^40 times. Obvious downside is that verifying that the
computation was performed
correctly is just as expensive (but parallelizable).
Perhaps there is a function that's sequential and slow in one
direction and fast in the reverse direction.

@_date: 2013-11-11 21:45:33
@_author: CodesInChaos 
@_subject: [cryptography] NIST Randomness Beacon 
No this idea isn't about proof of work. The idea is delaying the
computation result, preventing a miner from picking a value.
If the computation takes an hour on the fastest available computer and
isn't parallelizable, then a miner can't influence
the unpredictable value (unless they have 51%).
With slightly weaker security requirements iterating only a few
million times would be decent as well, since attempting to
influence the value would result in a performance hit a competitive
miner can't afford.

@_date: 2013-10-03 21:24:09
@_author: CodesInChaos 
@_subject: Pen register request used to force disclosure of SSL private keys 
We need to catch a CA which does this, for example using Certificate
Then handing over the CA private key is equivalent to committing company
This means that
1. CAs will fight with all they've got
2. If corruption is successful, eliminates US CAs one by one until there
are none left to compel.
I don't think disabling auto-update is a good idea. What we need is secure
auto update.
This involves:
1) requiring multiple signatures on the update by people in different
2) Reproducible builds
3) A Certificate Transparency like log of all updates.
I believe TOR is doing some work on points 1) and 2).

@_date: 2013-10-03 21:24:09
@_author: CodesInChaos 
@_subject: Pen register request used to force disclosure of SSL private keys 
We need to catch a CA which does this, for example using Certificate
Then handing over the CA private key is equivalent to committing company
This means that
1. CAs will fight with all they've got
2. If corruption is successful, eliminates US CAs one by one until there
are none left to compel.
I don't think disabling auto-update is a good idea. What we need is secure
auto update.
This involves:
1) requiring multiple signatures on the update by people in different
2) Reproducible builds
3) A Certificate Transparency like log of all updates.
I believe TOR is doing some work on points 1) and 2).

@_date: 2013-10-03 21:24:09
@_author: CodesInChaos 
@_subject: Pen register request used to force disclosure of SSL private keys 
We need to catch a CA which does this, for example using Certificate
Then handing over the CA private key is equivalent to committing company
This means that
1. CAs will fight with all they've got
2. If corruption is successful, eliminates US CAs one by one until there
are none left to compel.
I don't think disabling auto-update is a good idea. What we need is secure
auto update.
This involves:
1) requiring multiple signatures on the update by people in different
2) Reproducible builds
3) A Certificate Transparency like log of all updates.
I believe TOR is doing some work on points 1) and 2).

@_date: 2014-12-08 19:47:47
@_author: CodesInChaos 
@_subject: Bitcoin networks surpasses 2^80 hashes per week 
That'd only be the case for a naive collision finding attack. But
there are attacks that require little memory. Search for
"distinguished points".

@_date: 2014-12-08 19:47:47
@_author: CodesInChaos 
@_subject: Bitcoin networks surpasses 2^80 hashes per week 
That'd only be the case for a naive collision finding attack. But
there are attacks that require little memory. Search for
"distinguished points".

@_date: 2014-12-08 19:47:47
@_author: CodesInChaos 
@_subject: Bitcoin networks surpasses 2^80 hashes per week 
That'd only be the case for a naive collision finding attack. But
there are attacks that require little memory. Search for
"distinguished points".

@_date: 2014-11-19 10:35:35
@_author: CodesInChaos 
@_subject: Whatsapp open source 
The copyright holder can always dual-license it. In the case of text
secure it's a bit more complicated, but still the CLA allows OWS to
dual-license the code. So I wouldn't expect anything.

@_date: 2014-11-19 10:35:35
@_author: CodesInChaos 
@_subject: Whatsapp open source 
The copyright holder can always dual-license it. In the case of text
secure it's a bit more complicated, but still the CLA allows OWS to
dual-license the code. So I wouldn't expect anything.

@_date: 2014-11-19 10:35:35
@_author: CodesInChaos 
@_subject: Whatsapp open source 
The copyright holder can always dual-license it. In the case of text
secure it's a bit more complicated, but still the CLA allows OWS to
dual-license the code. So I wouldn't expect anything.

@_date: 2014-09-20 18:43:56
@_author: CodesInChaos 
@_subject: salty axolotl 
Why would you use scrypt for anything except strengthening low entropy
secrets (like passwords)?
For high entropy secrets there are much simpler and cleaner
alternatives, such as HKDF.

@_date: 2014-09-20 18:43:56
@_author: CodesInChaos 
@_subject: salty axolotl 
Why would you use scrypt for anything except strengthening low entropy
secrets (like passwords)?
For high entropy secrets there are much simpler and cleaner
alternatives, such as HKDF.

@_date: 2014-09-20 18:43:56
@_author: CodesInChaos 
@_subject: salty axolotl 
Why would you use scrypt for anything except strengthening low entropy
secrets (like passwords)?
For high entropy secrets there are much simpler and cleaner
alternatives, such as HKDF.
