
@_date: 2014-04-10 06:40:38
@_author: Peter Malone 
@_subject: Two possible vulnerabilities in OpenSSL? 
Hey there,
I was auditing OpenSSL last night. I looked at several files and found
the following:
 * avoid an attack we should *always* see RI even on initial server  * hello because the client doesn't see any renegotiation during an  * attack. However this would mean we could not connect to any server  * which doesn't support RI so for the immediate future tolerate RI  * absence on initial connect only.  */  Well that's awful coding.
Unless I'm mistaken, the following memcmp is vulnerable to a remote
timing attack.
static int ssl_session_cmp(const SSL_SESSION *a,const SSL_SESSION *b)  {    if (a->ssl_version != b->ssl_version)         return(1);    if (a->session_id_length != b->session_id_length)         return(1);    return(memcmp(a->session_id,b->session_id,a->session_id_length));  }  I posted both of these findings to the full disclosure list last night.
I figured someone on this list might find it interesting as well.

@_date: 2014-04-10 20:06:12
@_author: Peter Malone 
@_subject: Two possible vulnerabilities in OpenSSL? 
It's no longer implemented in OpenSSL, however some of the versions
which were not vulnerable to Heartbleed are impacted.
Also the latest version of Ruby and Android implement it.

@_date: 2014-04-11 22:57:42
@_author: Peter Malone 
@_subject: [tor-talk] [cryptography] The Heartbleed Bug is a serious 
I don't buy into conspiracy theories often but I really can't see how
you can fail to follow your own RFC. If he had a check in there to make
sure the payload_length wasn't too large I would say "hey, he forgot to
make sure it wasn't too small and he never even mentioned checking if it
was too small that in the RFC"... but he actually never checked for
anything.. so maybe it is just a mistake. He definitely failed to follow
his own RFC which never mentioned making sure the length was correct,
just that it wasn't too big, and that's something he never did.
I don't get how the reviewer can miss it too, like it's code for an RFC
the reviewer is COMPLETELY new to... so at first the code looks a bit
mad until you read the RFC, then you realize right away that he's
missing shit. Seems silly, i don't think the reviewer ever read the RFC.

@_date: 2014-04-10 06:40:38
@_author: Peter Malone 
@_subject: Two possible vulnerabilities in OpenSSL? 
Hey there,
I was auditing OpenSSL last night. I looked at several files and found
the following:
 * avoid an attack we should *always* see RI even on initial server  * hello because the client doesn't see any renegotiation during an  * attack. However this would mean we could not connect to any server  * which doesn't support RI so for the immediate future tolerate RI  * absence on initial connect only.  */  Well that's awful coding.
Unless I'm mistaken, the following memcmp is vulnerable to a remote
timing attack.
static int ssl_session_cmp(const SSL_SESSION *a,const SSL_SESSION *b)  {    if (a->ssl_version != b->ssl_version)         return(1);    if (a->session_id_length != b->session_id_length)         return(1);    return(memcmp(a->session_id,b->session_id,a->session_id_length));  }  I posted both of these findings to the full disclosure list last night.
I figured someone on this list might find it interesting as well.

@_date: 2014-04-10 20:06:12
@_author: Peter Malone 
@_subject: Two possible vulnerabilities in OpenSSL? 
It's no longer implemented in OpenSSL, however some of the versions
which were not vulnerable to Heartbleed are impacted.
Also the latest version of Ruby and Android implement it.

@_date: 2014-04-11 22:57:42
@_author: Peter Malone 
@_subject: [tor-talk] [cryptography] The Heartbleed Bug is a serious 
I don't buy into conspiracy theories often but I really can't see how
you can fail to follow your own RFC. If he had a check in there to make
sure the payload_length wasn't too large I would say "hey, he forgot to
make sure it wasn't too small and he never even mentioned checking if it
was too small that in the RFC"... but he actually never checked for
anything.. so maybe it is just a mistake. He definitely failed to follow
his own RFC which never mentioned making sure the length was correct,
just that it wasn't too big, and that's something he never did.
I don't get how the reviewer can miss it too, like it's code for an RFC
the reviewer is COMPLETELY new to... so at first the code looks a bit
mad until you read the RFC, then you realize right away that he's
missing shit. Seems silly, i don't think the reviewer ever read the RFC.

@_date: 2014-04-10 06:40:38
@_author: Peter Malone 
@_subject: Two possible vulnerabilities in OpenSSL? 
Hey there,
I was auditing OpenSSL last night. I looked at several files and found
the following:
 * avoid an attack we should *always* see RI even on initial server  * hello because the client doesn't see any renegotiation during an  * attack. However this would mean we could not connect to any server  * which doesn't support RI so for the immediate future tolerate RI  * absence on initial connect only.  */  Well that's awful coding.
Unless I'm mistaken, the following memcmp is vulnerable to a remote
timing attack.
static int ssl_session_cmp(const SSL_SESSION *a,const SSL_SESSION *b)  {    if (a->ssl_version != b->ssl_version)         return(1);    if (a->session_id_length != b->session_id_length)         return(1);    return(memcmp(a->session_id,b->session_id,a->session_id_length));  }  I posted both of these findings to the full disclosure list last night.
I figured someone on this list might find it interesting as well.

@_date: 2014-04-10 20:06:12
@_author: Peter Malone 
@_subject: Two possible vulnerabilities in OpenSSL? 
It's no longer implemented in OpenSSL, however some of the versions
which were not vulnerable to Heartbleed are impacted.
Also the latest version of Ruby and Android implement it.

@_date: 2014-04-11 22:57:42
@_author: Peter Malone 
@_subject: [tor-talk] [cryptography] The Heartbleed Bug is a serious 
I don't buy into conspiracy theories often but I really can't see how
you can fail to follow your own RFC. If he had a check in there to make
sure the payload_length wasn't too large I would say "hey, he forgot to
make sure it wasn't too small and he never even mentioned checking if it
was too small that in the RFC"... but he actually never checked for
anything.. so maybe it is just a mistake. He definitely failed to follow
his own RFC which never mentioned making sure the length was correct,
just that it wasn't too big, and that's something he never did.
I don't get how the reviewer can miss it too, like it's code for an RFC
the reviewer is COMPLETELY new to... so at first the code looks a bit
mad until you read the RFC, then you realize right away that he's
missing shit. Seems silly, i don't think the reviewer ever read the RFC.
