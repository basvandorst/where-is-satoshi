
@_date: 2013-11-05 09:51:50
@_author: John Denker 
@_subject: [Cryptography] randomness +- entropy 
Are we not having a technical discussion?  If not, then what?
The physics entropy and the information-theory entropy are the
same thing.  This is not a mere "similarity in formalisms".
For example, it is a one-line calculation to find the entropy
of the nuclear spins in a sample of copper, starting from
statistical principles, namely
     S = R ln 4
and you can also measure S using a physical thermometer.
Mirabile dictu, you get the same answer either way.
Nevermind the word, ideas are what's important.  Terminology is
important only insofar as it helps formulate and communicate the
The /idea/ of entropy has tremendous significance.  If we didn't
call it "entropy" we would need to invent another name for it.  So
please let's save everybody a lot of trouble and call it "entropy".
Yes, "tied to" ... but that's not the same as "same as".  Simple
 -- If you mean "unpredictability", say "unpredictability".
 -- If you mean "entropy", say "entropy".
We have perfectly good words for each of these things.
Speak for yourself, Kemosabe.  As for me, I know of a systematic method for estimating the entropy, based on a series of intelligent guesses.  The method was described by some guy named Shannon, several decades ago.  It is consistent with everything else we know about Successful cryptography often depends on depth of understanding and
attention to detail.  The loosey-goosey approach is very likely to
get you into trouble.
The same idea applies to various other fields of endeavor
  There *is* a difference between a TRNG and a cryptographically-strong
  A) In /some/ situations, the difference doesn't matter very much.
  B) In other situations, it matters a great deal.
For starters,   A) It possible to imagine a TRNG independent of any PRNG.
  B) It is not possible to imagine a PRNG completely independent of
   any TRNG, because the PRNG needs a seed, and the seed has to
   come from somewhere.
Here's another contrast:
   A) It may be that under /normal/ operating conditions, the /user/
    does not care about TRNG versus PRNG.
   B) Anybody who is /designing/ any such thing needs to understand
    the distinction.  In particular, the /recovery from compromise/     is wildly different in the two cases.
Here's a highly-condensed tutorial:
Suppose we have N-bit codewords, and various statistical distributions
over codewords.
Entropy is a property of the ensemble (not of any particular codeword).
 1) If the ensemble consists of all 2^N possible codewords, evenly   distributed, the distribution has N bits of entropy.
 2) Now consider a different distribution.  If half the codewords are
  missing, and the rest are evenly distributed, the distribution has
  N-1 bits of entropy.
 2a) In the sub-case where you know exactly which codewords are missing,
  this distribution is noticeably less random, less predictable than
  distribution (1).
 2b) In the sub-case where it is computationally infeasible to figure
  out which codewords are missing, this distribution may be -- for a
  wide range of practical purposes -- just as unpredictable as
  distribution (1).  However, it still has less entropy.
 3) For a typical real-world PRNG, we are not talking about one bit of
  entropy going missing.  Almost all of the bits have gone missing!
  If we seed the PRNG with 100 bits and then use it to generate a
  billion bits, then there are 2^999999900 missing codes out of a
  possible 2^1000000000.  That's a lot of missing codes.  Well over
  99.99% of the codes are missing.
  With a TRNG, the situation is reversed.  Ideally there would be no
  missing codes whatsoever.  However, for reasons of computational
  efficiency, a practical TRNG will typically allow a few -- a very
  few -- codes to be missing or under-represented in the ensemble.
  The contrast is extreme:
   A) The cryptographic strength required to hide the missing codes
    when almost all codes are missing, versus
   B) The cryptographic strength required to hide the under-represented
    codes, when there are very few of them.
And on top of that, there is the issue or recovery from compromise.
There is an important idea here.  If you are not going to call this
idea "entropy", you need to come up with a different name for it.
Bear in mind that practically everybody in the world reserves the
word "entropy" to denote the genuine physical / statistical entropy.
Also note that we have perfectly good words like "randomness" and
"unpredictability" to cover the other cases.
The cryptography mailing list

@_date: 2013-11-05 09:51:50
@_author: John Denker 
@_subject: [Cryptography] randomness +- entropy 
Are we not having a technical discussion?  If not, then what?
The physics entropy and the information-theory entropy are the
same thing.  This is not a mere "similarity in formalisms".
For example, it is a one-line calculation to find the entropy
of the nuclear spins in a sample of copper, starting from
statistical principles, namely
     S = R ln 4
and you can also measure S using a physical thermometer.
Mirabile dictu, you get the same answer either way.
Nevermind the word, ideas are what's important.  Terminology is
important only insofar as it helps formulate and communicate the
The /idea/ of entropy has tremendous significance.  If we didn't
call it "entropy" we would need to invent another name for it.  So
please let's save everybody a lot of trouble and call it "entropy".
Yes, "tied to" ... but that's not the same as "same as".  Simple
 -- If you mean "unpredictability", say "unpredictability".
 -- If you mean "entropy", say "entropy".
We have perfectly good words for each of these things.
Speak for yourself, Kemosabe.  As for me, I know of a systematic method for estimating the entropy, based on a series of intelligent guesses.  The method was described by some guy named Shannon, several decades ago.  It is consistent with everything else we know about Successful cryptography often depends on depth of understanding and
attention to detail.  The loosey-goosey approach is very likely to
get you into trouble.
The same idea applies to various other fields of endeavor
  There *is* a difference between a TRNG and a cryptographically-strong
  A) In /some/ situations, the difference doesn't matter very much.
  B) In other situations, it matters a great deal.
For starters,   A) It possible to imagine a TRNG independent of any PRNG.
  B) It is not possible to imagine a PRNG completely independent of
   any TRNG, because the PRNG needs a seed, and the seed has to
   come from somewhere.
Here's another contrast:
   A) It may be that under /normal/ operating conditions, the /user/
    does not care about TRNG versus PRNG.
   B) Anybody who is /designing/ any such thing needs to understand
    the distinction.  In particular, the /recovery from compromise/     is wildly different in the two cases.
Here's a highly-condensed tutorial:
Suppose we have N-bit codewords, and various statistical distributions
over codewords.
Entropy is a property of the ensemble (not of any particular codeword).
 1) If the ensemble consists of all 2^N possible codewords, evenly   distributed, the distribution has N bits of entropy.
 2) Now consider a different distribution.  If half the codewords are
  missing, and the rest are evenly distributed, the distribution has
  N-1 bits of entropy.
 2a) In the sub-case where you know exactly which codewords are missing,
  this distribution is noticeably less random, less predictable than
  distribution (1).
 2b) In the sub-case where it is computationally infeasible to figure
  out which codewords are missing, this distribution may be -- for a
  wide range of practical purposes -- just as unpredictable as
  distribution (1).  However, it still has less entropy.
 3) For a typical real-world PRNG, we are not talking about one bit of
  entropy going missing.  Almost all of the bits have gone missing!
  If we seed the PRNG with 100 bits and then use it to generate a
  billion bits, then there are 2^999999900 missing codes out of a
  possible 2^1000000000.  That's a lot of missing codes.  Well over
  99.99% of the codes are missing.
  With a TRNG, the situation is reversed.  Ideally there would be no
  missing codes whatsoever.  However, for reasons of computational
  efficiency, a practical TRNG will typically allow a few -- a very
  few -- codes to be missing or under-represented in the ensemble.
  The contrast is extreme:
   A) The cryptographic strength required to hide the missing codes
    when almost all codes are missing, versus
   B) The cryptographic strength required to hide the under-represented
    codes, when there are very few of them.
And on top of that, there is the issue or recovery from compromise.
There is an important idea here.  If you are not going to call this
idea "entropy", you need to come up with a different name for it.
Bear in mind that practically everybody in the world reserves the
word "entropy" to denote the genuine physical / statistical entropy.
Also note that we have perfectly good words like "randomness" and
"unpredictability" to cover the other cases.
The cryptography mailing list
cryptography at metzdowd.com

@_date: 2013-11-05 09:51:50
@_author: John Denker 
@_subject: [Cryptography] randomness +- entropy 
Are we not having a technical discussion?  If not, then what?
The physics entropy and the information-theory entropy are the
same thing.  This is not a mere "similarity in formalisms".
For example, it is a one-line calculation to find the entropy
of the nuclear spins in a sample of copper, starting from
statistical principles, namely
     S = R ln 4
and you can also measure S using a physical thermometer.
Mirabile dictu, you get the same answer either way.
Nevermind the word, ideas are what's important.  Terminology is
important only insofar as it helps formulate and communicate the
The /idea/ of entropy has tremendous significance.  If we didn't
call it "entropy" we would need to invent another name for it.  So
please let's save everybody a lot of trouble and call it "entropy".
Yes, "tied to" ... but that's not the same as "same as".  Simple
 -- If you mean "unpredictability", say "unpredictability".
 -- If you mean "entropy", say "entropy".
We have perfectly good words for each of these things.
Speak for yourself, Kemosabe.  As for me, I know of a systematic method for estimating the entropy, based on a series of intelligent guesses.  The method was described by some guy named Shannon, several decades ago.  It is consistent with everything else we know about Successful cryptography often depends on depth of understanding and
attention to detail.  The loosey-goosey approach is very likely to
get you into trouble.
The same idea applies to various other fields of endeavor
  There *is* a difference between a TRNG and a cryptographically-strong
  A) In /some/ situations, the difference doesn't matter very much.
  B) In other situations, it matters a great deal.
For starters,   A) It possible to imagine a TRNG independent of any PRNG.
  B) It is not possible to imagine a PRNG completely independent of
   any TRNG, because the PRNG needs a seed, and the seed has to
   come from somewhere.
Here's another contrast:
   A) It may be that under /normal/ operating conditions, the /user/
    does not care about TRNG versus PRNG.
   B) Anybody who is /designing/ any such thing needs to understand
    the distinction.  In particular, the /recovery from compromise/     is wildly different in the two cases.
Here's a highly-condensed tutorial:
Suppose we have N-bit codewords, and various statistical distributions
over codewords.
Entropy is a property of the ensemble (not of any particular codeword).
 1) If the ensemble consists of all 2^N possible codewords, evenly   distributed, the distribution has N bits of entropy.
 2) Now consider a different distribution.  If half the codewords are
  missing, and the rest are evenly distributed, the distribution has
  N-1 bits of entropy.
 2a) In the sub-case where you know exactly which codewords are missing,
  this distribution is noticeably less random, less predictable than
  distribution (1).
 2b) In the sub-case where it is computationally infeasible to figure
  out which codewords are missing, this distribution may be -- for a
  wide range of practical purposes -- just as unpredictable as
  distribution (1).  However, it still has less entropy.
 3) For a typical real-world PRNG, we are not talking about one bit of
  entropy going missing.  Almost all of the bits have gone missing!
  If we seed the PRNG with 100 bits and then use it to generate a
  billion bits, then there are 2^999999900 missing codes out of a
  possible 2^1000000000.  That's a lot of missing codes.  Well over
  99.99% of the codes are missing.
  With a TRNG, the situation is reversed.  Ideally there would be no
  missing codes whatsoever.  However, for reasons of computational
  efficiency, a practical TRNG will typically allow a few -- a very
  few -- codes to be missing or under-represented in the ensemble.
  The contrast is extreme:
   A) The cryptographic strength required to hide the missing codes
    when almost all codes are missing, versus
   B) The cryptographic strength required to hide the under-represented
    codes, when there are very few of them.
And on top of that, there is the issue or recovery from compromise.
There is an important idea here.  If you are not going to call this
idea "entropy", you need to come up with a different name for it.
Bear in mind that practically everybody in the world reserves the
word "entropy" to denote the genuine physical / statistical entropy.
Also note that we have perfectly good words like "randomness" and
"unpredictability" to cover the other cases.
The cryptography mailing list
cryptography at metzdowd.com

@_date: 2013-10-19 14:21:15
@_author: John Denker 
@_subject: [Cryptography] PRNG WYTM 
OK, the next step in any such discussion is to ask the
famous question, What's Your Threat Model (WYTM).
Several different reasonable answers are possible.
1) At one extreme, we have the "no threat at all" model,
aka the "non-adversarial" model.  Examples include
 *) Doing a Monte Carlo integral in the context of   a molecular dynamics calculation.  The molecules   are not going to attack our PRNG.  They are not   going to cryptanalyze it.  Almost any PRNG is
  "random enough" for this purpose.
 *) Cooperative situations, such as friendly computers
  on a LAN, doing random exponential backoff as part
  of the layer-1 Ethernet CSMA/CD.  Everybody has a
  shared interest in implementing the protocol properly,
  so even if they could break the PRNG they wouldn't
  want to.
 *) Et cetera.  There are tons of examples in this   category.
A PRNG in category (1) could be considered "random" but not "secure".  It is usually adequate to seed this type of PRNG with things like the MAC address, serial number, and time-of-day.
2) At the opposite extreme we have high-stakes adversarial
applications, including military cryptography, banking,
other high-value business communications, high-stakes
gaming, etc. etc. etc.  A PRNG in this category needs to
be *secure* against a wide range of threats.
For tasks in this category, seeding the PRNG with things like the MAC address, serial number, and time-of-day is
nowhere near good enough.  It is a band-aid or worse.
It is security theater.  It gives you "randomness" in some weak sense, but it does not give you security.
The typical modern PRNG in this category consists of a
seed, a counter, a hash function, and a reseeding
mechanism.  Sometimes there is a block cipher in there somewhere, but to a sufficient approximation this is the same basic architecture, just with a fancier hash So let's look in more detail at the threats against such
a PRNG.
*) For starters we have the threat of direct cryptanalysis
of the output.  If the preimage can be found, all further
outputs will be known to the attacker, and probably all past outputs as well, over the span bounded by the nearest past and present reseedings.
The feasibility of finding a preimage depends on the number of bits output by the PRNG.  Therefore there
should be a limit on the number of output bits between
*) Another type of threat is more indirect.  For example,
suppose the PRNG was seeded at boot time from the saved
random-seed file.  It may be possible for the attacker to find this, perhaps by sneaking a peek at an old backup tape or whatever.  Such a threat is independent of the number of bits emitted by the PRNG.  It is hard to say what it /does/ depend on, but in the absence of anything better, wall-clock time is a plausible proxy.  Therefore there should be a time limit on how long a seed file is allowed to remain on disk before it is regenerated, and a time limit between reseedings of the PRNG.
That might be a "solution" in certain favorable cases, but
it is nowhere near being a reliable, general solution.  I
can think of five failure modes in five minutes.  Perhaps
the most obvious is this:  Suppose my system is sitting in
a rack at some colocation provider.  All the attacker needs
to do is rent a box in the same rack, on the same LAN
segment.  Then he knows my MAC address, the time at which
I booted up, and (to a good approximation) the arrival time
of every network packet addressed to me.
Similarly for my laptop on the corporate wifi network.  The
bad guy in the loft across the street has a nontrivial
chance of figuring out everything he needs to know about my network traffic.  If anybody has a proof that this
cannot happen, please explain.
Here's the only thing that has ever made sense to me:
 a) Any device that wants to have any security whatsoever
  needs to be able to store a seed, even when powered off.
 b) The seed needs to be provisioned on a per-device
  basis, much like the MAC address is provisioned.
 c) The seed needs to be big enough, randomly-chosen, and   secret, very unlike the MAC address, RTC, and device   serial number.
The cryptography mailing list

@_date: 2013-10-27 15:17:14
@_author: John Denker 
@_subject: [Cryptography] [RNG] /dev/random initialisation 
[sources for a good high-entropy seed]
This is excellent.  This is exactly the sort of discussion we
ought to be having.
I agree with the sentiment, but having lots of entropy isn't the only way of solving the problem;  we can make do with a lot less entropy if it is /computationally infeasible/ for the attacker to untangle what we have done.
OK, good.
It may help to add a little bit more detail to that analysis.  There are two subcases:
  a) The PRNG starts out in a good state, with a seed that is
   large enough, random enough, and unknown to the attacker.  If    we now use the real-time clock (RTC) to /stir/ the seed, that
   should be sufficient to guarantee no collisions.  That should
   be enough to stop replay attacks.
  b) If the PRNG starts out in a bad state, because the seed has
   been compromised, then the PRNG cannot quickly recover, and in
   particular it cannot recover while it is under attack.  The RTC
   is nowhere near sufficient to /substitute/ for a proper seed.
To say the same thing in slightly different words:  There are two
separate objectives that we need to consider:
  A) Resistance to attack, and
  B) Recovery from compromise.
In some rock-candy world it would be nice to do both at the same time, but in this world, there are situations where a practical
PRNG cannot do both at the same time, and that's OK.
The moral of the story is that it is super-important to make sure
the PRNG is properly seeded.  The seed needs to be big enough,
random enough, and unknown to the attacker.
Note that the RTC does not add real entropy to the PRNG.  All it
does is stir the PRNG.  Assuming the PRNG's hash function is working
properly, (seed + RTC1) should be effectively very different from
(seed + RTC2).  The attacker could try to mount a related-plaintext
attack against the hash, but for any decent cryptologic hash this
should be computationally infeasible.
There is a fundamental conceptual distinction between (a) reseeding
the PRNG with honest-to-goodness entropy and (b) merely stirring
the existing seed.  However, there are some situations in which
stirring suffices.
It shouldn't take much stirring, assuming the hash function is working
properly.  We absolutely require that the RTC produce non-repeating values, but that's about all we really require.  Again, this is all predicated on starting with a high-quality seed.
I hate to sound like a broken record, but the solution is the same in
all cases:  You need a proper seed:  big enough, random enough, and
unknown to the attacker.
The manufacturer reeeeally needs to provision each instance of the
device with a proper seed.  The cost of doing this is ridiculously
small.  The manufacturer already needs to provision things like the
MAC address, hostname, IMEI, et cetera ... and the addition burden
of provisioning the seed for the PRNG is negligible.
Again (!) the solution is the same:  If there is a proper seed, you're
fine.  If there is not a proper seed, you're screwed.
Specific suggestion:
  a) Download the .iso image onto disk.
  b) Provision a proper seed onto the image.
  c) Burn the modified image to CD if desired.
A few years ago I cooked up some tools to do exactly this.  I tried to
get support for it installed into the distributions, but the proposal
was shot down by some "expert" who decided that the RTC was sufficient
security, even if every attacker on earth knew what was in the distributed
seed-file ... and even if every attacker on earth knew what time it was.
More general suggestion:  We ought to produce some sort of "Best Practices"
document that explains to manufacturers, software distributors, VM providers,
et cetera how important it is to provision a proper seed, and explains how
to do it.
We should also provide tools and infrastructure that makes it easy to do
the right thing and hard to do the wrong thing.  For example, in the
general case, unpacking and repacking an .iso image is a pain in the neck,
but if the image is engineered to facilitate rewriting the seed-file the
procedure is much, much simpler.
Following up on a proposal by Jerry Leichter, on 10/25/2013 05:15 AM, I like this idea so much that I implemented it many years ago.  The
command line looks roughly like:
lynx -auth=harpo:swordfish -source ' | randomize kernel from -
I disagree; see below.
Again (!) the key is to have a proper seed stored on the machine
in question.  It's like the proverbial seed-corn:  If you have
none, you're screwed.  If you have some, you can grow more.
Some comments:
a) If you have 256 bits of honest-to-goodness entropy from
 /any/ source, OS or otherwise, then that's more than enough
 to seed the PRNG, and nothing on the list matters.
b) Ditto.
c) Not so good. Ping times are not guaranteed to be always
 different, and not guaranteed to be unknown to the attacker.
 In the crypto business it is conventional to worry about
 MITM attacks.  A scenario where the MITM doesn't need to
 mess with the packet contents, just the packet timing,
 is extra-easy for the attacker.
d) Not so good.  All that stuff is constant, and relatively
 easy for the attacker to know or guess.  The RTC wasn't  mentioned, but it is better than the items that were
 mentioned, in that it is at least non-constant and non-
 repeating.  The RTC cannot /substitute/ for a proper
 stored seed, but it can /stir/ the seed.
e) That's basically the right idea, except that we should
 call it the "stored" seed rather than the "at-birth" seed.
 The stored seed should be changed at frequent intervals.
 This helps with the recovery from compromise.  Perhaps
 more importantly, it reduces the window of vulnerability
 and reduces the value the attacker gets from peeking at  the stored seed.
The cryptography mailing list

@_date: 2013-10-19 14:21:15
@_author: John Denker 
@_subject: [Cryptography] PRNG WYTM 
OK, the next step in any such discussion is to ask the
famous question, What's Your Threat Model (WYTM).
Several different reasonable answers are possible.
1) At one extreme, we have the "no threat at all" model,
aka the "non-adversarial" model.  Examples include
 *) Doing a Monte Carlo integral in the context of   a molecular dynamics calculation.  The molecules   are not going to attack our PRNG.  They are not   going to cryptanalyze it.  Almost any PRNG is
  "random enough" for this purpose.
 *) Cooperative situations, such as friendly computers
  on a LAN, doing random exponential backoff as part
  of the layer-1 Ethernet CSMA/CD.  Everybody has a
  shared interest in implementing the protocol properly,
  so even if they could break the PRNG they wouldn't
  want to.
 *) Et cetera.  There are tons of examples in this   category.
A PRNG in category (1) could be considered "random" but not "secure".  It is usually adequate to seed this type of PRNG with things like the MAC address, serial number, and time-of-day.
2) At the opposite extreme we have high-stakes adversarial
applications, including military cryptography, banking,
other high-value business communications, high-stakes
gaming, etc. etc. etc.  A PRNG in this category needs to
be *secure* against a wide range of threats.
For tasks in this category, seeding the PRNG with things like the MAC address, serial number, and time-of-day is
nowhere near good enough.  It is a band-aid or worse.
It is security theater.  It gives you "randomness" in some weak sense, but it does not give you security.
The typical modern PRNG in this category consists of a
seed, a counter, a hash function, and a reseeding
mechanism.  Sometimes there is a block cipher in there somewhere, but to a sufficient approximation this is the same basic architecture, just with a fancier hash So let's look in more detail at the threats against such
a PRNG.
*) For starters we have the threat of direct cryptanalysis
of the output.  If the preimage can be found, all further
outputs will be known to the attacker, and probably all past outputs as well, over the span bounded by the nearest past and present reseedings.
The feasibility of finding a preimage depends on the number of bits output by the PRNG.  Therefore there
should be a limit on the number of output bits between
*) Another type of threat is more indirect.  For example,
suppose the PRNG was seeded at boot time from the saved
random-seed file.  It may be possible for the attacker to find this, perhaps by sneaking a peek at an old backup tape or whatever.  Such a threat is independent of the number of bits emitted by the PRNG.  It is hard to say what it /does/ depend on, but in the absence of anything better, wall-clock time is a plausible proxy.  Therefore there should be a time limit on how long a seed file is allowed to remain on disk before it is regenerated, and a time limit between reseedings of the PRNG.
That might be a "solution" in certain favorable cases, but
it is nowhere near being a reliable, general solution.  I
can think of five failure modes in five minutes.  Perhaps
the most obvious is this:  Suppose my system is sitting in
a rack at some colocation provider.  All the attacker needs
to do is rent a box in the same rack, on the same LAN
segment.  Then he knows my MAC address, the time at which
I booted up, and (to a good approximation) the arrival time
of every network packet addressed to me.
Similarly for my laptop on the corporate wifi network.  The
bad guy in the loft across the street has a nontrivial
chance of figuring out everything he needs to know about my network traffic.  If anybody has a proof that this
cannot happen, please explain.
Here's the only thing that has ever made sense to me:
 a) Any device that wants to have any security whatsoever
  needs to be able to store a seed, even when powered off.
 b) The seed needs to be provisioned on a per-device
  basis, much like the MAC address is provisioned.
 c) The seed needs to be big enough, randomly-chosen, and   secret, very unlike the MAC address, RTC, and device   serial number.
The cryptography mailing list
cryptography at metzdowd.com

@_date: 2013-10-27 15:17:14
@_author: John Denker 
@_subject: [Cryptography] [RNG] /dev/random initialisation 
[sources for a good high-entropy seed]
This is excellent.  This is exactly the sort of discussion we
ought to be having.
I agree with the sentiment, but having lots of entropy isn't the only way of solving the problem;  we can make do with a lot less entropy if it is /computationally infeasible/ for the attacker to untangle what we have done.
OK, good.
It may help to add a little bit more detail to that analysis.  There are two subcases:
  a) The PRNG starts out in a good state, with a seed that is
   large enough, random enough, and unknown to the attacker.  If    we now use the real-time clock (RTC) to /stir/ the seed, that
   should be sufficient to guarantee no collisions.  That should
   be enough to stop replay attacks.
  b) If the PRNG starts out in a bad state, because the seed has
   been compromised, then the PRNG cannot quickly recover, and in
   particular it cannot recover while it is under attack.  The RTC
   is nowhere near sufficient to /substitute/ for a proper seed.
To say the same thing in slightly different words:  There are two
separate objectives that we need to consider:
  A) Resistance to attack, and
  B) Recovery from compromise.
In some rock-candy world it would be nice to do both at the same time, but in this world, there are situations where a practical
PRNG cannot do both at the same time, and that's OK.
The moral of the story is that it is super-important to make sure
the PRNG is properly seeded.  The seed needs to be big enough,
random enough, and unknown to the attacker.
Note that the RTC does not add real entropy to the PRNG.  All it
does is stir the PRNG.  Assuming the PRNG's hash function is working
properly, (seed + RTC1) should be effectively very different from
(seed + RTC2).  The attacker could try to mount a related-plaintext
attack against the hash, but for any decent cryptologic hash this
should be computationally infeasible.
There is a fundamental conceptual distinction between (a) reseeding
the PRNG with honest-to-goodness entropy and (b) merely stirring
the existing seed.  However, there are some situations in which
stirring suffices.
It shouldn't take much stirring, assuming the hash function is working
properly.  We absolutely require that the RTC produce non-repeating values, but that's about all we really require.  Again, this is all predicated on starting with a high-quality seed.
I hate to sound like a broken record, but the solution is the same in
all cases:  You need a proper seed:  big enough, random enough, and
unknown to the attacker.
The manufacturer reeeeally needs to provision each instance of the
device with a proper seed.  The cost of doing this is ridiculously
small.  The manufacturer already needs to provision things like the
MAC address, hostname, IMEI, et cetera ... and the addition burden
of provisioning the seed for the PRNG is negligible.
Again (!) the solution is the same:  If there is a proper seed, you're
fine.  If there is not a proper seed, you're screwed.
Specific suggestion:
  a) Download the .iso image onto disk.
  b) Provision a proper seed onto the image.
  c) Burn the modified image to CD if desired.
A few years ago I cooked up some tools to do exactly this.  I tried to
get support for it installed into the distributions, but the proposal
was shot down by some "expert" who decided that the RTC was sufficient
security, even if every attacker on earth knew what was in the distributed
seed-file ... and even if every attacker on earth knew what time it was.
More general suggestion:  We ought to produce some sort of "Best Practices"
document that explains to manufacturers, software distributors, VM providers,
et cetera how important it is to provision a proper seed, and explains how
to do it.
We should also provide tools and infrastructure that makes it easy to do
the right thing and hard to do the wrong thing.  For example, in the
general case, unpacking and repacking an .iso image is a pain in the neck,
but if the image is engineered to facilitate rewriting the seed-file the
procedure is much, much simpler.
Following up on a proposal by Jerry Leichter, on 10/25/2013 05:15 AM, I like this idea so much that I implemented it many years ago.  The
command line looks roughly like:
lynx -auth=harpo:swordfish -source ' | randomize kernel from -
I disagree; see below.
Again (!) the key is to have a proper seed stored on the machine
in question.  It's like the proverbial seed-corn:  If you have
none, you're screwed.  If you have some, you can grow more.
Some comments:
a) If you have 256 bits of honest-to-goodness entropy from
 /any/ source, OS or otherwise, then that's more than enough
 to seed the PRNG, and nothing on the list matters.
b) Ditto.
c) Not so good. Ping times are not guaranteed to be always
 different, and not guaranteed to be unknown to the attacker.
 In the crypto business it is conventional to worry about
 MITM attacks.  A scenario where the MITM doesn't need to
 mess with the packet contents, just the packet timing,
 is extra-easy for the attacker.
d) Not so good.  All that stuff is constant, and relatively
 easy for the attacker to know or guess.  The RTC wasn't  mentioned, but it is better than the items that were
 mentioned, in that it is at least non-constant and non-
 repeating.  The RTC cannot /substitute/ for a proper
 stored seed, but it can /stir/ the seed.
e) That's basically the right idea, except that we should
 call it the "stored" seed rather than the "at-birth" seed.
 The stored seed should be changed at frequent intervals.
 This helps with the recovery from compromise.  Perhaps
 more importantly, it reduces the window of vulnerability
 and reduces the value the attacker gets from peeking at  the stored seed.
The cryptography mailing list
cryptography at metzdowd.com

@_date: 2013-10-19 14:21:15
@_author: John Denker 
@_subject: [Cryptography] PRNG WYTM 
OK, the next step in any such discussion is to ask the
famous question, What's Your Threat Model (WYTM).
Several different reasonable answers are possible.
1) At one extreme, we have the "no threat at all" model,
aka the "non-adversarial" model.  Examples include
 *) Doing a Monte Carlo integral in the context of   a molecular dynamics calculation.  The molecules   are not going to attack our PRNG.  They are not   going to cryptanalyze it.  Almost any PRNG is
  "random enough" for this purpose.
 *) Cooperative situations, such as friendly computers
  on a LAN, doing random exponential backoff as part
  of the layer-1 Ethernet CSMA/CD.  Everybody has a
  shared interest in implementing the protocol properly,
  so even if they could break the PRNG they wouldn't
  want to.
 *) Et cetera.  There are tons of examples in this   category.
A PRNG in category (1) could be considered "random" but not "secure".  It is usually adequate to seed this type of PRNG with things like the MAC address, serial number, and time-of-day.
2) At the opposite extreme we have high-stakes adversarial
applications, including military cryptography, banking,
other high-value business communications, high-stakes
gaming, etc. etc. etc.  A PRNG in this category needs to
be *secure* against a wide range of threats.
For tasks in this category, seeding the PRNG with things like the MAC address, serial number, and time-of-day is
nowhere near good enough.  It is a band-aid or worse.
It is security theater.  It gives you "randomness" in some weak sense, but it does not give you security.
The typical modern PRNG in this category consists of a
seed, a counter, a hash function, and a reseeding
mechanism.  Sometimes there is a block cipher in there somewhere, but to a sufficient approximation this is the same basic architecture, just with a fancier hash So let's look in more detail at the threats against such
a PRNG.
*) For starters we have the threat of direct cryptanalysis
of the output.  If the preimage can be found, all further
outputs will be known to the attacker, and probably all past outputs as well, over the span bounded by the nearest past and present reseedings.
The feasibility of finding a preimage depends on the number of bits output by the PRNG.  Therefore there
should be a limit on the number of output bits between
*) Another type of threat is more indirect.  For example,
suppose the PRNG was seeded at boot time from the saved
random-seed file.  It may be possible for the attacker to find this, perhaps by sneaking a peek at an old backup tape or whatever.  Such a threat is independent of the number of bits emitted by the PRNG.  It is hard to say what it /does/ depend on, but in the absence of anything better, wall-clock time is a plausible proxy.  Therefore there should be a time limit on how long a seed file is allowed to remain on disk before it is regenerated, and a time limit between reseedings of the PRNG.
That might be a "solution" in certain favorable cases, but
it is nowhere near being a reliable, general solution.  I
can think of five failure modes in five minutes.  Perhaps
the most obvious is this:  Suppose my system is sitting in
a rack at some colocation provider.  All the attacker needs
to do is rent a box in the same rack, on the same LAN
segment.  Then he knows my MAC address, the time at which
I booted up, and (to a good approximation) the arrival time
of every network packet addressed to me.
Similarly for my laptop on the corporate wifi network.  The
bad guy in the loft across the street has a nontrivial
chance of figuring out everything he needs to know about my network traffic.  If anybody has a proof that this
cannot happen, please explain.
Here's the only thing that has ever made sense to me:
 a) Any device that wants to have any security whatsoever
  needs to be able to store a seed, even when powered off.
 b) The seed needs to be provisioned on a per-device
  basis, much like the MAC address is provisioned.
 c) The seed needs to be big enough, randomly-chosen, and   secret, very unlike the MAC address, RTC, and device   serial number.
The cryptography mailing list
cryptography at metzdowd.com

@_date: 2013-10-27 15:17:14
@_author: John Denker 
@_subject: [Cryptography] [RNG] /dev/random initialisation 
[sources for a good high-entropy seed]
This is excellent.  This is exactly the sort of discussion we
ought to be having.
I agree with the sentiment, but having lots of entropy isn't the only way of solving the problem;  we can make do with a lot less entropy if it is /computationally infeasible/ for the attacker to untangle what we have done.
OK, good.
It may help to add a little bit more detail to that analysis.  There are two subcases:
  a) The PRNG starts out in a good state, with a seed that is
   large enough, random enough, and unknown to the attacker.  If    we now use the real-time clock (RTC) to /stir/ the seed, that
   should be sufficient to guarantee no collisions.  That should
   be enough to stop replay attacks.
  b) If the PRNG starts out in a bad state, because the seed has
   been compromised, then the PRNG cannot quickly recover, and in
   particular it cannot recover while it is under attack.  The RTC
   is nowhere near sufficient to /substitute/ for a proper seed.
To say the same thing in slightly different words:  There are two
separate objectives that we need to consider:
  A) Resistance to attack, and
  B) Recovery from compromise.
In some rock-candy world it would be nice to do both at the same time, but in this world, there are situations where a practical
PRNG cannot do both at the same time, and that's OK.
The moral of the story is that it is super-important to make sure
the PRNG is properly seeded.  The seed needs to be big enough,
random enough, and unknown to the attacker.
Note that the RTC does not add real entropy to the PRNG.  All it
does is stir the PRNG.  Assuming the PRNG's hash function is working
properly, (seed + RTC1) should be effectively very different from
(seed + RTC2).  The attacker could try to mount a related-plaintext
attack against the hash, but for any decent cryptologic hash this
should be computationally infeasible.
There is a fundamental conceptual distinction between (a) reseeding
the PRNG with honest-to-goodness entropy and (b) merely stirring
the existing seed.  However, there are some situations in which
stirring suffices.
It shouldn't take much stirring, assuming the hash function is working
properly.  We absolutely require that the RTC produce non-repeating values, but that's about all we really require.  Again, this is all predicated on starting with a high-quality seed.
I hate to sound like a broken record, but the solution is the same in
all cases:  You need a proper seed:  big enough, random enough, and
unknown to the attacker.
The manufacturer reeeeally needs to provision each instance of the
device with a proper seed.  The cost of doing this is ridiculously
small.  The manufacturer already needs to provision things like the
MAC address, hostname, IMEI, et cetera ... and the addition burden
of provisioning the seed for the PRNG is negligible.
Again (!) the solution is the same:  If there is a proper seed, you're
fine.  If there is not a proper seed, you're screwed.
Specific suggestion:
  a) Download the .iso image onto disk.
  b) Provision a proper seed onto the image.
  c) Burn the modified image to CD if desired.
A few years ago I cooked up some tools to do exactly this.  I tried to
get support for it installed into the distributions, but the proposal
was shot down by some "expert" who decided that the RTC was sufficient
security, even if every attacker on earth knew what was in the distributed
seed-file ... and even if every attacker on earth knew what time it was.
More general suggestion:  We ought to produce some sort of "Best Practices"
document that explains to manufacturers, software distributors, VM providers,
et cetera how important it is to provision a proper seed, and explains how
to do it.
We should also provide tools and infrastructure that makes it easy to do
the right thing and hard to do the wrong thing.  For example, in the
general case, unpacking and repacking an .iso image is a pain in the neck,
but if the image is engineered to facilitate rewriting the seed-file the
procedure is much, much simpler.
Following up on a proposal by Jerry Leichter, on 10/25/2013 05:15 AM, I like this idea so much that I implemented it many years ago.  The
command line looks roughly like:
lynx -auth=harpo:swordfish -source ' | randomize kernel from -
I disagree; see below.
Again (!) the key is to have a proper seed stored on the machine
in question.  It's like the proverbial seed-corn:  If you have
none, you're screwed.  If you have some, you can grow more.
Some comments:
a) If you have 256 bits of honest-to-goodness entropy from
 /any/ source, OS or otherwise, then that's more than enough
 to seed the PRNG, and nothing on the list matters.
b) Ditto.
c) Not so good. Ping times are not guaranteed to be always
 different, and not guaranteed to be unknown to the attacker.
 In the crypto business it is conventional to worry about
 MITM attacks.  A scenario where the MITM doesn't need to
 mess with the packet contents, just the packet timing,
 is extra-easy for the attacker.
d) Not so good.  All that stuff is constant, and relatively
 easy for the attacker to know or guess.  The RTC wasn't  mentioned, but it is better than the items that were
 mentioned, in that it is at least non-constant and non-
 repeating.  The RTC cannot /substitute/ for a proper
 stored seed, but it can /stir/ the seed.
e) That's basically the right idea, except that we should
 call it the "stored" seed rather than the "at-birth" seed.
 The stored seed should be changed at frequent intervals.
 This helps with the recovery from compromise.  Perhaps
 more importantly, it reduces the window of vulnerability
 and reduces the value the attacker gets from peeking at  the stored seed.
The cryptography mailing list
cryptography at metzdowd.com
